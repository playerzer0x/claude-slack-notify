#!/bin/bash
# =============================================================================
# local-tunnel - Start tunnel for Slack button actions
#
# Uses Localtunnel for stable URLs that don't change between restarts.
# Falls back to Cloudflare Quick Tunnels if Localtunnel isn't available.
#
# Commands:
#   local-tunnel               - Start tunnel (prompts to configure stable URL if needed)
#   local-tunnel --setup       - Configure Slack tokens (for auto-URL updates)
#   local-tunnel --update-token - Quick Slack token refresh when expired
#   local-tunnel --background  - Start tunnel in background
#   local-tunnel --stop        - Stop background tunnel
#   local-tunnel --status      - Check tunnel status
# =============================================================================

set -uo pipefail

MCP_PORT=8463
CLAUDE_DIR="$HOME/.claude"
MCP_SERVER="$CLAUDE_DIR/bin/mcp-server"
SLACK_CONFIG_FILE="$CLAUDE_DIR/.slack-config"
WEBHOOK_FILE="$CLAUDE_DIR/slack-webhook-url"
TUNNEL_PID_FILE="$CLAUDE_DIR/.tunnel.pid"
TUNNEL_URL_FILE="$CLAUDE_DIR/.tunnel-url"
WATCHDOG_PID_FILE="$CLAUDE_DIR/.tunnel-watchdog.pid"
ACTIVITY_FILE="$CLAUDE_DIR/.tunnel-last-activity"
TUNNEL_LOG="$CLAUDE_DIR/tunnel.log"
IDLE_TIMEOUT=3600  # 1 hour in seconds
LOCALTUNNEL_SUBDOMAIN_FILE="$CLAUDE_DIR/.localtunnel-subdomain"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

echo_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
echo_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
echo_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# =============================================================================
# Slack API helpers
# =============================================================================

# Load Slack config
load_slack_config() {
    if [[ ! -f "$SLACK_CONFIG_FILE" ]]; then
        return 1
    fi
    # Source the config file (sets SLACK_APP_ID, SLACK_ACCESS_TOKEN, SLACK_REFRESH_TOKEN, SLACK_TOKEN_EXPIRES)
    source "$SLACK_CONFIG_FILE"
    return 0
}

# Save Slack config
save_slack_config() {
    cat > "$SLACK_CONFIG_FILE" << EOF
SLACK_APP_ID="$SLACK_APP_ID"
SLACK_ACCESS_TOKEN="$SLACK_ACCESS_TOKEN"
SLACK_REFRESH_TOKEN="$SLACK_REFRESH_TOKEN"
SLACK_TOKEN_EXPIRES="$SLACK_TOKEN_EXPIRES"
SLACK_BOT_TOKEN="${SLACK_BOT_TOKEN:-}"
SLACK_CHANNEL_ID="${SLACK_CHANNEL_ID:-}"
EOF
    chmod 600 "$SLACK_CONFIG_FILE"
}

# =============================================================================
# Localtunnel config (stable URL)
# =============================================================================

has_stable_tunnel() {
    [[ -f "$LOCALTUNNEL_SUBDOMAIN_FILE" ]]
}

get_localtunnel_subdomain() {
    cat "$LOCALTUNNEL_SUBDOMAIN_FILE" 2>/dev/null
}

# Check if token is expired (with 5 minute buffer)
is_token_expired() {
    local now
    now=$(date +%s)
    local buffer=300  # 5 minutes
    if [[ -z "${SLACK_TOKEN_EXPIRES:-}" ]] || [[ $((SLACK_TOKEN_EXPIRES - buffer)) -lt $now ]]; then
        return 0  # expired
    fi
    return 1  # not expired
}

# Rotate the Slack token using refresh token
rotate_slack_token() {
    echo_info "Refreshing Slack configuration token..."

    local response
    response=$(curl -s -X POST "https://slack.com/api/tooling.tokens.rotate" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "refresh_token=${SLACK_REFRESH_TOKEN}")

    local ok
    ok=$(echo "$response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$response" | jq -r '.error // "unknown error"')
        echo_error "Failed to refresh token: $error"
        echo_error "Run 'local-tunnel --update-token' to refresh"
        return 1
    fi

    SLACK_ACCESS_TOKEN=$(echo "$response" | jq -r '.token')
    SLACK_REFRESH_TOKEN=$(echo "$response" | jq -r '.refresh_token')
    local exp
    exp=$(echo "$response" | jq -r '.exp')
    SLACK_TOKEN_EXPIRES="$exp"

    save_slack_config
    echo_info "Token refreshed successfully"
    return 0
}

# Update Slack app's Request URLs (actions + events)
update_slack_request_url() {
    local actions_url="$1"
    local events_url="${2:-}"  # Optional for backward compatibility

    # Ensure token is valid
    if is_token_expired; then
        if ! rotate_slack_token; then
            return 1
        fi
    fi

    echo_info "Updating Slack Request URLs..."

    # Export current manifest
    local manifest_response
    manifest_response=$(curl -s -X POST "https://slack.com/api/apps.manifest.export" \
        -H "Authorization: Bearer ${SLACK_ACCESS_TOKEN}" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "app_id=${SLACK_APP_ID}")

    local ok
    ok=$(echo "$manifest_response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$manifest_response" | jq -r '.error // "unknown error"')
        echo_error "Failed to export manifest: $error"
        return 1
    fi

    # Update interactivity URL (for buttons) and optionally event_subscriptions URL (for thread replies)
    local updated_manifest
    if [[ -n "$events_url" ]]; then
        updated_manifest=$(echo "$manifest_response" | jq --arg actions_url "$actions_url" --arg events_url "$events_url" '
            .manifest.settings.interactivity.is_enabled = true |
            .manifest.settings.interactivity.request_url = $actions_url |
            .manifest.settings.event_subscriptions.request_url = $events_url |
            .manifest
        ')
    else
        updated_manifest=$(echo "$manifest_response" | jq --arg url "$actions_url" '
            .manifest.settings.interactivity.is_enabled = true |
            .manifest.settings.interactivity.request_url = $url |
            .manifest
        ')
    fi

    # Update the manifest
    local update_response
    update_response=$(curl -s -X POST "https://slack.com/api/apps.manifest.update" \
        -H "Authorization: Bearer ${SLACK_ACCESS_TOKEN}" \
        -H "Content-Type: application/json" \
        -d "{\"app_id\": \"${SLACK_APP_ID}\", \"manifest\": ${updated_manifest}}")

    ok=$(echo "$update_response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$update_response" | jq -r '.error // "unknown error"')
        echo_error "Failed to update manifest: $error"

        # Show more details if available
        local errors
        errors=$(echo "$update_response" | jq -r '.errors // empty')
        if [[ -n "$errors" ]]; then
            echo_error "Details: $errors"
        fi
        return 1
    fi

    echo_info "Slack URLs updated:"
    echo_info "  Actions: $actions_url"
    if [[ -n "$events_url" ]]; then
        echo_info "  Events:  $events_url"
    fi
    return 0
}

# =============================================================================
# MCP server helpers
# =============================================================================

check_mcp_server() {
    if curl -s "http://localhost:$MCP_PORT/health" &>/dev/null; then
        return 0
    fi
    return 1
}

find_mcp_source_dir() {
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

    if [[ -L "$CLAUDE_DIR/bin/mcp-server" ]]; then
        local target
        target="$(readlink "$CLAUDE_DIR/bin/mcp-server")"
        local repo_dir
        repo_dir="$(dirname "$target")/.."
        if [[ -d "$repo_dir/mcp-server/src" ]]; then
            echo "$repo_dir/mcp-server"
            return 0
        fi
    fi

    if [[ -d "$script_dir/../mcp-server/src" ]]; then
        echo "$script_dir/../mcp-server"
        return 0
    fi

    return 1
}

rebuild_if_needed() {
    local mcp_source_dir
    if ! mcp_source_dir=$(find_mcp_source_dir); then
        return 0
    fi

    local src_dir="$mcp_source_dir/src"
    local dist_dir="$mcp_source_dir/dist"
    local installed_dist="$CLAUDE_DIR/mcp-server-dist/dist"

    local newest_src
    newest_src=$(find "$src_dir" -name "*.ts" -type f -exec stat -f "%m %N" {} \; 2>/dev/null | sort -rn | head -1 | cut -d' ' -f1)

    local oldest_dist=0
    if [[ -d "$dist_dir" ]]; then
        oldest_dist=$(find "$dist_dir" -name "*.js" -type f -exec stat -f "%m %N" {} \; 2>/dev/null | sort -n | head -1 | cut -d' ' -f1)
    fi

    if [[ -n "$newest_src" ]] && [[ "$newest_src" -gt "$oldest_dist" ]]; then
        echo_info "Source files changed, rebuilding MCP server..."
        (
            cd "$mcp_source_dir"
            if command -v bun &>/dev/null; then
                bun run build
            elif command -v npm &>/dev/null; then
                npm run build
            else
                echo_warn "No build tool found (bun/npm), skipping rebuild"
                return 0
            fi
        )

        if [[ -d "$installed_dist" ]]; then
            cp -r "$dist_dir"/* "$installed_dist"/
            echo_info "Updated installed MCP server"
        fi
    fi
}

start_mcp_server() {
    if [[ ! -x "$MCP_SERVER" ]]; then
        echo_error "MCP server not found at $MCP_SERVER"
        echo_error "Run install.sh first to build the MCP server"
        exit 1
    fi

    echo_info "Starting MCP server..."
    nohup "$MCP_SERVER" > "$CLAUDE_DIR/mcp-server.log" 2>&1 &
    MCP_PID=$!
    echo "$MCP_PID" > "$CLAUDE_DIR/.mcp-server.pid"

    for i in {1..10}; do
        if check_mcp_server; then
            echo_info "MCP server started (PID: $MCP_PID)"
            return 0
        fi
        sleep 0.5
    done

    echo_error "MCP server failed to start. Check $CLAUDE_DIR/mcp-server.log"
    exit 1
}

stop_mcp_server() {
    local pid_file="$CLAUDE_DIR/.mcp-server.pid"
    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            rm -f "$pid_file"
            echo_info "MCP server stopped"
        fi
    fi
}

# =============================================================================
# Sync tunnel URL to remote servers
# =============================================================================

sync_tunnel_url_to_remotes() {
    local links_dir="$CLAUDE_DIR/links"
    if [[ ! -d "$links_dir" ]]; then
        return 0
    fi

    local mac_url_file="$CLAUDE_DIR/.mac-tunnel-url"
    if [[ ! -f "$mac_url_file" ]]; then
        return 0
    fi

    # Find unique remote hosts from link files
    local hosts_synced=0
    local seen_hosts=""

    for link_file in "$links_dir"/*.json; do
        [[ -f "$link_file" ]] || continue

        local ssh_host ssh_user ssh_port
        ssh_host=$(grep -o '"ssh_host": *"[^"]*"' "$link_file" 2>/dev/null | cut -d'"' -f4)
        ssh_user=$(grep -o '"ssh_user": *"[^"]*"' "$link_file" 2>/dev/null | cut -d'"' -f4)
        ssh_port=$(grep -o '"ssh_port": *"[^"]*"' "$link_file" 2>/dev/null | cut -d'"' -f4)

        # Skip if no SSH info or already synced to this host
        [[ -z "$ssh_host" ]] && continue
        [[ "$seen_hosts" == *"$ssh_user@$ssh_host:$ssh_port"* ]] && continue

        seen_hosts="$seen_hosts $ssh_user@$ssh_host:$ssh_port"

        # Try to sync (non-blocking, best effort)
        if scp -o BatchMode=yes -o ConnectTimeout=2 -P "${ssh_port:-22}" \
            "$mac_url_file" "${ssh_user}@${ssh_host}:~/.claude/.mac-tunnel-url" 2>/dev/null; then
            ((hosts_synced++)) || true
        fi
    done

    if [[ $hosts_synced -gt 0 ]]; then
        echo_info "Synced tunnel URL to $hosts_synced remote host(s)"
    fi
}

# =============================================================================
# Idle watchdog (for --background mode)
# =============================================================================

start_watchdog() {
    touch "$ACTIVITY_FILE"

    (
        while true; do
            sleep 300  # Check every 5 minutes

            if [[ ! -f "$ACTIVITY_FILE" ]]; then
                continue
            fi

            local last now
            if [[ "$(uname)" == "Darwin" ]]; then
                last=$(stat -f %m "$ACTIVITY_FILE" 2>/dev/null || echo 0)
            else
                last=$(stat -c %Y "$ACTIVITY_FILE" 2>/dev/null || echo 0)
            fi
            now=$(date +%s)

            if [[ $((now - last)) -gt $IDLE_TIMEOUT ]]; then
                echo "$(date): Idle timeout ($IDLE_TIMEOUT seconds), shutting down" >> "$TUNNEL_LOG"

                if [[ -f "$TUNNEL_PID_FILE" ]]; then
                    local tunnel_pid
                    tunnel_pid=$(cat "$TUNNEL_PID_FILE")
                    kill "$tunnel_pid" 2>/dev/null || true
                    rm -f "$TUNNEL_PID_FILE"
                fi

                stop_mcp_server
                rm -f "$ACTIVITY_FILE"
                rm -f "$WATCHDOG_PID_FILE"
                exit 0
            fi
        done
    ) &
    local watchdog_pid=$!
    echo "$watchdog_pid" > "$WATCHDOG_PID_FILE"
    echo_info "Idle watchdog started (timeout: ${IDLE_TIMEOUT}s)"
}

stop_watchdog() {
    if [[ -f "$WATCHDOG_PID_FILE" ]]; then
        local pid
        pid=$(cat "$WATCHDOG_PID_FILE")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
        fi
        rm -f "$WATCHDOG_PID_FILE"
    fi
}

# =============================================================================
# Start tunnel and get URL
# =============================================================================

start_tunnel_and_get_url() {
    local background="${1:-false}"
    local log_file="$CLAUDE_DIR/.tunnel.log"

    # Kill any existing tunnel processes
    pkill -f "cloudflared tunnel" 2>/dev/null || true
    pkill -f "^lt --port" 2>/dev/null || true
    rm -f "$TUNNEL_PID_FILE" "$TUNNEL_URL_FILE" "$log_file"
    sleep 0.5

    # Priority 1: Localtunnel with saved subdomain (simplest stable option)
    if has_stable_tunnel; then
        local subdomain
        subdomain=$(get_localtunnel_subdomain)

        if ! command -v lt &>/dev/null; then
            echo_warn "Localtunnel not installed. Installing..."
            if command -v bun &>/dev/null; then
                bun add -g localtunnel
            elif command -v npm &>/dev/null; then
                npm install -g localtunnel
            else
                echo_error "Cannot install localtunnel. Falling back to cloudflared."
                rm -f "$LOCALTUNNEL_SUBDOMAIN_FILE"
                start_tunnel_and_get_url "$background"
                return
            fi
        fi

        echo_info "Starting Localtunnel (stable URL: ${subdomain}.loca.lt)..."

        if [[ "$background" == "true" ]]; then
            nohup lt --port "$MCP_PORT" --subdomain "$subdomain" > "$log_file" 2>&1 &
        else
            lt --port "$MCP_PORT" --subdomain "$subdomain" > "$log_file" 2>&1 &
        fi
        TUNNEL_PID=$!
        echo "$TUNNEL_PID" > "$TUNNEL_PID_FILE"

        # Wait for URL to appear
        local tunnel_url=""
        for i in {1..20}; do
            if [[ -f "$log_file" ]]; then
                tunnel_url=$(grep -oE 'https://[a-z0-9-]+\.loca\.lt' "$log_file" 2>/dev/null | head -1 || true)
                if [[ -n "$tunnel_url" ]]; then
                    break
                fi
            fi
            sleep 0.5
        done

        if [[ -z "$tunnel_url" ]]; then
            echo_error "Failed to start localtunnel"
            cat "$log_file" 2>/dev/null | tail -5
            kill "$TUNNEL_PID" 2>/dev/null || true
            rm -f "$TUNNEL_PID_FILE"
            exit 1
        fi

        echo "$tunnel_url" > "$TUNNEL_URL_FILE"
        TUNNEL_URL="$tunnel_url"
        echo_info "Tunnel started: $tunnel_url"

    # Fallback: Cloudflare quick tunnel (random URL)
    else
        if ! command -v cloudflared &>/dev/null; then
            echo_error "No tunnel provider available."
            echo ""
            echo -e "  Install one of:"
            echo -e "    ${BOLD}bun add -g localtunnel${NC}  (recommended for stable URLs)"
            echo -e "    ${BOLD}brew install cloudflared${NC}  (random URLs each restart)"
            exit 1
        fi

        echo_info "Starting Cloudflare Quick Tunnel (random URL)..."
        echo -e "  ${DIM}Tip: Run 'local-tunnel --stable' for a permanent URL${NC}"

        if [[ "$background" == "true" ]]; then
            nohup cloudflared tunnel --url "http://localhost:$MCP_PORT" > "$log_file" 2>&1 &
        else
            cloudflared tunnel --url "http://localhost:$MCP_PORT" > "$log_file" 2>&1 &
        fi
        TUNNEL_PID=$!
        echo "$TUNNEL_PID" > "$TUNNEL_PID_FILE"

        # Wait for URL to appear in logs
        local tunnel_url=""
        for i in {1..30}; do
            if [[ -f "$log_file" ]]; then
                tunnel_url=$(grep -oE 'https://[a-z0-9-]+\.trycloudflare\.com' "$log_file" 2>/dev/null | tail -1 || true)
                if [[ -n "$tunnel_url" ]]; then
                    break
                fi
            fi
            sleep 0.5
        done

        if [[ -z "$tunnel_url" ]]; then
            echo_error "Failed to get tunnel URL"
            cat "$log_file" 2>/dev/null | tail -10
            kill "$TUNNEL_PID" 2>/dev/null || true
            rm -f "$TUNNEL_PID_FILE"
            exit 1
        fi

        echo "$tunnel_url" > "$TUNNEL_URL_FILE"
        TUNNEL_URL="$tunnel_url"
        echo_info "Tunnel started: $tunnel_url"
    fi

    # Save to .mac-tunnel-url for remote-relay auto-detect
    MAC_TUNNEL_URL_FILE="$CLAUDE_DIR/.mac-tunnel-url"
    echo "$TUNNEL_URL" > "$MAC_TUNNEL_URL_FILE"

    # Optionally sync to remote Linux servers (if links exist)
    sync_tunnel_url_to_remotes
}

# =============================================================================
# --setup: Configure Slack API tokens
# =============================================================================

cmd_setup() {
    echo ""
    echo -e "${BOLD}Slack Tunnel Setup${NC}"
    echo -e "${DIM}Configure automatic Request URL updates${NC}"
    echo ""

    # Check dependencies
    if ! command -v jq &>/dev/null; then
        echo_error "jq is required but not installed."
        echo "  Install with: brew install jq (macOS) or apt install jq (Linux)"
        exit 1
    fi

    if ! command -v lt &>/dev/null && ! command -v cloudflared &>/dev/null; then
        echo_error "A tunnel provider is required but none installed."
        echo "  Install one of:"
        echo "    bun add -g localtunnel  (recommended)"
        echo "    brew install cloudflared"
        exit 1
    fi

    echo -e "${CYAN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${CYAN}│${NC}  ${BOLD}Step 1: Generate a Configuration Token${NC}                     ${CYAN}│${NC}"
    echo -e "${CYAN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  ${CYAN}1.${NC} Go to ${BOLD}https://api.slack.com/apps${NC}"
    echo -e "  ${CYAN}2.${NC} Scroll to the ${BOLD}bottom${NC} of the page (below your apps list)"
    echo -e "  ${CYAN}3.${NC} Find ${BOLD}\"Your App Configuration Tokens\"${NC} section"
    echo -e "  ${CYAN}4.${NC} Click ${BOLD}\"Generate Token\"${NC}"
    echo -e "  ${CYAN}5.${NC} Select your ${BOLD}workspace${NC} from the dropdown"
    echo -e "  ${CYAN}6.${NC} Click ${BOLD}\"Generate\"${NC}"
    echo ""
    echo -e "  ${DIM}(This adds \"Slack Tooling Tokens Vendor\" app to your workspace)${NC}"
    echo ""
    echo -e "  ${CYAN}7.${NC} Copy the ${BOLD}Access Token${NC} (starts with xoxe-...)"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Paste the Access Token: "
    read -r SLACK_ACCESS_TOKEN

    if [[ -z "$SLACK_ACCESS_TOKEN" ]]; then
        echo_error "Access token is required"
        exit 1
    fi

    echo ""
    echo -e "  ${CYAN}8.${NC} Copy the ${BOLD}Refresh Token${NC} (shown below the access token)"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Paste the Refresh Token: "
    read -r SLACK_REFRESH_TOKEN

    if [[ -z "$SLACK_REFRESH_TOKEN" ]]; then
        echo_error "Refresh token is required"
        exit 1
    fi

    # Set initial expiry (12 hours from now, but we'll refresh before using)
    SLACK_TOKEN_EXPIRES=$(($(date +%s) + 43200))

    echo ""
    echo -e "${CYAN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${CYAN}│${NC}  ${BOLD}Step 2: Get your Slack App ID${NC}                               ${CYAN}│${NC}"
    echo -e "${CYAN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  ${BOLD}If you don't have an app yet:${NC}"
    echo -e "    ${CYAN}1.${NC} Click ${BOLD}Create New App${NC}"
    echo -e "    ${CYAN}2.${NC} Select ${BOLD}From scratch${NC}"
    echo -e "    ${CYAN}3.${NC} Name it ${BOLD}Claude Code Notifier${NC} (or similar)"
    echo -e "    ${CYAN}4.${NC} Select your workspace → Click ${BOLD}Create App${NC}"
    echo ""
    echo -e "  ${BOLD}Then:${NC}"
    echo -e "    ${CYAN}5.${NC} Copy the ${BOLD}App ID${NC} from the top of the page"
    echo -e "       ${DIM}(Format: A0XXXXXXXXX)${NC}"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Paste your App ID: "
    read -r SLACK_APP_ID

    if [[ -z "$SLACK_APP_ID" || ! "$SLACK_APP_ID" =~ ^A[A-Z0-9]+$ ]]; then
        echo_error "Invalid App ID format. Should start with 'A' followed by letters/numbers."
        exit 1
    fi

    # Save config
    save_slack_config
    echo ""
    echo_info "Configuration saved to $SLACK_CONFIG_FILE"

    # Verify by testing the token
    echo ""
    echo_info "Verifying configuration..."

    local test_response
    test_response=$(curl -s -X POST "https://slack.com/api/apps.manifest.export" \
        -H "Authorization: Bearer ${SLACK_ACCESS_TOKEN}" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "app_id=${SLACK_APP_ID}")

    local ok
    ok=$(echo "$test_response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$test_response" | jq -r '.error // "unknown error"')
        echo_error "Configuration test failed: $error"
        echo_error "Please check your tokens and try again."
        rm -f "$SLACK_CONFIG_FILE"
        exit 1
    fi

    echo ""
    echo -e "${GREEN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${GREEN}│${NC}  ${GREEN}✓${NC} ${BOLD}Basic Setup Complete!${NC}                                     ${GREEN}│${NC}"
    echo -e "${GREEN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""

    # Webhook setup
    echo -e "${CYAN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${CYAN}│${NC}  ${BOLD}Step 3: Webhook URL${NC}                                         ${CYAN}│${NC}"
    echo -e "${CYAN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  ${DIM}Webhooks enable basic notifications (buttons come later).${NC}"
    echo ""
    echo -e "  ${CYAN}1.${NC} Go to your app: ${BOLD}https://api.slack.com/apps/${SLACK_APP_ID}${NC}"
    echo -e "  ${CYAN}2.${NC} Click ${BOLD}Incoming Webhooks${NC}"
    echo -e "  ${CYAN}3.${NC} Toggle ${BOLD}Activate Incoming Webhooks${NC} to On"
    echo -e "  ${CYAN}4.${NC} Click ${BOLD}Add New Webhook to Workspace${NC}"
    echo -e "  ${CYAN}5.${NC} Select your notification channel → Click ${BOLD}Allow${NC}"
    echo -e "  ${CYAN}6.${NC} Copy the webhook URL"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Paste webhook URL: "
    read -r webhook_url

    if [[ -n "$webhook_url" ]]; then
        echo "$webhook_url" > "$WEBHOOK_FILE"
        chmod 600 "$WEBHOOK_FILE"
        echo_info "Webhook URL saved"
    else
        echo_warn "Skipped - notifications won't work without a webhook URL"
    fi
    echo ""

    # Optional: Bot token for thread replies
    echo -e "${CYAN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${CYAN}│${NC}  ${BOLD}Optional: Enable Thread Replies${NC}                            ${CYAN}│${NC}"
    echo -e "${CYAN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  ${DIM}Reply to Claude notifications to send messages to the terminal.${NC}"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Enable thread replies? [Y/n] "
    read -r enable_threads

    if [[ ! "$enable_threads" =~ ^[Nn]$ ]]; then
        echo ""
        echo -e "  ${CYAN}1.${NC} Go to your app: ${BOLD}https://api.slack.com/apps/${SLACK_APP_ID}${NC}"
        echo -e "  ${CYAN}2.${NC} Click ${BOLD}OAuth & Permissions${NC}"
        echo -e "  ${CYAN}3.${NC} Under ${BOLD}Bot Token Scopes${NC}, add:"
        echo -e "       ${BOLD}app_mentions:read${NC} - View messages that mention your bot"
        echo -e "       ${BOLD}channels:history${NC} - View messages in channels the bot is in"
        echo -e "       ${BOLD}chat:write${NC} - Send messages"
        echo -e "       ${BOLD}files:read${NC} - Download images from replies"
        echo -e "  ${CYAN}4.${NC} Click ${BOLD}Install to Workspace${NC} (or Reinstall)"
        echo -e "  ${CYAN}5.${NC} Copy the ${BOLD}Bot User OAuth Token${NC} (starts with xoxb-)"
        echo ""
        echo -ne "  ${YELLOW}?${NC} Bot Token: "
        read -r SLACK_BOT_TOKEN

        if [[ -n "$SLACK_BOT_TOKEN" ]]; then
            echo ""
            echo -e "  ${CYAN}6.${NC} Go to ${BOLD}Event Subscriptions${NC}"
            echo -e "  ${CYAN}7.${NC} Toggle ${BOLD}Enable Events${NC} to On"
            echo -e "  ${CYAN}8.${NC} Under ${BOLD}Subscribe to bot events${NC}, add:"
            echo -e "       ${BOLD}message.channels${NC}"
            echo -e "       ${BOLD}message.im${NC} (for DMs)"
            echo -e "  ${CYAN}9.${NC} Save Changes"
            echo ""
            echo -e "  ${DIM}The Request URL will be set automatically when you start the tunnel.${NC}"

            save_slack_config
            echo ""
            echo_info "Bot token saved!"
        fi
    fi

    # Channel ID for thread routing
    echo ""
    echo -e "${CYAN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${CYAN}│${NC}  ${BOLD}Notification Channel${NC}                                        ${CYAN}│${NC}"
    echo -e "${CYAN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  ${DIM}What channel should notifications go to?${NC}"
    echo -e "  ${DIM}(Right-click channel → View channel details → scroll to Channel ID)${NC}"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Channel ID (e.g., C01234ABCDE): "
    read -r SLACK_CHANNEL_ID

    if [[ -n "$SLACK_CHANNEL_ID" ]]; then
        save_slack_config
        echo_info "Channel ID saved"
    else
        echo_warn "Skipped - can set later in ~/.claude/.slack-config"
    fi

    echo ""
    echo -e "  ${BOLD}To start the tunnel:${NC}"
    echo -e "    local-tunnel"
    echo ""
    echo -e "  ${BOLD}Or for background mode:${NC}"
    echo -e "    local-tunnel --background"
    echo ""
}

# =============================================================================
# --update-token: Quick token refresh (when token expired)
# =============================================================================

cmd_update_token() {
    echo ""
    echo -e "${BOLD}Update Slack Configuration Token${NC}"
    echo -e "${DIM}Quick refresh when your token has expired${NC}"
    echo ""

    # Must have existing config
    if [[ ! -f "$SLACK_CONFIG_FILE" ]]; then
        echo_error "No existing configuration found."
        echo "  Run: local-tunnel --setup"
        exit 1
    fi

    # Load existing config to get App ID
    source "$SLACK_CONFIG_FILE"

    if [[ -z "${SLACK_APP_ID:-}" ]]; then
        echo_error "App ID not found in config."
        echo "  Run: local-tunnel --setup"
        exit 1
    fi

    echo -e "  Current App ID: ${BOLD}${SLACK_APP_ID}${NC}"
    echo ""

    # Open browser to config tokens page
    echo -e "${CYAN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${CYAN}│${NC}  ${BOLD}Generate New Configuration Token${NC}                          ${CYAN}│${NC}"
    echo -e "${CYAN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""

    local config_url="https://api.slack.com/apps"
    echo -e "  Opening: ${BOLD}${config_url}${NC}"
    echo ""

    # Try to open browser
    if command -v open &>/dev/null; then
        open "$config_url" 2>/dev/null || true
    elif command -v xdg-open &>/dev/null; then
        xdg-open "$config_url" 2>/dev/null || true
    fi

    echo -e "  ${CYAN}1.${NC} Scroll to the ${BOLD}bottom${NC} of the page"
    echo -e "  ${CYAN}2.${NC} Find ${BOLD}\"Your App Configuration Tokens\"${NC} section"
    echo -e "  ${CYAN}3.${NC} Click ${BOLD}\"Generate Token\"${NC} (or regenerate existing)"
    echo -e "  ${CYAN}4.${NC} Select your workspace and click ${BOLD}\"Generate\"${NC}"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Paste the Access Token (xoxe-...): "
    read -r SLACK_ACCESS_TOKEN

    if [[ -z "$SLACK_ACCESS_TOKEN" ]]; then
        echo_error "Access token is required"
        exit 1
    fi

    echo ""
    echo -ne "  ${YELLOW}?${NC} Paste the Refresh Token: "
    read -r SLACK_REFRESH_TOKEN

    if [[ -z "$SLACK_REFRESH_TOKEN" ]]; then
        echo_error "Refresh token is required"
        exit 1
    fi

    # Set expiry
    SLACK_TOKEN_EXPIRES=$(($(date +%s) + 43200))

    # Save config
    save_slack_config
    echo ""
    echo_info "Configuration saved!"

    # Verify
    echo_info "Verifying token..."

    local test_response
    test_response=$(curl -s -X POST "https://slack.com/api/apps.manifest.export" \
        -H "Authorization: Bearer ${SLACK_ACCESS_TOKEN}" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "app_id=${SLACK_APP_ID}")

    local ok
    ok=$(echo "$test_response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$test_response" | jq -r '.error // "unknown error"')
        echo_error "Token verification failed: $error"
        exit 1
    fi

    echo ""
    echo -e "${GREEN}✓${NC} Token updated successfully!"
    echo ""
    echo -e "  ${DIM}The token will auto-refresh as long as you run the tunnel regularly.${NC}"
    echo ""
}

# =============================================================================
# --stable: Setup stable URL with Localtunnel and start tunnel
# =============================================================================

cmd_stable() {
    # Check if localtunnel is installed
    if ! command -v lt &>/dev/null; then
        echo_warn "Localtunnel not installed. Installing..."
        echo ""
        if command -v bun &>/dev/null; then
            bun add -g localtunnel
        elif command -v npm &>/dev/null; then
            npm install -g localtunnel
        else
            echo_error "Neither bun nor npm found. Please install Node.js first."
            exit 1
        fi
        echo ""
    fi

    # If already configured, ask if they want to reconfigure or just start
    if has_stable_tunnel; then
        local current
        current=$(get_localtunnel_subdomain)
        local tunnel_url="https://${current}.loca.lt"

        echo ""
        echo -e "  ${GREEN}✓${NC} Stable URL already configured: ${CYAN}${tunnel_url}${NC}"
        echo ""
        echo -ne "  ${YELLOW}?${NC} Change subdomain? [y/N] "
        read -r change_subdomain

        if [[ ! "$change_subdomain" =~ ^[Yy]$ ]]; then
            # Just start the tunnel with existing config
            echo ""
            cmd_interactive
            return
        fi
        echo ""
    fi

    # Setup flow
    echo ""
    echo -e "${BOLD}Stable Tunnel Setup${NC}"
    echo -e "${DIM}Get a URL that stays the same every time${NC}"
    echo ""

    echo -e "  ${GREEN}✓${NC} URL stays the same every restart"
    echo -e "  ${GREEN}✓${NC} No accounts or tokens needed"
    echo -e "  ${GREEN}✓${NC} Set Slack URLs once, never again"
    echo ""

    echo -e "  Choose a unique subdomain for your tunnel."
    echo -e "  ${DIM}Pick something unlikely to be taken (e.g., claude-slack-yourname)${NC}"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Subdomain: "
    read -r subdomain

    if [[ -z "$subdomain" ]]; then
        echo_error "Subdomain is required"
        exit 1
    fi

    # Remove any protocol or domain suffix if user pasted full URL
    subdomain="${subdomain#https://}"
    subdomain="${subdomain%.loca.lt}"
    subdomain="${subdomain%%/*}"

    # Validate subdomain (alphanumeric and hyphens only)
    if [[ ! "$subdomain" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$ ]]; then
        echo_error "Invalid subdomain. Use only letters, numbers, and hyphens."
        exit 1
    fi

    # Save subdomain
    echo "$subdomain" > "$LOCALTUNNEL_SUBDOMAIN_FILE"
    chmod 600 "$LOCALTUNNEL_SUBDOMAIN_FILE"

    local tunnel_url="https://${subdomain}.loca.lt"

    echo ""
    echo_info "Testing tunnel..."

    # Test the tunnel briefly
    local log_file="$CLAUDE_DIR/.localtunnel-test.log"
    rm -f "$log_file"

    lt --port "$MCP_PORT" --subdomain "$subdomain" > "$log_file" 2>&1 &
    local test_pid=$!

    local connected=""
    for i in {1..10}; do
        if grep -q "your url is" "$log_file" 2>/dev/null; then
            connected="true"
            break
        fi
        sleep 1
    done

    kill "$test_pid" 2>/dev/null || true
    wait "$test_pid" 2>/dev/null || true

    if [[ -z "$connected" ]]; then
        echo_warn "Could not verify tunnel. The subdomain might be taken."
        echo -e "  ${DIM}Try a more unique name if it doesn't work.${NC}"
        cat "$log_file" 2>/dev/null | tail -3
    else
        echo -e "  ${GREEN}✓${NC} Tunnel works!"
    fi

    echo ""
    echo -e "${GREEN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${GREEN}│${NC}  ${GREEN}✓${NC} ${BOLD}Stable URL Configured!${NC}                                    ${GREEN}│${NC}"
    echo -e "${GREEN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  ${BOLD}Your stable URL:${NC} ${CYAN}${tunnel_url}${NC}"
    echo ""

    # Try to auto-update Slack if tokens exist
    local slack_updated=false
    if load_slack_config && [[ -n "${SLACK_APP_ID:-}" ]]; then
        echo_info "Updating Slack app settings..."
        if update_slack_request_url "${tunnel_url}/slack/actions" "${tunnel_url}/slack/events"; then
            slack_updated=true
            echo -e "  ${GREEN}✓${NC} Slack Request URLs updated automatically!"
            echo ""
        fi
    fi

    if [[ "$slack_updated" != "true" ]]; then
        echo -e "  ${BOLD}Update your Slack app (one-time only):${NC}"
        echo ""
        echo -e "  ${CYAN}1.${NC} Go to ${BOLD}https://api.slack.com/apps${NC} → your app"
        echo -e "  ${CYAN}2.${NC} ${BOLD}Interactivity & Shortcuts${NC} → Request URL:"
        echo -e "       ${BOLD}${tunnel_url}/slack/actions${NC}"
        echo -e "  ${CYAN}3.${NC} ${BOLD}Event Subscriptions${NC} → Request URL:"
        echo -e "       ${BOLD}${tunnel_url}/slack/events${NC}"
        echo ""
    fi

    # Start the tunnel
    echo_info "Starting tunnel..."
    echo ""
    cmd_interactive
}

# =============================================================================
# --background: Start tunnel in background
# =============================================================================

cmd_background() {
    # Check Slack is configured
    if ! load_slack_config; then
        echo_error "Slack not configured. Run: local-tunnel --setup"
        exit 1
    fi

    # Check if already running (and there's only ONE tunnel)
    local tunnel_count
    tunnel_count=$(pgrep -f "cloudflared tunnel.*localhost:${MCP_PORT}" 2>/dev/null | wc -l | tr -d ' ')

    if [[ -f "$TUNNEL_PID_FILE" ]] && [[ "$tunnel_count" -eq 1 ]]; then
        local existing_pid
        existing_pid=$(cat "$TUNNEL_PID_FILE")
        if kill -0 "$existing_pid" 2>/dev/null; then
            echo_info "Tunnel already running (PID: $existing_pid)"
            return 0
        fi
    fi

    # Clean up stale state (multiple tunnels or orphaned PID file)
    if [[ "$tunnel_count" -gt 0 ]]; then
        echo_info "Cleaning up stale tunnel processes..."
    fi
    rm -f "$TUNNEL_PID_FILE"

    # Rebuild MCP server if needed
    rebuild_if_needed

    # Start MCP server if not running
    if ! check_mcp_server; then
        start_mcp_server
    fi

    # Start tunnel
    start_tunnel_and_get_url "true"

    # Update Slack Request URLs (actions + events)
    if ! update_slack_request_url "${TUNNEL_URL}/slack/actions" "${TUNNEL_URL}/slack/events"; then
        echo_warn "Failed to update Slack, but tunnel is running"
        echo_warn "Manually set Request URLs:"
        echo_warn "  Actions: ${TUNNEL_URL}/slack/actions"
        echo_warn "  Events:  ${TUNNEL_URL}/slack/events"
    fi

    # Start idle watchdog
    start_watchdog

    # Touch activity file
    touch "$ACTIVITY_FILE"

    echo_info "Tunnel running in background (PID: $TUNNEL_PID)"
}

# =============================================================================
# --stop: Stop background tunnel
# =============================================================================

cmd_stop() {
    local stopped=false

    if [[ -f "$WATCHDOG_PID_FILE" ]]; then
        stop_watchdog
        stopped=true
    fi

    # Kill the tunnel from PID file
    if [[ -f "$TUNNEL_PID_FILE" ]]; then
        local pid
        pid=$(cat "$TUNNEL_PID_FILE")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            stopped=true
        fi
        rm -f "$TUNNEL_PID_FILE"
    fi

    # Kill ANY remaining cloudflared tunnel processes (cleanup stale tunnels)
    local stale_count=0
    while IFS= read -r pid; do
        if [[ -n "$pid" ]]; then
            kill "$pid" 2>/dev/null || true
            ((stale_count++)) || true
        fi
    done < <(pgrep -f "cloudflared tunnel.*localhost:${MCP_PORT:-8463}" 2>/dev/null || true)

    if [[ "$stale_count" -gt 0 || "$stopped" == "true" ]]; then
        echo_info "Tunnel stopped"
        stopped=true
    fi

    # Remove tunnel URL file
    rm -f "$TUNNEL_URL_FILE"

    if [[ -f "$CLAUDE_DIR/.mcp-server.pid" ]]; then
        stop_mcp_server
        stopped=true
    fi

    rm -f "$ACTIVITY_FILE"

    if [[ "$stopped" == "true" ]]; then
        echo_info "All services stopped"
    else
        echo_info "No services were running"
    fi
}

# =============================================================================
# --status: Check tunnel status
# =============================================================================

cmd_status() {
    echo ""
    echo -e "${BOLD}Tunnel Status${NC}"
    echo ""

    # Check stable tunnel config
    if has_stable_tunnel; then
        local subdomain
        subdomain=$(get_localtunnel_subdomain)
        echo -e "  Mode:       ${GREEN}Localtunnel (stable URL)${NC}"
        echo -e "  URL:        ${CYAN}https://${subdomain}.loca.lt${NC}"
        echo ""
    else
        echo -e "  Mode:       ${YELLOW}Quick Tunnel${NC} (random URL each restart)"
        echo -e "              ${DIM}Run --stable for permanent URL${NC}"
        echo ""

        # Check Slack config (only needed for quick tunnels)
        if [[ -f "$SLACK_CONFIG_FILE" ]]; then
            load_slack_config
            echo -e "  Slack App:  ${CYAN}$SLACK_APP_ID${NC}"
            if is_token_expired; then
                echo -e "  Token:      ${YELLOW}Expired (will refresh on next use)${NC}"
            else
                echo -e "  Token:      ${GREEN}Valid${NC}"
            fi
        else
            echo -e "  Slack:      ${YELLOW}Not configured${NC} (run: local-tunnel --setup)"
        fi
        echo ""
    fi

    # Check tunnel process
    if [[ -f "$TUNNEL_PID_FILE" ]]; then
        local pid
        pid=$(cat "$TUNNEL_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "  Tunnel:     ${GREEN}Running${NC} (PID: $pid)"
            if [[ -f "$TUNNEL_URL_FILE" ]]; then
                local url
                url=$(cat "$TUNNEL_URL_FILE")
                echo -e "  URL:        ${CYAN}$url/slack/actions${NC}"
            fi
        else
            echo -e "  Tunnel:     ${YELLOW}Stopped${NC} (stale PID file)"
        fi
    else
        echo -e "  Tunnel:     ${YELLOW}Stopped${NC}"
    fi

    # Check MCP server
    if check_mcp_server; then
        local mcp_pid=""
        if [[ -f "$CLAUDE_DIR/.mcp-server.pid" ]]; then
            mcp_pid=$(cat "$CLAUDE_DIR/.mcp-server.pid")
        fi
        echo -e "  MCP Server: ${GREEN}Running${NC}${mcp_pid:+ (PID: $mcp_pid)}"
    else
        echo -e "  MCP Server: ${YELLOW}Stopped${NC}"
    fi

    # Check watchdog
    if [[ -f "$WATCHDOG_PID_FILE" ]]; then
        local pid
        pid=$(cat "$WATCHDOG_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "  Watchdog:   ${GREEN}Running${NC}"
        else
            echo -e "  Watchdog:   ${YELLOW}Stopped${NC}"
        fi
    else
        echo -e "  Watchdog:   ${YELLOW}Stopped${NC}"
    fi

    # Check last activity
    if [[ -f "$ACTIVITY_FILE" ]]; then
        local last now elapsed
        if [[ "$(uname)" == "Darwin" ]]; then
            last=$(stat -f %m "$ACTIVITY_FILE" 2>/dev/null || echo 0)
        else
            last=$(stat -c %Y "$ACTIVITY_FILE" 2>/dev/null || echo 0)
        fi
        now=$(date +%s)
        elapsed=$((now - last))
        local remaining=$((IDLE_TIMEOUT - elapsed))
        if [[ $remaining -gt 0 ]]; then
            echo -e "  Idle timer: ${DIM}${remaining}s until auto-stop${NC}"
        fi
    fi

    echo ""
}

# =============================================================================
# Default: Interactive mode
# =============================================================================

cmd_interactive() {
    echo ""
    echo -e "${BOLD}Slack Tunnel for Claude Notifications${NC}"
    echo -e "${DIM}Creates a public URL for Slack button actions${NC}"
    echo ""

    local using_stable_tunnel=false

    # Check if stable tunnel is configured
    if has_stable_tunnel; then
        using_stable_tunnel=true
        local subdomain
        subdomain=$(get_localtunnel_subdomain)
        echo_info "Using stable URL: https://${subdomain}.loca.lt"
    else
        # Quick tunnel mode - need Slack config for auto-URL updates
        if ! load_slack_config; then
            echo_warn "Slack not configured yet."
            echo ""
            echo -e "  ${BOLD}Options:${NC}"
            echo -e "  ${CYAN}1.${NC} Run ${BOLD}--stable${NC} to setup permanent URL (recommended)"
            echo -e "  ${CYAN}2.${NC} Run ${BOLD}--setup${NC} to configure auto-URL updates"
            echo ""
            echo -ne "  ${YELLOW}?${NC} Run setup now? [Y/n] "
            read -r response
            if [[ "$response" =~ ^[Nn]$ ]]; then
                exit 0
            fi
            cmd_setup
            load_slack_config
        fi
    fi

    # Rebuild MCP server if needed
    rebuild_if_needed

    # Kill existing MCP server and start fresh
    if check_mcp_server; then
        echo_info "Stopping existing MCP server..."
        local old_pid
        old_pid=$(cat "$CLAUDE_DIR/.mcp-server.pid" 2>/dev/null)
        if [[ -n "$old_pid" ]]; then
            kill "$old_pid" 2>/dev/null || true
            sleep 1
        fi
    fi
    start_mcp_server

    # Cleanup on exit
    cleanup() {
        echo ""
        echo_info "Shutting down..."
        if [[ -n "${TUNNEL_PID:-}" ]]; then
            kill "$TUNNEL_PID" 2>/dev/null || true
        fi
        stop_mcp_server
        rm -f "$TUNNEL_PID_FILE" "$TUNNEL_URL_FILE"
    }
    trap cleanup EXIT INT TERM

    # Start tunnel
    start_tunnel_and_get_url "false"

    if [[ "$using_stable_tunnel" == "true" ]]; then
        # Stable tunnel - no URL updates needed
        echo ""
        echo -e "${GREEN}╭──────────────────────────────────────────────────────────────╮${NC}"
        echo -e "${GREEN}│${NC}  ${GREEN}✓${NC} ${BOLD}Stable tunnel connected!${NC}                                  ${GREEN}│${NC}"
        echo -e "${GREEN}╰──────────────────────────────────────────────────────────────╯${NC}"
        echo ""
        echo -e "  URL: ${CYAN}${TUNNEL_URL}${NC}"
        echo ""
        echo -e "  ${DIM}Buttons and thread replies will work on both desktop and mobile.${NC}"
        echo -e "  ${DIM}Keep this running. Press Ctrl+C to stop.${NC}"
    else
        # Quick tunnel - try to update Slack URLs
        if update_slack_request_url "${TUNNEL_URL}/slack/actions" "${TUNNEL_URL}/slack/events"; then
            echo ""
            echo -e "${GREEN}╭──────────────────────────────────────────────────────────────╮${NC}"
            echo -e "${GREEN}│${NC}  ${GREEN}✓${NC} ${BOLD}Slack URLs updated automatically!${NC}                         ${GREEN}│${NC}"
            echo -e "${GREEN}╰──────────────────────────────────────────────────────────────╯${NC}"
            echo ""
            echo -e "  Actions URL: ${CYAN}${TUNNEL_URL}/slack/actions${NC}"
            echo -e "  Events URL:  ${CYAN}${TUNNEL_URL}/slack/events${NC}"
            echo ""
            echo -e "  ${DIM}Buttons and thread replies will work on both desktop and mobile.${NC}"
            echo -e "  ${DIM}Keep this running. Press Ctrl+C to stop.${NC}"
        else
            echo ""
            echo -e "${YELLOW}╭──────────────────────────────────────────────────────────────╮${NC}"
            echo -e "${YELLOW}│${NC}  ${YELLOW}!${NC} ${BOLD}Could not auto-update Slack${NC}                               ${YELLOW}│${NC}"
            echo -e "${YELLOW}╰──────────────────────────────────────────────────────────────╯${NC}"
            echo ""
            echo -e "  Actions URL: ${CYAN}${TUNNEL_URL}/slack/actions${NC}"
            echo -e "  Events URL:  ${CYAN}${TUNNEL_URL}/slack/events${NC}"
            echo ""
            echo -e "  ${BOLD}Manually update in Slack:${NC}"
            echo -e "  ${CYAN}1.${NC} Go to ${BOLD}https://api.slack.com/apps/${SLACK_APP_ID:-your-app}${NC}"
            echo -e "  ${CYAN}2.${NC} ${BOLD}Interactivity & Shortcuts${NC} → Set Request URL"
            echo -e "  ${CYAN}3.${NC} ${BOLD}Event Subscriptions${NC} → Set Request URL"
            echo -e "  ${CYAN}4.${NC} Click ${BOLD}Save Changes${NC} on each page"
            echo ""
            echo -e "  ${DIM}Tip: Run ${BOLD}local-tunnel --stable${NC} for a permanent URL.${NC}"
            echo ""
            echo -e "  ${DIM}Keep this running. Press Ctrl+C to stop.${NC}"
        fi
    fi
    echo ""

    # Keep running until interrupted
    wait "$TUNNEL_PID" 2>/dev/null || true
}

# =============================================================================
# Main
# =============================================================================

case "${1:-}" in
    --setup)
        cmd_setup
        ;;
    --update-token)
        cmd_update_token
        ;;
    --background)
        cmd_background
        ;;
    --stop)
        cmd_stop
        ;;
    --status)
        cmd_status
        ;;
    --help|-h)
        echo "Usage: local-tunnel [command]"
        echo ""
        echo "Commands:"
        echo "  (none)         Start tunnel (uses stable URL, prompts to configure if needed)"
        echo "  --setup        Configure Slack tokens (for auto-URL updates)"
        echo "  --update-token Quick Slack token refresh when expired"
        echo "  --background   Start tunnel in background"
        echo "  --stop         Stop background tunnel"
        echo "  --status       Check tunnel status"
        echo ""
        ;;
    --stable|"")
        cmd_stable
        ;;
    *)
        echo_error "Unknown command: $1"
        echo "Run: local-tunnel --help"
        exit 1
        ;;
esac
