#!/bin/bash
# Claude Slack Notifier - Multi-instance aware with clickable focus buttons

CLAUDE_DIR="${HOME}/.claude"
WEBHOOK_FILE="${CLAUDE_DIR}/slack-webhook-url"
INSTANCES_DIR="${CLAUDE_DIR}/instances"
LINKS_DIR="${CLAUDE_DIR}/links"
MIN_DURATION="${CLAUDE_NOTIFY_MIN_SECONDS:-30}"

# Get instance ID - use parent PID to be consistent across hook calls
INSTANCE_ID="${CLAUDE_INSTANCE_ID:-$PPID}"

# Validate INSTANCE_ID to prevent path traversal attacks
# Only allow alphanumeric characters, underscore, and hyphen
if [[ ! "$INSTANCE_ID" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    echo "Error: Invalid INSTANCE_ID format" >&2
    exit 1
fi

INSTANCE_FILE="${INSTANCES_DIR}/${INSTANCE_ID}.json"
TIMESTAMP_FILE="/tmp/claude-prompt-start-${INSTANCE_ID}"

# -----------------------------------------------------------------------------
# Detect terminal environment and build focus URL
# Sets: TERM_TYPE, TERM_TARGET, FOCUS_URL
# -----------------------------------------------------------------------------
# URL encode a string (encode all non-alphanumeric except - _ . ~)
url_encode() {
    local string="$1"
    local length="${#string}"
    local encoded=""
    local c
    for (( i = 0; i < length; i++ )); do
        c="${string:i:1}"
        case "$c" in
            [a-zA-Z0-9._~-]) encoded+="$c" ;;
            *) encoded+=$(printf '%%%02X' "'$c") ;;
        esac
    done
    echo "$encoded"
}

# Escape string for safe embedding in JSON
# Handles: backslash, double quote, newline, carriage return, tab
json_escape() {
    local str="$1"
    str="${str//\\/\\\\}"      # Escape backslashes first
    str="${str//\"/\\\"}"      # Escape double quotes
    str="${str//$'\n'/\\n}"    # Escape newlines
    str="${str//$'\r'/\\r}"    # Escape carriage returns
    str="${str//$'\t'/\\t}"    # Escape tabs
    echo "$str"
}

# Check if MCP server is running (for hybrid button support)
# Checks: 1) PID file with valid process, 2) Health endpoint responds
is_mcp_server_running() {
    local pid_file="${CLAUDE_DIR}/.mcp-server.pid"
    local port_file="${CLAUDE_DIR}/.mcp-server.port"
    local port="${MCP_SERVER_PORT:-8463}"

    # Check PID file first (fastest)
    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file" 2>/dev/null)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
    fi

    # Check port file for custom port
    if [[ -f "$port_file" ]]; then
        port=$(cat "$port_file" 2>/dev/null)
    fi

    # Check if health endpoint responds (catches servers started without PID file)
    if curl -sf "http://localhost:${port}/health" --max-time 1 >/dev/null 2>&1; then
        return 0
    fi

    return 1
}

# -----------------------------------------------------------------------------
# Link command - creates a link for SSH or JupyterLab sessions
# Run this on LOCAL machine before SSH to create a reference to the local terminal
# Usage: claude-slack-notify link [--host <hostname>] [--jupyter] [ssh-options...]
# -----------------------------------------------------------------------------
if [[ "$1" == "link" ]]; then
    shift  # Remove "link" from args

    # Parse options
    SSH_HOST=""
    JUPYTER_MODE=""
    SSH_ARGS=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --host|-h)
                SSH_HOST="$2"
                shift 2
                ;;
            --jupyter|-j)
                JUPYTER_MODE="1"
                shift
                ;;
            *)
                # Collect remaining args as SSH options
                SSH_ARGS+=("$1")
                shift
                ;;
        esac
    done

    mkdir -p "$LINKS_DIR"

    # Generate unique link ID (8 chars, alphanumeric)
    LINK_ID=$(head -c 12 /dev/urandom | base64 | tr -dc 'a-z0-9' | head -c 8)

    # -------------------------------------------------------------------------
    # JupyterLab mode: link Chrome tab running JupyterLab + SSH for input
    # -------------------------------------------------------------------------
    if [[ -n "$JUPYTER_MODE" ]]; then
        if [[ -z "$SSH_HOST" ]]; then
            echo "Error: --jupyter requires --host <server>" >&2
            echo "Usage: claude-slack-notify link --jupyter --host user@server" >&2
            exit 1
        fi

        # Get Chrome tab URL (JupyterLab must be open in Chrome)
        JUPYTER_URL=$(osascript -e 'tell application "Google Chrome" to return URL of active tab of front window' 2>/dev/null)

        if [[ -z "$JUPYTER_URL" ]]; then
            echo "Error: Could not get Chrome tab URL." >&2
            echo "Make sure JupyterLab is open in the active Chrome tab." >&2
            exit 1
        fi

        if [[ "$JUPYTER_URL" != *"lab"* && "$JUPYTER_URL" != *"jupyter"* && "$JUPYTER_URL" != *"notebook"* ]]; then
            echo "Warning: URL doesn't look like JupyterLab: $JUPYTER_URL"
            echo "Continuing anyway..."
        fi

        # Parse SSH_HOST for user@host format
        if [[ "$SSH_HOST" == *"@"* ]]; then
            JUPYTER_SSH_USER="${SSH_HOST%%@*}"
            JUPYTER_SSH_HOST="${SSH_HOST#*@}"
        else
            JUPYTER_SSH_USER=$(whoami)
            JUPYTER_SSH_HOST="$SSH_HOST"
        fi
        JUPYTER_SSH_PORT="${CLAUDE_SSH_PORT:-22}"

        # Save link file with jupyter info
        cat > "$LINKS_DIR/${LINK_ID}.json" << EOF
{
  "link_id": "${LINK_ID}",
  "term_type": "jupyter-tmux",
  "jupyter_url": "${JUPYTER_URL}",
  "ssh_host": "${JUPYTER_SSH_HOST}",
  "ssh_user": "${JUPYTER_SSH_USER}",
  "ssh_port": "${JUPYTER_SSH_PORT}",
  "created_at": "$(date -Iseconds)"
}
EOF

        # SSH to remote and create env file for the JupyterLab terminal to source
        echo "Creating environment file on remote..."
        ssh "${SSH_ARGS[@]}" "$SSH_HOST" "mkdir -p ~/.claude && cat > ~/.claude/jupyter-env << 'ENVEOF'
export CLAUDE_LINK_ID=$LINK_ID
export CLAUDE_SSH_HOST=$JUPYTER_SSH_HOST
ENVEOF"

        if [[ $? -ne 0 ]]; then
            echo "Error: Could not SSH to $SSH_HOST to create env file" >&2
            exit 1
        fi

        echo ""
        echo "╭─────────────────────────────────────────────────────────────╮"
        echo "│  JupyterLab Link Created                                    │"
        echo "╰─────────────────────────────────────────────────────────────╯"
        echo ""
        echo "  Link ID:  $LINK_ID"
        echo "  SSH Host: $SSH_HOST"
        echo "  URL:      $JUPYTER_URL"
        echo ""
        echo "╭─────────────────────────────────────────────────────────────╮"
        echo "│  Next Steps (in JupyterLab terminal)                        │"
        echo "╰─────────────────────────────────────────────────────────────╯"
        echo ""
        echo "  1. source ~/.claude/jupyter-env"
        echo "  2. tmux new -s claude"
        echo "  3. claude"
        echo "  4. /slack-notify"
        echo ""
        exit 0
    fi

    # -------------------------------------------------------------------------
    # Normal mode: link local terminal (iTerm/Terminal.app)
    # -------------------------------------------------------------------------
    # Detect local terminal
    # We need a minimal detect_terminal inline since the function hasn't been defined yet
    LINK_TERM_TYPE="unknown"
    LINK_TERM_TARGET=""
    LINK_FOCUS_URL=""

    case "$(uname -s)" in
        Darwin)
            if [[ -n "$TMUX" ]]; then
                local_session=$(tmux display-message -p '#{session_name}' 2>/dev/null)
                local_window=$(tmux display-message -p '#{window_index}' 2>/dev/null)
                local_pane=$(tmux display-message -p '#{pane_index}' 2>/dev/null)
                local_tmux_target="${local_session}:${local_window}.${local_pane}"
                local_client_tty=$(tmux display-message -p '#{client_tty}' 2>/dev/null)
                local_client_termtype=$(tmux display-message -p '#{client_termtype}' 2>/dev/null)

                if [[ "$local_client_termtype" == *"iTerm"* ]] || [[ -n "$ITERM_SESSION_ID" ]]; then
                    term_app="iterm"
                else
                    term_app="terminal"
                fi

                if [[ -n "$local_client_tty" ]]; then
                    LINK_TERM_TYPE="${term_app}-tmux"
                    LINK_TERM_TARGET="${local_client_tty}|${local_tmux_target}"
                    LINK_FOCUS_URL="claude-focus://${term_app}-tmux/$(url_encode "$local_client_tty")/$(url_encode "$local_tmux_target")"
                else
                    LINK_TERM_TYPE="tmux"
                    LINK_TERM_TARGET="$local_tmux_target"
                    LINK_FOCUS_URL="claude-focus://tmux/$(url_encode "$local_tmux_target")"
                fi
            elif [[ -n "$ITERM_SESSION_ID" ]]; then
                LINK_TERM_TYPE="iterm2"
                LINK_TERM_TARGET="${ITERM_SESSION_ID#*:}"
                LINK_FOCUS_URL="claude-focus://iterm2/${LINK_TERM_TARGET}"
            elif [[ "$__CFBundleIdentifier" == "com.apple.Terminal" || "$TERM_PROGRAM" == "Apple_Terminal" ]]; then
                local_terminal_tty=$(tty 2>/dev/null)
                if [[ -n "$local_terminal_tty" && "$local_terminal_tty" != "not a tty" ]]; then
                    LINK_TERM_TYPE="terminal"
                    LINK_TERM_TARGET="$local_terminal_tty"
                    LINK_FOCUS_URL="claude-focus://terminal/$(url_encode "$local_terminal_tty")"
                fi
            fi
            ;;
        *)
            echo "Error: link command only works on macOS (the local machine)" >&2
            exit 1
            ;;
    esac

    if [[ "$LINK_TERM_TYPE" == "unknown" ]]; then
        echo "Error: Could not detect terminal. Run this from iTerm2, Terminal.app, or tmux." >&2
        exit 1
    fi

    # Save link info
    cat > "$LINKS_DIR/${LINK_ID}.json" << EOF
{
  "link_id": "${LINK_ID}",
  "term_type": "${LINK_TERM_TYPE}",
  "term_target": "${LINK_TERM_TARGET}",
  "focus_url": "${LINK_FOCUS_URL}",
  "created_at": "$(date -Iseconds)"
}
EOF

    # If --host provided, SSH directly and start tmux
    if [[ -n "$SSH_HOST" ]]; then
        echo ""
        echo "╭─────────────────────────────────────────────────────────────╮"
        echo "│  SSH Link Created                                           │"
        echo "╰─────────────────────────────────────────────────────────────╯"
        echo ""
        echo "  Link ID: $LINK_ID"
        echo "  Host:    $SSH_HOST"
        echo ""
        echo "╭─────────────────────────────────────────────────────────────╮"
        echo "│  Mac-Based Buttons (Focus + Input)                          │"
        echo "╰─────────────────────────────────────────────────────────────╯"
        echo ""
        echo "  When your Mac is open, start slack-tunnel on Mac:"
        echo "    slack-tunnel"
        echo ""
        echo "  Then on the remote server, run:"
        echo "    claude"
        echo "    /slack-notify"
        echo ""
        echo "  ✓ Focus button will switch to this terminal"
        echo "  ✓ 1/2/Continue/Push buttons work from Slack"
        echo ""
        echo "╭─────────────────────────────────────────────────────────────╮"
        echo "│  Remote-Only Buttons (Mac can be closed)                    │"
        echo "╰─────────────────────────────────────────────────────────────╯"
        echo ""
        echo "  For buttons to work when Mac is closed:"
        echo ""
        echo "    1. On remote, start remote-tunnel:"
        echo "       remote-tunnel --background"
        echo ""
        echo "    2. Run Claude and register:"
        echo "       claude"
        echo "       /slack-notify"
        echo ""
        echo "  ✓ 1/2/Continue/Push buttons work from phone"
        echo "  ✗ Focus button won't switch windows (Mac is closed)"
        echo ""

        # Offer to sync Slack config to remote
        SYNC_CONFIG=""
        if [[ -f "$CLAUDE_DIR/.slack-config" ]]; then
            echo -n "  Sync Slack config to remote for remote-tunnel? [Y/n] "
            read -r SYNC_CONFIG
            if [[ ! "$SYNC_CONFIG" =~ ^[Nn]$ ]]; then
                echo ""
                echo "  Syncing Slack config..."
                scp -q "${SSH_ARGS[@]}" "$CLAUDE_DIR/.slack-config" "$SSH_HOST:~/.claude/" 2>/dev/null && \
                    echo "  ✓ .slack-config synced"
                if [[ -f "$CLAUDE_DIR/slack-signing-secret" ]]; then
                    scp -q "${SSH_ARGS[@]}" "$CLAUDE_DIR/slack-signing-secret" "$SSH_HOST:~/.claude/" 2>/dev/null && \
                        echo "  ✓ slack-signing-secret synced"
                fi
            fi
        fi
        echo ""
        echo -n "  Press Enter to connect and start tmux..."
        read -r
        echo ""
        # Create new tmux session that exports env vars into the shell
        # The vars must be exported INSIDE the shell tmux spawns, not just for tmux itself
        exec ssh -t "${SSH_ARGS[@]}" "$SSH_HOST" \
            "tmux new-session -s claude-$LINK_ID 'export CLAUDE_LINK_ID=$LINK_ID CLAUDE_SSH_HOST=$SSH_HOST; exec \$SHELL -l'"
    fi

    # Otherwise print instructions (no --host)
    echo ""
    echo "╭─────────────────────────────────────────────────────────────╮"
    echo "│  Link Created                                               │"
    echo "╰─────────────────────────────────────────────────────────────╯"
    echo ""
    echo "  Link ID: $LINK_ID"
    echo ""
    echo "╭─────────────────────────────────────────────────────────────╮"
    echo "│  Next Steps                                                 │"
    echo "╰─────────────────────────────────────────────────────────────╯"
    echo ""
    echo "  Option 1: Use --host to connect directly"
    echo "    claude-slack-notify link --host <hostname>"
    echo ""
    echo "  Option 2: SSH manually with link ID"
    echo "    export CLAUDE_LINK_ID=$LINK_ID"
    echo "    ssh <hostname>"
    echo ""
    exit 0
fi

# -----------------------------------------------------------------------------
# Links command - list or manage links
# Usage: claude-slack-notify links [clean]
# -----------------------------------------------------------------------------
if [[ "$1" == "links" ]]; then
    if [[ "$2" == "clean" ]]; then
        # Remove links older than 24 hours
        if [[ -d "$LINKS_DIR" ]]; then
            find "$LINKS_DIR" -name "*.json" -mtime +1 -delete 2>/dev/null
            echo "Cleaned old links"
        fi
        exit 0
    fi

    # List active links
    if [[ -d "$LINKS_DIR" ]]; then
        for f in "$LINKS_DIR"/*.json; do
            [[ -f "$f" ]] || continue
            LINK_ID=$(basename "$f" .json)
            TERM_TYPE=$(grep -o '"term_type": *"[^"]*"' "$f" | cut -d'"' -f4)
            CREATED=$(grep -o '"created_at": *"[^"]*"' "$f" | cut -d'"' -f4)
            echo "$LINK_ID  ($TERM_TYPE)  created: $CREATED"
        done
    fi
    exit 0
fi

get_tmux_target() {
    # Get the controlling TTY for this process tree
    # We need to find the TTY that corresponds to our tmux pane
    local my_tty=""

    # Try to get TTY from PPID (the parent shell process)
    # Note: CLAUDE_INSTANCE_ID is now a session UUID, not a PID, so we use PPID for TTY lookup
    local check_pid="$PPID"
    my_tty=$(ps -p "$check_pid" -o tty= 2>/dev/null | tr -d ' ')

    # Normalize TTY format (add /dev/ prefix if missing)
    if [[ -n "$my_tty" && "$my_tty" != "??" && "$my_tty" != "?" ]]; then
        [[ "$my_tty" != /dev/* ]] && my_tty="/dev/$my_tty"

        # Look up which tmux pane has this TTY
        local pane_info
        pane_info=$(tmux list-panes -a -F '#{pane_tty} #{session_name}:#{window_index}.#{pane_index}' 2>/dev/null | grep "^${my_tty} " | head -1)

        if [[ -n "$pane_info" ]]; then
            # Extract session:window.pane from the output
            echo "${pane_info#* }"
            return
        fi
    fi

    # Fallback to display-message (works when called from the active pane)
    local session window pane
    session=$(tmux display-message -p '#{session_name}' 2>/dev/null)
    window=$(tmux display-message -p '#{window_index}' 2>/dev/null)
    pane=$(tmux display-message -p '#{pane_index}' 2>/dev/null)
    echo "${session}:${window}.${pane}"
}

detect_terminal() {
    TERM_TYPE="unknown"
    TERM_TARGET=""
    FOCUS_URL=""

    # Check for linked session without SSH (e.g., JupyterLab terminal)
    # CLAUDE_LINK_ID is set but SSH_CONNECTION is not
    if [[ -n "$CLAUDE_LINK_ID" && -z "$SSH_CONNECTION" ]]; then
        SSH_USER=$(whoami)
        SSH_HOST="${CLAUDE_SSH_HOST:-$(hostname -f 2>/dev/null || hostname)}"
        SSH_PORT="${CLAUDE_SSH_PORT:-22}"

        # Get tmux target if available
        local remote_tmux_target=""
        if [[ -n "$TMUX" ]]; then
            local r_session r_window r_pane
            r_session=$(tmux display-message -p '#{session_name}' 2>/dev/null)
            r_window=$(tmux display-message -p '#{window_index}' 2>/dev/null)
            r_pane=$(tmux display-message -p '#{pane_index}' 2>/dev/null)
            remote_tmux_target="${r_session}:${r_window}.${r_pane}"
        fi

        # JupyterLab or similar linked terminal (no direct SSH)
        TERM_TYPE="jupyter-tmux"
        TERM_TARGET="${CLAUDE_LINK_ID}|${SSH_HOST}|${SSH_USER}|${SSH_PORT}|${remote_tmux_target}"
        FOCUS_URL="claude-focus://jupyter-tmux/$(url_encode "$CLAUDE_LINK_ID")/$(url_encode "$SSH_HOST")/$(url_encode "$SSH_USER")/${SSH_PORT}/$(url_encode "$remote_tmux_target")"
        return
    fi

    # Check for SSH session with linked local terminal
    if [[ -n "$SSH_CONNECTION" ]]; then
        SSH_USER=$(whoami)
        # Use CLAUDE_SSH_HOST if set (passed from link --host), otherwise fall back to hostname
        # CLAUDE_SSH_HOST ensures we use the same host/alias the user connected with
        SSH_HOST="${CLAUDE_SSH_HOST:-$(hostname -f 2>/dev/null || hostname)}"
        SSH_PORT="${CLAUDE_SSH_PORT:-22}"

        if [[ -n "$CLAUDE_LINK_ID" ]]; then
            # Linked SSH mode - local terminal for focus, remote for input
            TERM_TYPE="ssh-linked"

            # Get tmux target if available on remote
            local remote_tmux_target=""
            if [[ -n "$TMUX" ]]; then
                local r_session r_window r_pane
                r_session=$(tmux display-message -p '#{session_name}' 2>/dev/null)
                r_window=$(tmux display-message -p '#{window_index}' 2>/dev/null)
                r_pane=$(tmux display-message -p '#{pane_index}' 2>/dev/null)
                remote_tmux_target="${r_session}:${r_window}.${r_pane}"
            fi

            TERM_TARGET="${CLAUDE_LINK_ID}|${SSH_HOST}|${SSH_USER}|${SSH_PORT}|${remote_tmux_target}"
            FOCUS_URL="claude-focus://ssh-linked/$(url_encode "$CLAUDE_LINK_ID")/$(url_encode "$SSH_HOST")/$(url_encode "$SSH_USER")/${SSH_PORT}/$(url_encode "$remote_tmux_target")"
            return
        fi

        # Unlinked SSH mode - direct SSH (no local terminal focus)
        if [[ -n "$TMUX" ]]; then
            # SSH + tmux but no link
            local r_session r_window r_pane
            r_session=$(tmux display-message -p '#{session_name}' 2>/dev/null)
            r_window=$(tmux display-message -p '#{window_index}' 2>/dev/null)
            r_pane=$(tmux display-message -p '#{pane_index}' 2>/dev/null)
            local remote_tmux_target="${r_session}:${r_window}.${r_pane}"

            TERM_TYPE="ssh-tmux"
            TERM_TARGET="${SSH_HOST}|${SSH_USER}|${SSH_PORT}|${remote_tmux_target}"
            FOCUS_URL="claude-focus://ssh-tmux/$(url_encode "$SSH_HOST")/$(url_encode "$SSH_USER")/${SSH_PORT}/$(url_encode "$remote_tmux_target")"
            return
        fi

        # SSH without tmux or link - limited support
        TERM_TYPE="ssh"
        TERM_TARGET="${SSH_HOST}|${SSH_USER}|${SSH_PORT}"
        FOCUS_URL=""  # No focus URL - can't reliably send input without tmux
        return
    fi

    # Detect OS
    local os_type
    case "$(uname -s)" in
        MINGW*|MSYS*|CYGWIN*) os_type="windows" ;;
        Linux)
            if [[ -n "$WSL_DISTRO_NAME" ]] || grep -qi microsoft /proc/version 2>/dev/null; then
                os_type="wsl"
            else
                os_type="linux"
            fi
            ;;
        Darwin) os_type="macos" ;;
        *) os_type="unknown" ;;
    esac

    # ---------------------------------------------------------------------
    # Windows Terminal detection (runs in WSL, Git Bash, MSYS2, Cygwin)
    # ---------------------------------------------------------------------
    if [[ "$os_type" == "wsl" || "$os_type" == "windows" ]]; then
        if [[ -n "$WT_SESSION" ]]; then
            # Windows Terminal detected
            if [[ -n "$TMUX" ]]; then
                local tmux_target
                tmux_target=$(get_tmux_target)
                TERM_TYPE="wt-tmux"
                TERM_TARGET="${WT_SESSION}|${tmux_target}"
                FOCUS_URL="claude-focus://wt-tmux/$(url_encode "$WT_SESSION")/$(url_encode "$tmux_target")"
            else
                TERM_TYPE="windows-terminal"
                TERM_TARGET="$WT_SESSION"
                FOCUS_URL="claude-focus://windows-terminal/$(url_encode "$WT_SESSION")"
            fi
            return
        elif [[ -n "$ConEmuPID" ]]; then
            # ConEmu/Cmder detected
            TERM_TYPE="conemu"
            TERM_TARGET="$ConEmuPID"
            FOCUS_URL="claude-focus://conemu/$(url_encode "$ConEmuPID")"
            return
        elif [[ "$os_type" == "wsl" ]]; then
            # WSL without Windows Terminal - identify by WSL distro and window
            local wsl_window_id
            wsl_window_id="${WSL_DISTRO_NAME:-wsl}-$$"
            if [[ -n "$TMUX" ]]; then
                local tmux_target
                tmux_target=$(get_tmux_target)
                TERM_TYPE="wsl-tmux"
                TERM_TARGET="${wsl_window_id}|${tmux_target}"
                FOCUS_URL="claude-focus://wsl-tmux/$(url_encode "$wsl_window_id")/$(url_encode "$tmux_target")"
            else
                TERM_TYPE="wsl"
                TERM_TARGET="$wsl_window_id"
                FOCUS_URL="claude-focus://wsl/$(url_encode "$wsl_window_id")"
            fi
            return
        elif [[ "$os_type" == "windows" ]]; then
            # Git Bash / MSYS2 / Cygwin without Windows Terminal
            local mintty_pid="${MINTTY_PID:-$PPID}"
            TERM_TYPE="mintty"
            TERM_TARGET="$mintty_pid"
            FOCUS_URL="claude-focus://mintty/$(url_encode "$mintty_pid")"
            return
        fi
    fi

    # ---------------------------------------------------------------------
    # macOS terminal detection
    # ---------------------------------------------------------------------
    if [[ "$os_type" == "macos" ]]; then
        if [[ -n "$TMUX" ]]; then
            local tmux_target client_tty term_app client_termtype
            tmux_target=$(get_tmux_target)
            client_tty=$(tmux display-message -p '#{client_tty}' 2>/dev/null)
            client_termtype=$(tmux display-message -p '#{client_termtype}' 2>/dev/null)

            # Detect which terminal app is running tmux
            # Use client_termtype (most reliable), fall back to ITERM_SESSION_ID
            if [[ "$client_termtype" == *"iTerm"* ]] || [[ -n "$ITERM_SESSION_ID" ]]; then
                term_app="iterm"
            else
                term_app="terminal"
            fi

            if [[ -n "$client_tty" ]]; then
                TERM_TYPE="${term_app}-tmux"
                TERM_TARGET="${client_tty}|${tmux_target}"
                FOCUS_URL="claude-focus://${term_app}-tmux/$(url_encode "$client_tty")/$(url_encode "$tmux_target")"
            else
                TERM_TYPE="tmux"
                TERM_TARGET="$tmux_target"
                FOCUS_URL="claude-focus://tmux/$(url_encode "$tmux_target")"
            fi
        elif [[ -n "$ITERM_SESSION_ID" ]]; then
            TERM_TYPE="iterm2"
            TERM_TARGET="${ITERM_SESSION_ID#*:}"
            FOCUS_URL="claude-focus://iterm2/${TERM_TARGET}"
        elif [[ "$__CFBundleIdentifier" == "com.apple.Terminal" || "$TERM_PROGRAM" == "Apple_Terminal" ]]; then
            # Terminal.app - get TTY of current shell (works even in subshells)
            local terminal_tty
            terminal_tty=$(tty 2>/dev/null)
            if [[ -n "$terminal_tty" && "$terminal_tty" != "not a tty" ]]; then
                TERM_TYPE="terminal"
                TERM_TARGET="$terminal_tty"
                FOCUS_URL="claude-focus://terminal/$(url_encode "$terminal_tty")"
            fi
        fi
        return
    fi

    # ---------------------------------------------------------------------
    # Linux terminal detection (non-WSL)
    # ---------------------------------------------------------------------
    if [[ "$os_type" == "linux" ]]; then
        if [[ -n "$TMUX" ]]; then
            local tmux_target client_tty
            tmux_target=$(get_tmux_target)
            client_tty=$(tmux display-message -p '#{client_tty}' 2>/dev/null)
            if [[ -n "$client_tty" ]]; then
                TERM_TYPE="linux-tmux"
                TERM_TARGET="${client_tty}|${tmux_target}"
                FOCUS_URL="claude-focus://linux-tmux/$(url_encode "$client_tty")/$(url_encode "$tmux_target")"
            else
                TERM_TYPE="tmux"
                TERM_TARGET="$tmux_target"
                FOCUS_URL="claude-focus://tmux/$(url_encode "$tmux_target")"
            fi
        elif [[ -n "$GNOME_TERMINAL_SERVICE" ]]; then
            TERM_TYPE="gnome-terminal"
            TERM_TARGET="$$"
            FOCUS_URL="claude-focus://gnome-terminal/$(url_encode "$$")"
        elif [[ -n "$KONSOLE_DBUS_SESSION" ]]; then
            TERM_TYPE="konsole"
            TERM_TARGET="$KONSOLE_DBUS_SESSION"
            FOCUS_URL="claude-focus://konsole/$(url_encode "$KONSOLE_DBUS_SESSION")"
        elif [[ "$TERM_PROGRAM" == "vscode" ]]; then
            TERM_TYPE="vscode"
            TERM_TARGET="$$"
            FOCUS_URL="claude-focus://vscode/$(url_encode "$$")"
        fi
    fi
}

# -----------------------------------------------------------------------------
# Register a new instance
# -----------------------------------------------------------------------------
if [[ "$1" == "register" ]]; then
    mkdir -p "$INSTANCES_DIR"

    INSTANCE_NAME="$2"
    if [[ -z "$INSTANCE_NAME" ]]; then
        ADJECTIVES=("red" "blue" "green" "purple" "orange" "silver" "golden" "cosmic" "swift" "bright" "dark" "wild" "calm" "bold" "quick")
        NOUNS=("wolf" "hawk" "bear" "lion" "tiger" "eagle" "falcon" "dragon" "phoenix" "raven" "fox" "panther" "cobra" "shark" "storm")
        COLORS=("amber" "coral" "jade" "ruby" "onyx" "ivory" "copper" "bronze" "teal" "indigo" "crimson" "azure" "scarlet" "violet" "emerald")
        ITEMS=("coffee" "thunder" "shadow" "crystal" "ember" "breeze" "river" "mountain" "forest" "ocean" "sunrise" "comet" "glacier" "canyon" "meadow")
        INSTANCE_NAME="${ADJECTIVES[$RANDOM % ${#ADJECTIVES[@]}]}-${NOUNS[$RANDOM % ${#NOUNS[@]}]}-${COLORS[$RANDOM % ${#COLORS[@]}]}-${ITEMS[$RANDOM % ${#ITEMS[@]}]}"
    fi

    detect_terminal
    HOSTNAME=$(hostname -s 2>/dev/null || echo "unknown")

    # Build instance JSON with optional SSH fields
    INSTANCE_JSON="{
  \"id\": \"${INSTANCE_ID}\",
  \"name\": \"${INSTANCE_NAME}\",
  \"hostname\": \"${HOSTNAME}\",
  \"term_type\": \"${TERM_TYPE}\",
  \"term_target\": \"${TERM_TARGET}\",
  \"focus_url\": \"${FOCUS_URL}\""

    # Add SSH-specific fields if in SSH mode
    if [[ "$TERM_TYPE" == "ssh-linked" && -n "$CLAUDE_LINK_ID" ]]; then
        INSTANCE_JSON+=",
  \"link_id\": \"${CLAUDE_LINK_ID}\",
  \"ssh_host\": \"${SSH_HOST}\",
  \"ssh_user\": \"${SSH_USER}\",
  \"ssh_port\": \"${SSH_PORT}\""
    elif [[ "$TERM_TYPE" == "ssh-tmux" || "$TERM_TYPE" == "ssh" ]]; then
        INSTANCE_JSON+=",
  \"ssh_host\": \"${SSH_HOST}\",
  \"ssh_user\": \"${SSH_USER}\",
  \"ssh_port\": \"${SSH_PORT}\""
    fi

    INSTANCE_JSON+=",
  \"registered_at\": \"$(date -Iseconds)\"
}"

    echo "$INSTANCE_JSON" > "$INSTANCE_FILE"

    # Check if tunnel is running when Slack is configured (local only - warn if not)
    SLACK_CONFIG_FILE="${CLAUDE_DIR}/.slack-config"
    TUNNEL_PID_FILE="${CLAUDE_DIR}/.tunnel.pid"
    if [[ -f "$SLACK_CONFIG_FILE" ]] && [[ "$TERM_TYPE" != "ssh-linked" ]] && [[ "$TERM_TYPE" != "jupyter-tmux" ]]; then
        # Check if tunnel is running
        TUNNEL_RUNNING=false
        if [[ -f "$TUNNEL_PID_FILE" ]]; then
            EXISTING_PID=$(cat "$TUNNEL_PID_FILE" 2>/dev/null)
            if [[ -n "$EXISTING_PID" ]] && kill -0 "$EXISTING_PID" 2>/dev/null; then
                TUNNEL_RUNNING=true
            fi
        fi

        if [[ "$TUNNEL_RUNNING" == "false" ]]; then
            echo "Warning: Slack buttons require 'slack-tunnel' to be running" >&2
            echo "         Run: slack-tunnel --background" >&2
        fi
    fi

    echo "$INSTANCE_NAME"
    exit 0
fi

# -----------------------------------------------------------------------------
# List registered instances
# -----------------------------------------------------------------------------
if [[ "$1" == "list" ]]; then
    if [[ -d "$INSTANCES_DIR" ]]; then
        for f in "$INSTANCES_DIR"/*.json; do
            [[ -f "$f" ]] || continue
            NAME=$(grep -o '"name": *"[^"]*"' "$f" | cut -d'"' -f4)
            HOST=$(grep -o '"hostname": *"[^"]*"' "$f" | cut -d'"' -f4)
            TERM=$(grep -o '"term_type": *"[^"]*"' "$f" | cut -d'"' -f4)
            TARGET=$(grep -o '"term_target": *"[^"]*"' "$f" | cut -d'"' -f4)
            echo "$NAME @ $HOST ($TERM $TARGET)"
        done
    fi
    exit 0
fi

# -----------------------------------------------------------------------------
# Stop - unregister session and stop tunnel (if available)
# Usage: claude-slack-notify stop
# On local Mac: stops tunnel + MCP server + unregisters session
# On remote: just unregisters session (tunnel runs on local Mac)
# -----------------------------------------------------------------------------
if [[ "$1" == "stop" ]]; then
    # Unregister this session
    if [[ -f "$INSTANCE_FILE" ]]; then
        rm -f "$INSTANCE_FILE"
        echo "Session unregistered"
    fi

    # Stop tunnel if available (only on local Mac)
    SLACK_TUNNEL="${CLAUDE_DIR}/bin/slack-tunnel"
    if [[ -x "$SLACK_TUNNEL" ]]; then
        "$SLACK_TUNNEL" --stop
    fi
    exit 0
fi

# -----------------------------------------------------------------------------
# Start timing
# Usage: claude-slack-notify start
# -----------------------------------------------------------------------------
if [[ "$1" == "start" ]]; then
    # Only work for registered instances (prevents sub-agents from creating timers)
    if [[ ! -f "$INSTANCE_FILE" ]]; then
        exit 0
    fi

    # Only start a new timer if one isn't already running
    # This preserves the original start time across multiple rapid tool calls
    if [[ ! -f "$TIMESTAMP_FILE" ]]; then
        date +%s > "$TIMESTAMP_FILE"
    fi
    exit 0
fi

# -----------------------------------------------------------------------------
# Check elapsed time and notify if needed
# Usage: claude-slack-notify check [context]
# Stop hook passes transcript_path in stdin JSON
# -----------------------------------------------------------------------------
if [[ "$1" == "check" ]]; then
    # Only work for registered instances (prevents sub-agents from notifying)
    if [[ ! -f "$INSTANCE_FILE" ]]; then
        exit 0
    fi

    # First, read stdin to check hook event type
    STDIN_DATA=""
    HOOK_EVENT=""
    NOTIF_MSG=""
    TRANSCRIPT_MSG=""
    if [[ ! -t 0 ]]; then
        STDIN_DATA=$(timeout 1 cat 2>/dev/null || true)
        if [[ -n "$STDIN_DATA" ]] && command -v jq &>/dev/null; then
            HOOK_EVENT=$(echo "$STDIN_DATA" | jq -r '.hook_event_name // empty' 2>/dev/null)

            # Get notification message if this is a Notification event
            if [[ "$HOOK_EVENT" == "Notification" ]]; then
                NOTIF_MSG=$(echo "$STDIN_DATA" | jq -r '.message // empty' 2>/dev/null)
            fi

            # Get last assistant message from transcript
            TRANSCRIPT_PATH=$(echo "$STDIN_DATA" | jq -r '.transcript_path // empty' 2>/dev/null)
            if [[ -n "$TRANSCRIPT_PATH" && -f "$TRANSCRIPT_PATH" ]]; then
                TRANSCRIPT_MSG=$(tac "$TRANSCRIPT_PATH" 2>/dev/null | while read -r line; do
                    MSG_TYPE=$(echo "$line" | jq -r '.type // empty' 2>/dev/null)
                    if [[ "$MSG_TYPE" == "assistant" ]]; then
                        TEXT=$(echo "$line" | jq -r '
                            if .message.content then
                                [.message.content[] | select(.type == "text") | .text] | join(" ")
                            else
                                empty
                            end
                        ' 2>/dev/null)
                        if [[ -n "$TEXT" ]]; then
                            echo "$TEXT"
                            break
                        fi
                    fi
                done)

                # For Notification events, extract tool request details from transcript
                # This provides more context than the generic "needs permission" message
                if [[ "$HOOK_EVENT" == "Notification" ]]; then
                    TOOL_REQUEST=$(tac "$TRANSCRIPT_PATH" 2>/dev/null | while read -r line; do
                        MSG_TYPE=$(echo "$line" | jq -r '.type // empty' 2>/dev/null)
                        if [[ "$MSG_TYPE" == "assistant" ]]; then
                            # Look for tool_use blocks in the message content
                            TOOL_INFO=$(echo "$line" | jq -r '
                                if .message.content then
                                    [.message.content[] | select(.type == "tool_use") |
                                        {name: .name, desc: .input.description}] | first |
                                        if . then
                                            if .desc and .desc != "" then
                                                "Claude wants to \(.desc)"
                                            else
                                                "Claude wants to use \(.name)"
                                            end
                                        else
                                            empty
                                        end
                                else
                                    empty
                                end
                            ' 2>/dev/null)
                            if [[ -n "$TOOL_INFO" ]]; then
                                echo "$TOOL_INFO"
                                break
                            fi
                        fi
                    done)

                    # Replace generic notification with detailed tool request if available
                    if [[ -n "$TOOL_REQUEST" ]]; then
                        NOTIF_MSG="$TOOL_REQUEST"
                    fi
                fi
            fi
        fi
    fi

    # Calculate elapsed time if timestamp exists
    ELAPSED=0
    if [[ -f "$TIMESTAMP_FILE" ]]; then
        START_TIME=$(cat "$TIMESTAMP_FILE")
        NOW=$(date +%s)
        ELAPSED=$((NOW - START_TIME))
    fi

    # Notification events (user input requested) always notify immediately
    # Other events only notify if elapsed >= threshold
    if [[ "$HOOK_EVENT" == "Notification" ]]; then
        # Always notify for Notification events - user input is requested
        rm -f "$TIMESTAMP_FILE"
    elif [[ $ELAPSED -lt $MIN_DURATION ]]; then
        # Below threshold and not a Notification event - skip
        exit 0
    else
        # Threshold exceeded - clear timestamp and notify
        rm -f "$TIMESTAMP_FILE"
    fi

    # Build context: show both transcript and notification message
    CONTEXT=""
    if [[ -n "$TRANSCRIPT_MSG" && -n "$NOTIF_MSG" ]]; then
        CONTEXT="${TRANSCRIPT_MSG}

---
*${NOTIF_MSG}*"
    elif [[ -n "$NOTIF_MSG" ]]; then
        CONTEXT="$NOTIF_MSG"
    elif [[ -n "$TRANSCRIPT_MSG" ]]; then
        CONTEXT="$TRANSCRIPT_MSG"
    fi

    # Build message
    if [[ -n "$CONTEXT" ]]; then
        if [[ $ELAPSED -gt 0 ]]; then
            MESSAGE="${CONTEXT} (${ELAPSED}s)"
        else
            MESSAGE="$CONTEXT"
        fi
    else
        MESSAGE="Task completed (${ELAPSED}s)"
    fi
else
    MESSAGE="${1:-Ready for input}"
fi

STATUS="${2:-waiting}"

# -----------------------------------------------------------------------------
# Get webhook URL
# -----------------------------------------------------------------------------
if [[ -f "$WEBHOOK_FILE" ]]; then
    WEBHOOK_URL=$(cat "$WEBHOOK_FILE")
elif [[ -n "$SLACK_WEBHOOK_URL" ]]; then
    WEBHOOK_URL="$SLACK_WEBHOOK_URL"
else
    exit 0
fi

# -----------------------------------------------------------------------------
# Load instance info and detect terminal
# -----------------------------------------------------------------------------
INSTANCE_NAME="Claude"
HOSTNAME=$(hostname -s 2>/dev/null || echo "unknown")

if [[ -f "$INSTANCE_FILE" ]]; then
    INSTANCE_NAME=$(grep -o '"name": *"[^"]*"' "$INSTANCE_FILE" | cut -d'"' -f4)
    HOSTNAME=$(grep -o '"hostname": *"[^"]*"' "$INSTANCE_FILE" | cut -d'"' -f4)
fi

# Dynamically detect current terminal (tmux window/pane can change)
detect_terminal

# Fallback to stored values if detection failed or FOCUS_URL is empty
# This handles: Docker containers, SSH sessions where CLAUDE_LINK_ID isn't in hook env
if [[ -f "$INSTANCE_FILE" ]]; then
    if [[ "$TERM_TYPE" == "unknown" || "$TERM_TYPE" == "ssh" || -z "$FOCUS_URL" ]]; then
        STORED_FOCUS_URL=$(grep -o '"focus_url": *"[^"]*"' "$INSTANCE_FILE" | cut -d'"' -f4)
        if [[ -n "$STORED_FOCUS_URL" ]]; then
            TERM_TYPE=$(grep -o '"term_type": *"[^"]*"' "$INSTANCE_FILE" | cut -d'"' -f4)
            TERM_TARGET=$(grep -o '"term_target": *"[^"]*"' "$INSTANCE_FILE" | cut -d'"' -f4)
            FOCUS_URL="$STORED_FOCUS_URL"

            # For linked sessions, update the tmux target dynamically (user may have switched windows)
            if [[ "$TERM_TYPE" == "ssh-linked" || "$TERM_TYPE" == "jupyter-tmux" ]] && [[ -n "$TMUX" ]]; then
                local current_session current_window current_pane new_tmux_target
                current_session=$(tmux display-message -p '#{session_name}' 2>/dev/null)
                current_window=$(tmux display-message -p '#{window_index}' 2>/dev/null)
                current_pane=$(tmux display-message -p '#{pane_index}' 2>/dev/null)
                new_tmux_target="${current_session}:${current_window}.${current_pane}"

                # Update FOCUS_URL with current tmux target (replace last path segment)
                # Format: claude-focus://ssh-linked/LINK_ID/HOST/USER/PORT/TMUX_TARGET
                FOCUS_URL=$(echo "$FOCUS_URL" | sed "s|/[^/]*$|/$(url_encode "$new_tmux_target")|")
                # Also update TERM_TARGET (last field after |)
                TERM_TARGET=$(echo "$TERM_TARGET" | sed "s|[^|]*$|$new_tmux_target|")
            fi
        fi
    fi
fi

# -----------------------------------------------------------------------------
# Build notification
# -----------------------------------------------------------------------------
case "$STATUS" in
    started)  COLOR="#36a64f" ;;
    waiting)  COLOR="#ff9800" ;;
    error)    COLOR="#ff0000" ;;
    *)        COLOR="#3AA3E3" ;;
esac

# Build location string (keep it short for Slack display)
LOCATION="$HOSTNAME"
if [[ -n "$TERM_TYPE" && "$TERM_TYPE" != "unknown" ]]; then
    # Extract just the tmux session:window.pane if present (skip the /dev/tty part)
    DISPLAY_TARGET="$TERM_TARGET"
    if [[ "$TERM_TARGET" == *"|"* ]]; then
        DISPLAY_TARGET="${TERM_TARGET#*|}"
    fi
    # Simplify term type for display
    case "$TERM_TYPE" in
        iterm-tmux|terminal-tmux|wt-tmux|wsl-tmux|linux-tmux)
            LOCATION="$HOSTNAME (tmux $DISPLAY_TARGET)" ;;
        *)
            LOCATION="$HOSTNAME ($TERM_TYPE)" ;;
    esac
fi

# Escape all user-controllable values for safe JSON embedding
SAFE_INSTANCE_NAME=$(json_escape "$INSTANCE_NAME")
SAFE_HOSTNAME=$(json_escape "$HOSTNAME")
SAFE_LOCATION=$(json_escape "$LOCATION")
SAFE_MESSAGE=$(json_escape "$MESSAGE")
SAFE_FOCUS_URL=$(json_escape "$FOCUS_URL")

# Build button block if we have a focus URL
BUTTON_BLOCK=""
if [[ -n "$FOCUS_URL" ]]; then
    # Check if MCP server is running for hybrid button support
    # For linked sessions (ssh-linked, jupyter-tmux), assume MCP server is on the local machine
    # which we can't reach from here - use interactive buttons (they'll route through ngrok)
    MCP_SERVER_RUNNING=""
    if [[ "$TERM_TYPE" == "ssh-linked" || "$TERM_TYPE" == "jupyter-tmux" ]]; then
        # Linked session: MCP server is on local machine, use interactive buttons
        MCP_SERVER_RUNNING="1"
    elif is_mcp_server_running; then
        MCP_SERVER_RUNNING="1"
    fi

    # Read button config or use defaults
    BUTTON_CONFIG="$CLAUDE_DIR/button-config"
    if [[ ! -f "$BUTTON_CONFIG" ]]; then
        # Default buttons if no config exists
        BUTTON_CONFIG_CONTENT="1|1
2|2
Continue|continue
Push|push"
    else
        BUTTON_CONFIG_CONTENT=$(cat "$BUTTON_CONFIG")
    fi

    # For remote sessions (ssh-linked, jupyter-tmux), embed the focus URL directly
    # in the button value so the local MCP server doesn't need to look up the session
    # (session file is on remote, MCP server is on local)
    BUTTON_VALUE_PREFIX="${INSTANCE_ID}"
    if [[ "$TERM_TYPE" == "ssh-linked" || "$TERM_TYPE" == "jupyter-tmux" ]]; then
        # Use url: prefix so MCP server knows to use focus URL directly
        BUTTON_VALUE_PREFIX="url:${FOCUS_URL}"
    fi

    # Build action buttons from config
    ACTION_BUTTONS=""
    BUTTON_COUNT=0
    while IFS='|' read -r label action || [[ -n "$label" ]]; do
        # Skip empty lines and comments
        [[ -z "$label" || "$label" == \#* ]] && continue

        # URL encode the action
        safe_action=$(json_escape "${FOCUS_URL}?action=$(url_encode "$action")")
        safe_label=$(json_escape "$label")

        # Build button with action_id when MCP server running (works on mobile + desktop)
        # Otherwise use url (desktop-only with custom URL scheme)
        if [[ -n "$MCP_SERVER_RUNNING" ]]; then
            # Interactive button: action_id/value only, no url (works on mobile)
            ACTION_BUTTONS="${ACTION_BUTTONS},
        {
          \"type\": \"button\",
          \"text\": { \"type\": \"plain_text\", \"text\": \"${safe_label}\" },
          \"action_id\": \"session_action_${BUTTON_COUNT}\",
          \"value\": \"${BUTTON_VALUE_PREFIX}|${action}\"
        }"
        else
            # Desktop-only button: just url (custom URL scheme)
            ACTION_BUTTONS="${ACTION_BUTTONS},
        {
          \"type\": \"button\",
          \"text\": { \"type\": \"plain_text\", \"text\": \"${safe_label}\" },
          \"url\": \"${safe_action}\"
        }"
        fi
        ((BUTTON_COUNT++))
    done <<< "$BUTTON_CONFIG_CONTENT"

    # Build Focus button: interactive when MCP server running, url-based otherwise
    if [[ -n "$MCP_SERVER_RUNNING" ]]; then
        FOCUS_BUTTON="{
          \"type\": \"button\",
          \"text\": { \"type\": \"plain_text\", \"text\": \"Focus\" },
          \"style\": \"primary\",
          \"action_id\": \"session_focus\",
          \"value\": \"${BUTTON_VALUE_PREFIX}|focus\"
        }"
    else
        FOCUS_BUTTON="{
          \"type\": \"button\",
          \"text\": { \"type\": \"plain_text\", \"text\": \"Focus\" },
          \"url\": \"${SAFE_FOCUS_URL}\",
          \"style\": \"primary\"
        }"
    fi

    BUTTON_BLOCK=",{
      \"type\": \"actions\",
      \"elements\": [
        ${FOCUS_BUTTON}${ACTION_BUTTONS}
      ]
    }"
fi

# Check if we have bot token for API posting (enables thread replies)
SLACK_CONFIG_FILE="${CLAUDE_DIR}/.slack-config"
SLACK_BOT_TOKEN=""
SLACK_CHANNEL_ID=""
if [[ -f "$SLACK_CONFIG_FILE" ]]; then
    source "$SLACK_CONFIG_FILE"
fi

THREADS_DIR="${CLAUDE_DIR}/threads"

if [[ -n "$SLACK_BOT_TOKEN" && -n "$SLACK_CHANNEL_ID" ]]; then
    # Use chat.postMessage API (enables thread replies)
    RESPONSE=$(curl -s -X POST "https://slack.com/api/chat.postMessage" \
      -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
      -H 'Content-type: application/json' \
      --data "{
        \"channel\": \"${SLACK_CHANNEL_ID}\",
        \"attachments\": [
          {
            \"fallback\": \"${SAFE_INSTANCE_NAME}: ${SAFE_MESSAGE}\",
            \"color\": \"${COLOR}\",
            \"blocks\": [
              {
                \"type\": \"section\",
                \"text\": {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*${SAFE_INSTANCE_NAME}* on \\\`${SAFE_LOCATION}\\\`\n${SAFE_MESSAGE}\"
                }
              }${BUTTON_BLOCK}
            ]
          }
        ]
      }")

    # Save thread_ts for reply routing
    if command -v jq &>/dev/null; then
        THREAD_TS=$(echo "$RESPONSE" | jq -r '.ts // empty' 2>/dev/null)
        if [[ -n "$THREAD_TS" && -n "$FOCUS_URL" ]]; then
            mkdir -p "$THREADS_DIR"
            # Store mapping: thread_ts -> session info
            cat > "$THREADS_DIR/${THREAD_TS}.json" << EOF
{
  "thread_ts": "${THREAD_TS}",
  "instance_id": "${INSTANCE_ID}",
  "focus_url": "${FOCUS_URL}",
  "term_type": "${TERM_TYPE}",
  "created_at": "$(date -Iseconds)"
}
EOF
        fi
    fi
else
    # Fall back to webhook (no thread reply support)
    curl -s -X POST -H 'Content-type: application/json' \
      --data "{
        \"attachments\": [
          {
            \"fallback\": \"${SAFE_INSTANCE_NAME}: ${SAFE_MESSAGE}\",
            \"color\": \"${COLOR}\",
            \"blocks\": [
              {
                \"type\": \"section\",
                \"text\": {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*${SAFE_INSTANCE_NAME}* on \`${SAFE_LOCATION}\`\n${SAFE_MESSAGE}\"
                }
              }${BUTTON_BLOCK}
            ]
          }
        ]
      }" \
      "$WEBHOOK_URL" > /dev/null 2>&1
fi
