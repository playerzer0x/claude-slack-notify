#!/bin/bash
# =============================================================================
# local-tunnel - Start tunnel for Slack button actions
#
# Supports multiple tunnel backends (in order of preference):
#   1. Tailscale Funnel (recommended) - stable URL, no third-party service
#   2. Localtunnel - free, but can be flaky with subdomain conflicts
#
# Commands:
#   local-tunnel               - Start tunnel (auto-detects best backend)
#   local-tunnel --setup       - Configure Slack tokens (for auto-URL updates)
#   local-tunnel --update-token - Quick Slack token refresh when expired
#   local-tunnel --background  - Start tunnel in background
#   local-tunnel --stop        - Stop background tunnel
#   local-tunnel --status      - Check tunnel status
#   local-tunnel --use-tailscale - Force Tailscale Funnel
#   local-tunnel --use-localtunnel - Force Localtunnel
# =============================================================================

set -uo pipefail

MCP_PORT=8463
CLAUDE_DIR="$HOME/.claude"
MCP_SERVER="$CLAUDE_DIR/bin/mcp-server"
SLACK_CONFIG_FILE="$CLAUDE_DIR/.slack-config"
WEBHOOK_FILE="$CLAUDE_DIR/slack-webhook-url"
TUNNEL_PID_FILE="$CLAUDE_DIR/.tunnel.pid"
TUNNEL_URL_FILE="$CLAUDE_DIR/.tunnel-url"
TUNNEL_TYPE_FILE="$CLAUDE_DIR/.tunnel-type"
WATCHDOG_PID_FILE="$CLAUDE_DIR/.tunnel-watchdog.pid"
ACTIVITY_FILE="$CLAUDE_DIR/.tunnel-last-activity"
TUNNEL_LOG="$CLAUDE_DIR/tunnel.log"
IDLE_TIMEOUT=3600  # 1 hour in seconds
LOCALTUNNEL_SUBDOMAIN_FILE="$CLAUDE_DIR/.localtunnel-subdomain"
ENV_FILE="$CLAUDE_DIR/.env"

# Tunnel type: "tailscale" or "localtunnel"
TUNNEL_TYPE=""

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

echo_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
echo_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
echo_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# =============================================================================
# Slack API helpers
# =============================================================================

# Load Slack config
load_slack_config() {
    if [[ ! -f "$SLACK_CONFIG_FILE" ]]; then
        return 1
    fi
    # Source the config file (sets SLACK_APP_ID, SLACK_ACCESS_TOKEN, SLACK_REFRESH_TOKEN, SLACK_TOKEN_EXPIRES)
    source "$SLACK_CONFIG_FILE"
    return 0
}

# Save Slack config
save_slack_config() {
    cat > "$SLACK_CONFIG_FILE" << EOF
SLACK_APP_ID="$SLACK_APP_ID"
SLACK_ACCESS_TOKEN="$SLACK_ACCESS_TOKEN"
SLACK_REFRESH_TOKEN="$SLACK_REFRESH_TOKEN"
SLACK_TOKEN_EXPIRES="$SLACK_TOKEN_EXPIRES"
SLACK_BOT_TOKEN="${SLACK_BOT_TOKEN:-}"
SLACK_CHANNEL_ID="${SLACK_CHANNEL_ID:-}"
EOF
    chmod 600 "$SLACK_CONFIG_FILE"
}

# =============================================================================
# Tailscale Funnel helpers
# =============================================================================

# Check if Tailscale is available and Funnel can be used
has_tailscale() {
    command -v tailscale &>/dev/null
}

# Check if Tailscale is connected
is_tailscale_connected() {
    tailscale status &>/dev/null
}

# Get Tailscale DNS name (e.g., macbook.tailnet-name.ts.net)
get_tailscale_dns_name() {
    tailscale status --json 2>/dev/null | jq -r '.Self.DNSName // empty' 2>/dev/null | sed 's/\.$//'
}

# Get the Tailscale Funnel URL for our port
get_tailscale_funnel_url() {
    local dns_name
    dns_name=$(get_tailscale_dns_name)
    if [[ -n "$dns_name" ]]; then
        echo "https://${dns_name}"
    fi
}

# Check if Funnel is currently serving our port
is_tailscale_funnel_active() {
    local status
    status=$(tailscale funnel status --json 2>/dev/null)
    if [[ -n "$status" && "$status" != "{}" ]]; then
        # Check if any handler is proxying to our port (Web.<hostname>:443.Handlers./)
        echo "$status" | jq -e '.Web | to_entries[].value.Handlers["/"]' &>/dev/null
    else
        return 1
    fi
}

# Start Tailscale Funnel for MCP port
start_tailscale_funnel() {
    local background="${1:-false}"
    local retry="${2:-false}"

    if ! has_tailscale; then
        echo_error "Tailscale not installed"
        return 1
    fi

    if ! is_tailscale_connected; then
        echo_error "Tailscale not connected. Run: tailscale up"
        return 1
    fi

    local dns_name
    dns_name=$(get_tailscale_dns_name)
    if [[ -z "$dns_name" ]]; then
        echo_error "Could not get Tailscale DNS name"
        return 1
    fi

    TUNNEL_URL="https://${dns_name}"
    echo "$TUNNEL_URL" > "$TUNNEL_URL_FILE"
    echo "tailscale" > "$TUNNEL_TYPE_FILE"

    echo_info "Starting Tailscale Funnel..."

    if [[ "$background" == "true" ]]; then
        # Background mode - use --bg flag
        tailscale funnel --bg "$MCP_PORT" >/dev/null 2>&1
    else
        # Foreground mode - start in background but we'll wait on MCP server
        tailscale funnel --bg "$MCP_PORT" >/dev/null 2>&1
    fi

    # Verify funnel started
    sleep 1
    if is_tailscale_funnel_active; then
        echo_info "Tailscale Funnel started: $TUNNEL_URL"
        # Save to .mac-tunnel-url for remote-relay auto-detect
        echo "$TUNNEL_URL" > "$CLAUDE_DIR/.mac-tunnel-url"
        return 0
    else
        # Funnel failed - try to auto-enable it
        if [[ "$retry" == "false" ]]; then
            echo_warn "Tailscale Funnel not enabled in ACL policy"
            if enable_funnel_in_acl; then
                # Retry starting funnel
                echo_info "Retrying Tailscale Funnel..."
                start_tailscale_funnel "$background" "true"
                return $?
            fi
        fi
        echo_error "Tailscale Funnel failed to start"
        echo_error "Enable Funnel manually at: https://login.tailscale.com/admin/acls"
        return 1
    fi
}

# Stop Tailscale Funnel
stop_tailscale_funnel() {
    if has_tailscale && is_tailscale_funnel_active; then
        tailscale funnel off >/dev/null 2>&1 || true
        echo_info "Tailscale Funnel stopped"
        return 0
    fi
    return 1
}

# =============================================================================
# Tailscale API helpers (for auto-enabling Funnel)
# =============================================================================

# Load Tailscale API key from .env file
load_tailscale_api_key() {
    if [[ -f "$ENV_FILE" ]]; then
        # Source .env to get TAILSCALE_API_KEY (grep to avoid sourcing other vars)
        TAILSCALE_API_KEY=$(grep -E '^TAILSCALE_API_KEY=' "$ENV_FILE" 2>/dev/null | cut -d'=' -f2- | tr -d '"' | tr -d "'")
        [[ -n "$TAILSCALE_API_KEY" ]]
        return $?
    fi
    return 1
}

# Prompt user to add Tailscale API key to .env
prompt_tailscale_api_key() {
    echo ""
    echo -e "${BOLD}Tailscale Funnel Setup${NC}"
    echo -e "  Funnel needs an API key to auto-enable."
    echo ""
    echo -e "  ${CYAN}1.${NC} Go to ${BOLD}https://login.tailscale.com/admin/settings/keys${NC}"
    echo -e "  ${CYAN}2.${NC} Click ${BOLD}Generate API key${NC}"
    echo -e "  ${CYAN}3.${NC} Copy the key (starts with tskey-api-...)"
    echo ""

    # Try to open browser
    if command -v open &>/dev/null; then
        open "https://login.tailscale.com/admin/settings/keys" 2>/dev/null || true
    elif command -v xdg-open &>/dev/null; then
        xdg-open "https://login.tailscale.com/admin/settings/keys" 2>/dev/null || true
    fi

    echo -ne "  ${YELLOW}?${NC} API key: "
    read -r TAILSCALE_API_KEY

    if [[ -z "$TAILSCALE_API_KEY" ]]; then
        echo_error "API key is required"
        return 1
    fi

    if [[ ! "$TAILSCALE_API_KEY" =~ ^tskey-api- ]]; then
        echo_error "Invalid format - should start with 'tskey-api-'"
        return 1
    fi

    # Save to .env file
    if [[ -f "$ENV_FILE" ]]; then
        grep -v '^TAILSCALE_API_KEY=' "$ENV_FILE" > "$ENV_FILE.tmp" 2>/dev/null || true
        mv "$ENV_FILE.tmp" "$ENV_FILE"
    fi
    echo "TAILSCALE_API_KEY=$TAILSCALE_API_KEY" >> "$ENV_FILE"
    chmod 600 "$ENV_FILE"
    echo_info "API key saved"
    return 0
}

# Check if Funnel is enabled in the ACL policy
check_funnel_enabled_in_acl() {
    if ! load_tailscale_api_key; then
        return 1
    fi

    local response
    response=$(curl -s --max-time 10 "https://api.tailscale.com/api/v2/tailnet/-/acl" \
        -u "${TAILSCALE_API_KEY}:" 2>/dev/null)

    if [[ -z "$response" ]]; then
        return 1
    fi

    # Check for API error
    if echo "$response" | jq -e '.message' &>/dev/null; then
        return 1
    fi

    # Check if nodeAttrs contains funnel attribute
    if echo "$response" | jq -e '.nodeAttrs[]?.attr[]? | select(. == "funnel")' &>/dev/null; then
        return 0
    fi

    return 1
}

# Enable Funnel in the Tailscale ACL policy
enable_funnel_in_acl() {
    if ! load_tailscale_api_key; then
        if ! prompt_tailscale_api_key; then
            return 1
        fi
    fi

    echo_info "Checking current Tailscale ACL policy..."

    # Get current ACL (request JSON format, not HuJSON)
    local current_acl
    current_acl=$(curl -s --max-time 10 "https://api.tailscale.com/api/v2/tailnet/-/acl" \
        -u "${TAILSCALE_API_KEY}:" \
        -H "Accept: application/json" 2>/dev/null)

    if [[ -z "$current_acl" ]]; then
        echo_error "Failed to fetch current ACL policy"
        return 1
    fi

    # Check for API error
    local error_msg
    error_msg=$(echo "$current_acl" | jq -r '.message // empty' 2>/dev/null)
    if [[ -n "$error_msg" ]]; then
        echo_error "API error: $error_msg"
        echo_error "Check your TAILSCALE_API_KEY in $ENV_FILE"
        return 1
    fi

    # Check if funnel is already enabled
    if echo "$current_acl" | jq -e '.nodeAttrs[]?.attr[]? | select(. == "funnel")' &>/dev/null; then
        echo_info "Funnel is already enabled in ACL policy"
        return 0
    fi

    echo_info "Adding Funnel attribute to ACL policy..."

    # Add funnel to nodeAttrs
    # If nodeAttrs doesn't exist or is empty, create it
    # If it exists, append to it
    local updated_acl
    if echo "$current_acl" | jq -e '.nodeAttrs | length > 0' &>/dev/null; then
        # nodeAttrs exists - check if there's already a target: ["*"] entry
        if echo "$current_acl" | jq -e '.nodeAttrs[] | select(.target == ["*"])' &>/dev/null; then
            # Add funnel to existing wildcard target
            updated_acl=$(echo "$current_acl" | jq '
                .nodeAttrs = [.nodeAttrs[] |
                    if .target == ["*"] then
                        .attr = ((.attr // []) + ["funnel"] | unique)
                    else
                        .
                    end
                ]
            ')
        else
            # Add new entry for wildcard target with funnel
            updated_acl=$(echo "$current_acl" | jq '.nodeAttrs += [{"target": ["*"], "attr": ["funnel"]}]')
        fi
    else
        # nodeAttrs doesn't exist - create it
        updated_acl=$(echo "$current_acl" | jq '. + {"nodeAttrs": [{"target": ["*"], "attr": ["funnel"]}]}')
    fi

    # Update the ACL
    local update_response
    update_response=$(curl -s --max-time 10 -X POST "https://api.tailscale.com/api/v2/tailnet/-/acl" \
        -u "${TAILSCALE_API_KEY}:" \
        -H "Content-Type: application/json" \
        -H "Accept: application/json" \
        --data-raw "$updated_acl" 2>/dev/null)

    # Check for errors
    error_msg=$(echo "$update_response" | jq -r '.message // empty' 2>/dev/null)
    if [[ -n "$error_msg" ]]; then
        echo_error "Failed to update ACL: $error_msg"
        return 1
    fi

    echo_info "Funnel enabled - changes propagate in ~10s"
    sleep 5
    return 0
}

# =============================================================================
# Localtunnel config (stable URL)
# =============================================================================

has_localtunnel_subdomain() {
    [[ -f "$LOCALTUNNEL_SUBDOMAIN_FILE" ]]
}

has_stable_tunnel() {
    # For backward compatibility - checks if any tunnel type is configured
    [[ -f "$LOCALTUNNEL_SUBDOMAIN_FILE" ]] || (has_tailscale && is_tailscale_connected)
}

get_localtunnel_subdomain() {
    cat "$LOCALTUNNEL_SUBDOMAIN_FILE" 2>/dev/null
}

# Check if token is expired (with 5 minute buffer)
is_token_expired() {
    local now
    now=$(date +%s)
    local buffer=300  # 5 minutes
    if [[ -z "${SLACK_TOKEN_EXPIRES:-}" ]] || [[ $((SLACK_TOKEN_EXPIRES - buffer)) -lt $now ]]; then
        return 0  # expired
    fi
    return 1  # not expired
}

# Rotate the Slack token using refresh token
rotate_slack_token() {
    # Check if refresh token exists
    if [[ -z "${SLACK_REFRESH_TOKEN:-}" ]]; then
        echo_error "No refresh token configured"
        echo_error "Run 'local-tunnel --setup' to configure Slack"
        return 1
    fi

    echo_info "Refreshing Slack configuration token..."

    local response
    response=$(curl -s -X POST "https://slack.com/api/tooling.tokens.rotate" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "refresh_token=${SLACK_REFRESH_TOKEN}")

    local ok
    ok=$(echo "$response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$response" | jq -r '.error // "unknown error"')
        echo_error "Failed to refresh token: $error"
        echo_error "Run 'local-tunnel --update-token' to refresh"
        return 1
    fi

    SLACK_ACCESS_TOKEN=$(echo "$response" | jq -r '.token')
    SLACK_REFRESH_TOKEN=$(echo "$response" | jq -r '.refresh_token')
    local exp
    exp=$(echo "$response" | jq -r '.exp')
    SLACK_TOKEN_EXPIRES="$exp"

    save_slack_config
    echo_info "Token refreshed successfully"
    return 0
}

# NOTE: Slack Request URL auto-update removed - Remote server is the canonical endpoint
# Mac's local-tunnel provides /focus endpoint for Focus button forwarding only

# =============================================================================
# MCP server helpers
# =============================================================================

check_mcp_server() {
    if curl -s "http://localhost:$MCP_PORT/health" &>/dev/null; then
        return 0
    fi
    return 1
}

# Kill any orphan process on MCP_PORT that's not tracked by our PID file
# Returns 0 if orphans were killed, 1 if port was clear
kill_orphan_mcp_server() {
    local pid_file="$CLAUDE_DIR/.mcp-server.pid"
    local tracked_pid=""
    local killed_orphan=false

    # Get tracked PID (if valid)
    if [[ -f "$pid_file" ]]; then
        tracked_pid=$(cat "$pid_file" 2>/dev/null)
        # Verify it's actually running
        if [[ -n "$tracked_pid" ]] && ! kill -0 "$tracked_pid" 2>/dev/null; then
            # Stale PID file - remove it
            rm -f "$pid_file"
            tracked_pid=""
        fi
    fi

    # Find any process listening on MCP_PORT
    local port_pid
    port_pid=$(lsof -ti ":$MCP_PORT" 2>/dev/null | head -1)

    if [[ -n "$port_pid" ]]; then
        if [[ "$port_pid" != "$tracked_pid" ]]; then
            # Orphan process found - kill it
            echo_warn "Killing orphan process on port $MCP_PORT (PID: $port_pid)"
            kill "$port_pid" 2>/dev/null || true
            sleep 0.5
            # Force kill if still running
            if kill -0 "$port_pid" 2>/dev/null; then
                kill -9 "$port_pid" 2>/dev/null || true
                sleep 0.5
            fi
            killed_orphan=true
        fi
    fi

    # Clean up stale PID file if process doesn't match port
    if [[ -n "$tracked_pid" ]] && [[ "$tracked_pid" != "$port_pid" ]]; then
        rm -f "$pid_file"
    fi

    $killed_orphan && return 0 || return 1
}

find_mcp_source_dir() {
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

    if [[ -L "$CLAUDE_DIR/bin/mcp-server" ]]; then
        local target
        target="$(readlink "$CLAUDE_DIR/bin/mcp-server")"
        local repo_dir
        repo_dir="$(dirname "$target")/.."
        if [[ -d "$repo_dir/mcp-server/src" ]]; then
            echo "$repo_dir/mcp-server"
            return 0
        fi
    fi

    if [[ -d "$script_dir/../mcp-server/src" ]]; then
        echo "$script_dir/../mcp-server"
        return 0
    fi

    return 1
}

rebuild_if_needed() {
    local mcp_source_dir
    if ! mcp_source_dir=$(find_mcp_source_dir); then
        return 0
    fi

    local src_dir="$mcp_source_dir/src"
    local dist_dir="$mcp_source_dir/dist"
    local installed_dist="$CLAUDE_DIR/mcp-server-dist/dist"

    local newest_src
    newest_src=$(find "$src_dir" -name "*.ts" -type f -exec stat -f "%m %N" {} \; 2>/dev/null | sort -rn | head -1 | cut -d' ' -f1)

    local oldest_dist=0
    if [[ -d "$dist_dir" ]]; then
        oldest_dist=$(find "$dist_dir" -name "*.js" -type f -exec stat -f "%m %N" {} \; 2>/dev/null | sort -n | head -1 | cut -d' ' -f1)
    fi

    if [[ -n "$newest_src" ]] && [[ "$newest_src" -gt "$oldest_dist" ]]; then
        echo_info "Source files changed, rebuilding MCP server..."
        (
            cd "$mcp_source_dir"
            if command -v bun &>/dev/null; then
                bun run build
            elif command -v npm &>/dev/null; then
                npm run build
            else
                echo_warn "No build tool found (bun/npm), skipping rebuild"
                return 0
            fi
        )

        if [[ -d "$installed_dist" ]]; then
            cp -r "$dist_dir"/* "$installed_dist"/
            echo_info "Updated installed MCP server"
        fi
    fi
}

start_mcp_server() {
    if [[ ! -x "$MCP_SERVER" ]]; then
        echo_error "MCP server not found at $MCP_SERVER"
        echo_error "Run install.sh first to build the MCP server"
        exit 1
    fi

    # Kill any orphan process on the port first
    kill_orphan_mcp_server || true

    echo_info "Starting MCP server..."
    nohup "$MCP_SERVER" > "$CLAUDE_DIR/mcp-server.log" 2>&1 &
    MCP_PID=$!
    echo "$MCP_PID" > "$CLAUDE_DIR/.mcp-server.pid"

    for i in {1..10}; do
        if check_mcp_server; then
            echo_info "MCP server started (PID: $MCP_PID)"
            return 0
        fi
        sleep 0.5
    done

    echo_error "MCP server failed to start. Check $CLAUDE_DIR/mcp-server.log"
    exit 1
}

stop_mcp_server() {
    local pid_file="$CLAUDE_DIR/.mcp-server.pid"
    local stopped=false

    # Kill tracked process from PID file
    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            stopped=true
        fi
        rm -f "$pid_file"
    fi

    # Also kill any orphan process on the port
    if kill_orphan_mcp_server; then
        stopped=true
    fi

    if $stopped; then
        echo_info "MCP server stopped"
    fi
}

# =============================================================================
# Sync tunnel URL to remote servers
# =============================================================================

sync_tunnel_url_to_remotes() {
    local links_dir="$CLAUDE_DIR/links"
    if [[ ! -d "$links_dir" ]]; then
        return 0
    fi

    local mac_url_file="$CLAUDE_DIR/.mac-tunnel-url"
    if [[ ! -f "$mac_url_file" ]]; then
        return 0
    fi

    # Find unique remote hosts from link files
    local hosts_synced=0
    local seen_hosts=""

    for link_file in "$links_dir"/*.json; do
        [[ -f "$link_file" ]] || continue

        local ssh_host ssh_user ssh_port
        ssh_host=$(grep -o '"ssh_host": *"[^"]*"' "$link_file" 2>/dev/null | cut -d'"' -f4)
        ssh_user=$(grep -o '"ssh_user": *"[^"]*"' "$link_file" 2>/dev/null | cut -d'"' -f4)
        ssh_port=$(grep -o '"ssh_port": *"[^"]*"' "$link_file" 2>/dev/null | cut -d'"' -f4)

        # Skip if no SSH info or already synced to this host
        [[ -z "$ssh_host" ]] && continue
        [[ "$seen_hosts" == *"$ssh_user@$ssh_host:$ssh_port"* ]] && continue

        seen_hosts="$seen_hosts $ssh_user@$ssh_host:$ssh_port"

        # Try to sync (non-blocking, best effort)
        if scp -o BatchMode=yes -o ConnectTimeout=2 -P "${ssh_port:-22}" \
            "$mac_url_file" "${ssh_user}@${ssh_host}:~/.claude/.mac-tunnel-url" 2>/dev/null; then
            ((hosts_synced++)) || true
        fi
    done

    if [[ $hosts_synced -gt 0 ]]; then
        echo_info "Synced tunnel URL to $hosts_synced remote host(s)"
    fi
}

# =============================================================================
# Idle watchdog (for --background mode)
# =============================================================================

start_watchdog() {
    touch "$ACTIVITY_FILE"

    (
        while true; do
            sleep 300  # Check every 5 minutes

            if [[ ! -f "$ACTIVITY_FILE" ]]; then
                continue
            fi

            local last now
            if [[ "$(uname)" == "Darwin" ]]; then
                last=$(stat -f %m "$ACTIVITY_FILE" 2>/dev/null)
            else
                last=$(stat -c %Y "$ACTIVITY_FILE" 2>/dev/null)
            fi
            now=$(date +%s)

            # If stat failed, skip this check (don't treat as idle)
            if [[ -z "$last" || ! "$last" =~ ^[0-9]+$ ]]; then
                continue
            fi

            if [[ $((now - last)) -gt $IDLE_TIMEOUT ]]; then
                echo "$(date): Idle timeout ($IDLE_TIMEOUT seconds), shutting down" >> "$TUNNEL_LOG"

                if [[ -f "$TUNNEL_PID_FILE" ]]; then
                    local tunnel_pid
                    tunnel_pid=$(cat "$TUNNEL_PID_FILE")
                    kill "$tunnel_pid" 2>/dev/null || true
                    rm -f "$TUNNEL_PID_FILE"
                fi

                stop_mcp_server
                rm -f "$ACTIVITY_FILE"
                rm -f "$WATCHDOG_PID_FILE"
                exit 0
            fi
        done
    ) &
    local watchdog_pid=$!
    echo "$watchdog_pid" > "$WATCHDOG_PID_FILE"
    echo_info "Idle watchdog started (timeout: ${IDLE_TIMEOUT}s)"
}

stop_watchdog() {
    if [[ -f "$WATCHDOG_PID_FILE" ]]; then
        local pid
        pid=$(cat "$WATCHDOG_PID_FILE")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
        fi
        rm -f "$WATCHDOG_PID_FILE"
    fi
}

# =============================================================================
# Start tunnel and get URL
# =============================================================================

start_tunnel_and_get_url() {
    local background="${1:-false}"
    local log_file="$CLAUDE_DIR/.tunnel.log"

    # Kill any existing tunnel processes
    pkill -f "^lt --port" 2>/dev/null || true
    rm -f "$TUNNEL_PID_FILE" "$TUNNEL_URL_FILE" "$log_file"
    sleep 0.5

    # Require stable tunnel configuration
    if ! has_stable_tunnel; then
        echo_error "Stable URL not configured."
        echo ""
        echo -e "  Run ${BOLD}local-tunnel${NC} interactively to configure your subdomain."
        exit 1
    fi

    local subdomain
    subdomain=$(get_localtunnel_subdomain)

    if ! command -v lt &>/dev/null; then
        echo_warn "Localtunnel not installed. Installing..."
        if command -v bun &>/dev/null; then
            bun add -g localtunnel
        elif command -v npm &>/dev/null; then
            npm install -g localtunnel
        else
            echo_error "Cannot install localtunnel."
            echo ""
            echo -e "  Install with: ${BOLD}bun add -g localtunnel${NC}"
            echo -e "            or: ${BOLD}npm install -g localtunnel${NC}"
            exit 1
        fi
    fi

    echo_info "Starting Localtunnel (stable URL: ${subdomain}.loca.lt)..."

    if [[ "$background" == "true" ]]; then
        nohup lt --port "$MCP_PORT" --subdomain "$subdomain" > "$log_file" 2>&1 &
    else
        lt --port "$MCP_PORT" --subdomain "$subdomain" > "$log_file" 2>&1 &
    fi
    TUNNEL_PID=$!
    echo "$TUNNEL_PID" > "$TUNNEL_PID_FILE"

    # Wait for URL to appear
    local tunnel_url=""
    for i in {1..20}; do
        if [[ -f "$log_file" ]]; then
            tunnel_url=$(grep -oE 'https://[a-z0-9-]+\.loca\.lt' "$log_file" 2>/dev/null | head -1 || true)
            if [[ -n "$tunnel_url" ]]; then
                break
            fi
        fi
        sleep 0.5
    done

    if [[ -z "$tunnel_url" ]]; then
        echo_error "Failed to start localtunnel"
        cat "$log_file" 2>/dev/null | tail -5
        kill "$TUNNEL_PID" 2>/dev/null || true
        rm -f "$TUNNEL_PID_FILE"
        exit 1
    fi

    echo "$tunnel_url" > "$TUNNEL_URL_FILE"
    TUNNEL_URL="$tunnel_url"

    # Check if we got the subdomain we requested
    local expected_url="https://${subdomain}.loca.lt"
    if [[ "$tunnel_url" != "$expected_url" ]]; then
        echo_warn "Subdomain '$subdomain' unavailable - got random URL instead"
        echo_warn "Your stable subdomain may be in use. Try again in a few minutes,"
        echo_warn "or choose a new subdomain with: local-tunnel --stable"
        echo ""
    fi

    echo_info "Tunnel started: $tunnel_url"

    # Save to .mac-tunnel-url for remote-relay auto-detect
    MAC_TUNNEL_URL_FILE="$CLAUDE_DIR/.mac-tunnel-url"
    echo "$TUNNEL_URL" > "$MAC_TUNNEL_URL_FILE"

    # Optionally sync to remote Linux servers (if links exist)
    sync_tunnel_url_to_remotes
}

# =============================================================================
# --setup: Configure Slack API tokens
# =============================================================================

cmd_setup() {
    echo ""
    echo -e "${BOLD}Slack Tunnel Setup${NC}"
    echo ""

    # Check dependencies
    if ! command -v jq &>/dev/null; then
        echo_error "jq required. Install: brew install jq (macOS) or apt install jq (Linux)"
        exit 1
    fi

    echo -e "${BOLD}Configuration Token${NC}"
    echo -e "  1. Go to ${BOLD}https://api.slack.com/apps${NC}"
    echo -e "  2. Scroll to bottom → ${BOLD}\"Your App Configuration Tokens\"${NC}"
    echo -e "  3. Click ${BOLD}\"Generate Token\"${NC} → select workspace → ${BOLD}\"Generate\"${NC}"
    echo -e "  4. Copy the ${BOLD}Access Token${NC} (xoxe-...)"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Access Token: "
    read -r SLACK_ACCESS_TOKEN

    if [[ -z "$SLACK_ACCESS_TOKEN" ]]; then
        echo_error "Access token is required"
        exit 1
    fi

    echo -e "  5. Copy the ${BOLD}Refresh Token${NC}"
    echo -ne "  ${YELLOW}?${NC} Refresh Token: "
    read -r SLACK_REFRESH_TOKEN

    if [[ -z "$SLACK_REFRESH_TOKEN" ]]; then
        echo_error "Refresh token is required"
        exit 1
    fi

    SLACK_TOKEN_EXPIRES=$(($(date +%s) + 43200))

    echo ""
    echo -e "${BOLD}Slack App ID${NC}"
    echo -e "  Create app at ${BOLD}https://api.slack.com/apps${NC} if needed."
    echo -e "  Copy ${BOLD}App ID${NC} from top of page (format: A0XXXXXXXXX)"
    echo ""
    echo -ne "  ${YELLOW}?${NC} App ID: "
    read -r SLACK_APP_ID

    if [[ -z "$SLACK_APP_ID" || ! "$SLACK_APP_ID" =~ ^A[A-Z0-9]+$ ]]; then
        echo_error "Invalid App ID format"
        exit 1
    fi

    save_slack_config

    # Verify token
    local test_response ok
    test_response=$(curl -s -X POST "https://slack.com/api/apps.manifest.export" \
        -H "Authorization: Bearer ${SLACK_ACCESS_TOKEN}" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "app_id=${SLACK_APP_ID}")
    ok=$(echo "$test_response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$test_response" | jq -r '.error // "unknown error"')
        echo_error "Verification failed: $error"
        rm -f "$SLACK_CONFIG_FILE"
        exit 1
    fi

    echo_info "Configuration verified"
    echo ""

    echo -e "${BOLD}Webhook URL${NC}"
    echo -e "  1. Go to ${BOLD}https://api.slack.com/apps/${SLACK_APP_ID}${NC}"
    echo -e "  2. ${BOLD}Incoming Webhooks${NC} → Enable → ${BOLD}Add New Webhook${NC}"
    echo -e "  3. Select channel → Copy webhook URL"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Webhook URL: "
    read -r webhook_url

    if [[ -n "$webhook_url" ]]; then
        echo "$webhook_url" > "$WEBHOOK_FILE"
        chmod 600 "$WEBHOOK_FILE"
        echo_info "Webhook saved"
    else
        echo_warn "Skipped - notifications won't work"
    fi

    echo ""
    echo -ne "${YELLOW}?${NC} Enable thread replies? [Y/n] "
    read -r enable_threads

    if [[ ! "$enable_threads" =~ ^[Nn]$ ]]; then
        echo ""
        echo -e "  1. ${BOLD}OAuth & Permissions${NC} → Add scopes: app_mentions:read, channels:history, chat:write, files:read"
        echo -e "  2. ${BOLD}Install to Workspace${NC} → Copy ${BOLD}Bot User OAuth Token${NC} (xoxb-...)"
        echo ""
        echo -ne "  ${YELLOW}?${NC} Bot Token: "
        read -r SLACK_BOT_TOKEN

        if [[ -n "$SLACK_BOT_TOKEN" ]]; then
            echo -e "  3. ${BOLD}Event Subscriptions${NC} → Enable → Add: message.channels, message.im"
            save_slack_config
            echo_info "Bot token saved"
        fi
    fi

    echo ""
    echo -e "${BOLD}Channel ID${NC}"
    echo -e "  Right-click channel → View details → scroll to Channel ID"
    echo -ne "  ${YELLOW}?${NC} Channel ID: "
    read -r SLACK_CHANNEL_ID

    if [[ -n "$SLACK_CHANNEL_ID" ]]; then
        save_slack_config
        echo_info "Channel ID saved"
    fi

    echo ""
    echo -e "${GREEN}Setup complete!${NC} Run ${BOLD}local-tunnel${NC} to start."
    echo ""
}

# =============================================================================
# --update-token: Quick token refresh (when token expired)
# =============================================================================

cmd_update_token() {
    echo ""
    echo -e "${BOLD}Update Slack Token${NC}"
    echo ""

    if [[ ! -f "$SLACK_CONFIG_FILE" ]]; then
        echo_error "No config found. Run: local-tunnel --setup"
        exit 1
    fi

    source "$SLACK_CONFIG_FILE"

    if [[ -z "${SLACK_APP_ID:-}" ]]; then
        echo_error "App ID not found. Run: local-tunnel --setup"
        exit 1
    fi

    echo -e "  App ID: ${BOLD}${SLACK_APP_ID}${NC}"
    echo ""

    local config_url="https://api.slack.com/apps"
    if command -v open &>/dev/null; then
        open "$config_url" 2>/dev/null || true
    elif command -v xdg-open &>/dev/null; then
        xdg-open "$config_url" 2>/dev/null || true
    fi

    echo -e "  1. Scroll to bottom → ${BOLD}\"Your App Configuration Tokens\"${NC}"
    echo -e "  2. ${BOLD}\"Generate Token\"${NC} → select workspace → ${BOLD}\"Generate\"${NC}"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Access Token (xoxe-...): "
    read -r SLACK_ACCESS_TOKEN
    [[ -z "$SLACK_ACCESS_TOKEN" ]] && { echo_error "Required"; exit 1; }

    echo -ne "  ${YELLOW}?${NC} Refresh Token: "
    read -r SLACK_REFRESH_TOKEN
    [[ -z "$SLACK_REFRESH_TOKEN" ]] && { echo_error "Required"; exit 1; }

    SLACK_TOKEN_EXPIRES=$(($(date +%s) + 43200))
    save_slack_config

    # Verify
    local test_response ok
    test_response=$(curl -s -X POST "https://slack.com/api/apps.manifest.export" \
        -H "Authorization: Bearer ${SLACK_ACCESS_TOKEN}" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "app_id=${SLACK_APP_ID}")
    ok=$(echo "$test_response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        echo_error "Verification failed: $(echo "$test_response" | jq -r '.error // "unknown"')"
        exit 1
    fi

    echo ""
    echo -e "${GREEN}Token updated!${NC}"
    echo ""
}

# =============================================================================
# --stable: Setup stable URL with Localtunnel and start tunnel
# =============================================================================

cmd_stable() {
    # Check if localtunnel is installed
    if ! command -v lt &>/dev/null; then
        echo_info "Installing localtunnel..."
        if command -v bun &>/dev/null; then
            bun add -g localtunnel
        elif command -v npm &>/dev/null; then
            npm install -g localtunnel
        else
            echo_error "bun/npm not found. Install Node.js first."
            exit 1
        fi
    fi

    # If already configured, ask if they want to reconfigure or just start
    if has_stable_tunnel; then
        local current tunnel_url
        current=$(get_localtunnel_subdomain)
        tunnel_url="https://${current}.loca.lt"

        echo ""
        echo -e "  Current URL: ${CYAN}${tunnel_url}${NC}"
        echo -ne "  ${YELLOW}?${NC} Change subdomain? [y/N] "
        read -r change_subdomain

        if [[ ! "$change_subdomain" =~ ^[Yy]$ ]]; then
            cmd_interactive
            return
        fi
    fi

    echo ""
    echo -e "${BOLD}Stable Tunnel Setup${NC}"
    echo -e "  Choose a unique subdomain (e.g., claude-slack-yourname)"
    echo -ne "  ${YELLOW}?${NC} Subdomain: "
    read -r subdomain

    [[ -z "$subdomain" ]] && { echo_error "Subdomain required"; exit 1; }

    # Clean subdomain
    subdomain="${subdomain#https://}"
    subdomain="${subdomain%.loca.lt}"
    subdomain="${subdomain%%/*}"

    if [[ ! "$subdomain" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$ ]]; then
        echo_error "Invalid subdomain - use only letters, numbers, hyphens"
        exit 1
    fi

    echo "$subdomain" > "$LOCALTUNNEL_SUBDOMAIN_FILE"
    chmod 600 "$LOCALTUNNEL_SUBDOMAIN_FILE"

    local tunnel_url="https://${subdomain}.loca.lt"

    # Test the tunnel briefly
    echo_info "Testing tunnel..."
    local log_file="$CLAUDE_DIR/.localtunnel-test.log"
    rm -f "$log_file"

    lt --port "$MCP_PORT" --subdomain "$subdomain" > "$log_file" 2>&1 &
    local test_pid=$!

    local connected=""
    for i in {1..10}; do
        grep -q "your url is" "$log_file" 2>/dev/null && { connected="true"; break; }
        sleep 1
    done

    kill "$test_pid" 2>/dev/null || true
    wait "$test_pid" 2>/dev/null || true

    if [[ -z "$connected" ]]; then
        echo_warn "Could not verify - subdomain might be taken"
    else
        echo -e "  ${GREEN}✓${NC} Tunnel works!"
    fi

    echo ""
    echo -e "${GREEN}Stable URL:${NC} ${CYAN}${tunnel_url}${NC}"

    # Note: Remote server is the canonical Slack endpoint
    # This Mac tunnel provides /focus endpoint for Focus button forwarding
    echo -e "  ${DIM}This tunnel handles Focus button forwarding from remote${NC}"

    echo ""
    cmd_interactive
}

# =============================================================================
# --background: Start tunnel in background
# =============================================================================

cmd_background() {
    # Check Slack is configured
    if ! load_slack_config; then
        echo_error "Slack not configured. Run: local-tunnel --setup"
        exit 1
    fi

    # Check if Tailscale Funnel is already running
    if is_tailscale_funnel_active; then
        echo_info "Tailscale Funnel already running"
        TUNNEL_URL=$(get_tailscale_funnel_url)
        # Make sure MCP server is running
        if ! check_mcp_server; then
            rebuild_if_needed
            start_mcp_server
        fi
        return 0
    fi

    # Check if localtunnel is already running
    local tunnel_count
    tunnel_count=$(pgrep -f "lt --port.*${MCP_PORT}" 2>/dev/null | wc -l | tr -d ' ')

    if [[ -f "$TUNNEL_PID_FILE" ]] && [[ "$tunnel_count" -eq 1 ]]; then
        local existing_pid
        existing_pid=$(cat "$TUNNEL_PID_FILE")
        if kill -0 "$existing_pid" 2>/dev/null; then
            echo_info "Localtunnel already running (PID: $existing_pid)"
            return 0
        fi
    fi

    # Clean up stale localtunnel state
    if [[ "$tunnel_count" -gt 0 ]]; then
        echo_info "Cleaning up stale tunnel processes..."
    fi
    rm -f "$TUNNEL_PID_FILE"

    # Rebuild MCP server if needed
    rebuild_if_needed

    # Check MCP server state - verify PID file matches what's actually running
    local mcp_pid_file="$CLAUDE_DIR/.mcp-server.pid"
    local mcp_needs_start=true

    if check_mcp_server; then
        # Something is responding on the port - verify it's our tracked process
        local tracked_pid=""
        local port_pid=""
        if [[ -f "$mcp_pid_file" ]]; then
            tracked_pid=$(cat "$mcp_pid_file" 2>/dev/null)
        fi
        port_pid=$(lsof -ti ":$MCP_PORT" 2>/dev/null | head -1)

        if [[ -n "$tracked_pid" ]] && [[ "$tracked_pid" == "$port_pid" ]] && kill -0 "$tracked_pid" 2>/dev/null; then
            # Our tracked process is running correctly
            mcp_needs_start=false
            echo_info "MCP server already running (PID: $tracked_pid)"
        else
            # Orphan or mismatched process - will be cleaned up by start_mcp_server
            echo_info "Cleaning up stale MCP server..."
        fi
    fi

    if $mcp_needs_start; then
        start_mcp_server
    fi

    # Try Tailscale Funnel first (if available and not forced to use localtunnel)
    local tunnel_started=false
    if [[ "$TUNNEL_TYPE" != "localtunnel" ]] && has_tailscale && is_tailscale_connected; then
        if start_tailscale_funnel "true"; then
            tunnel_started=true
            # Sync tunnel URL to remote servers (if links exist)
            sync_tunnel_url_to_remotes
        else
            echo_warn "Tailscale Funnel failed, falling back to Localtunnel..."
        fi
    fi

    # Fall back to localtunnel
    if [[ "$tunnel_started" == "false" ]]; then
        if ! has_localtunnel_subdomain; then
            echo_error "No tunnel backend available."
            echo ""
            echo -e "  Either:"
            echo -e "    1. Enable Tailscale Funnel: ${BOLD}tailscale funnel ${MCP_PORT}${NC}"
            echo -e "    2. Configure Localtunnel: ${BOLD}local-tunnel --stable${NC}"
            exit 1
        fi
        start_tunnel_and_get_url "true"
    fi

    # Note: Remote server is the canonical Slack endpoint - no auto-update needed
    # This Mac tunnel provides /focus endpoint for Focus button forwarding

    # Start idle watchdog
    start_watchdog

    # Touch activity file
    touch "$ACTIVITY_FILE"

    echo_info "Tunnel running in background (PID: $TUNNEL_PID)"
}

# =============================================================================
# --stop: Stop background tunnel
# =============================================================================

cmd_stop() {
    local stopped=false

    if [[ -f "$WATCHDOG_PID_FILE" ]]; then
        stop_watchdog
        stopped=true
    fi

    # Stop Tailscale Funnel if active
    if stop_tailscale_funnel; then
        stopped=true
    fi

    # Kill the localtunnel from PID file
    if [[ -f "$TUNNEL_PID_FILE" ]]; then
        local pid
        pid=$(cat "$TUNNEL_PID_FILE")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            echo_info "Localtunnel stopped"
            stopped=true
        fi
        rm -f "$TUNNEL_PID_FILE"
    fi

    # Kill ANY remaining localtunnel processes (cleanup stale tunnels)
    local stale_count=0
    while IFS= read -r pid; do
        if [[ -n "$pid" ]]; then
            kill "$pid" 2>/dev/null || true
            ((stale_count++)) || true
        fi
    done < <(pgrep -f "lt --port.*${MCP_PORT:-8463}" 2>/dev/null || true)

    if [[ "$stale_count" -gt 0 ]]; then
        echo_info "Cleaned up $stale_count stale localtunnel process(es)"
        stopped=true
    fi

    # Remove tunnel URL and type files
    rm -f "$TUNNEL_URL_FILE" "$TUNNEL_TYPE_FILE"

    if [[ -f "$CLAUDE_DIR/.mcp-server.pid" ]]; then
        stop_mcp_server
        stopped=true
    fi

    rm -f "$ACTIVITY_FILE"

    if [[ "$stopped" == "true" ]]; then
        echo_info "All services stopped"
    else
        echo_info "No services were running"
    fi
}

# =============================================================================
# --status: Check tunnel status
# =============================================================================

cmd_status() {
    echo ""
    echo -e "${BOLD}Tunnel Status${NC}"
    echo ""

    # Determine active tunnel type
    local active_type=""
    if [[ -f "$TUNNEL_TYPE_FILE" ]]; then
        active_type=$(cat "$TUNNEL_TYPE_FILE" 2>/dev/null)
    fi

    # Check Tailscale availability and status
    if has_tailscale && is_tailscale_connected; then
        local ts_dns
        ts_dns=$(get_tailscale_dns_name)
        if is_tailscale_funnel_active; then
            echo -e "  Backend:    ${GREEN}Tailscale Funnel${NC} (active)"
            echo -e "  URL:        ${CYAN}https://${ts_dns}${NC}"
        else
            echo -e "  Tailscale:  ${CYAN}Available${NC} (${ts_dns})"
            if has_localtunnel_subdomain; then
                local subdomain
                subdomain=$(get_localtunnel_subdomain)
                echo -e "  Localtunnel: ${CYAN}Configured${NC} (${subdomain}.loca.lt)"
            fi
        fi
    elif has_localtunnel_subdomain; then
        local subdomain
        subdomain=$(get_localtunnel_subdomain)
        echo -e "  Backend:    ${GREEN}Localtunnel${NC}"
        echo -e "  URL:        ${CYAN}https://${subdomain}.loca.lt${NC}"
    else
        echo -e "  Backend:    ${YELLOW}Not configured${NC}"
        echo -e "              ${DIM}Tailscale recommended, or run --stable for Localtunnel${NC}"
    fi
    echo ""

    # Check tunnel process (for localtunnel - Tailscale doesn't use a PID file)
    if is_tailscale_funnel_active; then
        echo -e "  Tunnel:     ${GREEN}Running${NC} (Tailscale Funnel)"
        if [[ -f "$TUNNEL_URL_FILE" ]]; then
            local url
            url=$(cat "$TUNNEL_URL_FILE")
            echo -e "  Actions:    ${CYAN}$url/slack/actions${NC}"
        fi
    elif [[ -f "$TUNNEL_PID_FILE" ]]; then
        local pid
        pid=$(cat "$TUNNEL_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "  Tunnel:     ${GREEN}Running${NC} (Localtunnel PID: $pid)"
            if [[ -f "$TUNNEL_URL_FILE" ]]; then
                local url
                url=$(cat "$TUNNEL_URL_FILE")
                echo -e "  Actions:    ${CYAN}$url/slack/actions${NC}"
            fi
        else
            echo -e "  Tunnel:     ${YELLOW}Stopped${NC} (stale PID file)"
        fi
    else
        echo -e "  Tunnel:     ${YELLOW}Stopped${NC}"
    fi

    # Check MCP server - detect orphans
    local mcp_tracked_pid=""
    local mcp_port_pid=""
    if [[ -f "$CLAUDE_DIR/.mcp-server.pid" ]]; then
        mcp_tracked_pid=$(cat "$CLAUDE_DIR/.mcp-server.pid" 2>/dev/null)
    fi
    mcp_port_pid=$(lsof -ti ":$MCP_PORT" 2>/dev/null | head -1)

    if check_mcp_server; then
        if [[ -n "$mcp_tracked_pid" ]] && [[ "$mcp_tracked_pid" == "$mcp_port_pid" ]]; then
            echo -e "  MCP Server: ${GREEN}Running${NC} (PID: $mcp_tracked_pid)"
        elif [[ -n "$mcp_port_pid" ]]; then
            echo -e "  MCP Server: ${YELLOW}Orphan process${NC} (PID: $mcp_port_pid, not tracked)"
            echo -e "              ${DIM}Run: local-tunnel --stop && local-tunnel --background${NC}"
        else
            echo -e "  MCP Server: ${GREEN}Running${NC}"
        fi
    else
        if [[ -n "$mcp_tracked_pid" ]]; then
            echo -e "  MCP Server: ${YELLOW}Stopped${NC} (stale PID file: $mcp_tracked_pid)"
        else
            echo -e "  MCP Server: ${YELLOW}Stopped${NC}"
        fi
    fi

    # Check watchdog
    if [[ -f "$WATCHDOG_PID_FILE" ]]; then
        local pid
        pid=$(cat "$WATCHDOG_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "  Watchdog:   ${GREEN}Running${NC}"
        else
            echo -e "  Watchdog:   ${YELLOW}Stopped${NC}"
        fi
    else
        echo -e "  Watchdog:   ${YELLOW}Stopped${NC}"
    fi

    # Check last activity
    if [[ -f "$ACTIVITY_FILE" ]]; then
        local last now elapsed
        if [[ "$(uname)" == "Darwin" ]]; then
            last=$(stat -f %m "$ACTIVITY_FILE" 2>/dev/null || echo 0)
        else
            last=$(stat -c %Y "$ACTIVITY_FILE" 2>/dev/null || echo 0)
        fi
        now=$(date +%s)
        elapsed=$((now - last))
        local remaining=$((IDLE_TIMEOUT - elapsed))
        if [[ $remaining -gt 0 ]]; then
            echo -e "  Idle timer: ${DIM}${remaining}s until auto-stop${NC}"
        fi
    fi

    echo ""
}

# =============================================================================
# Default: Interactive mode
# =============================================================================

cmd_interactive() {
    echo ""
    echo -e "${BOLD}Slack Tunnel${NC}"

    local using_tailscale=false
    local using_localtunnel=false

    load_slack_config || true
    rebuild_if_needed

    # Kill existing MCP server and start fresh
    if check_mcp_server; then
        local old_pid
        old_pid=$(cat "$CLAUDE_DIR/.mcp-server.pid" 2>/dev/null)
        [[ -n "$old_pid" ]] && kill "$old_pid" 2>/dev/null || true
        sleep 1
    fi
    start_mcp_server

    # Cleanup on exit
    cleanup() {
        echo ""
        echo_info "Shutting down..."
        stop_tailscale_funnel 2>/dev/null || true
        [[ -n "${TUNNEL_PID:-}" ]] && kill "$TUNNEL_PID" 2>/dev/null || true
        stop_mcp_server
        rm -f "$TUNNEL_PID_FILE" "$TUNNEL_URL_FILE" "$TUNNEL_TYPE_FILE"
        exit 0
    }
    trap cleanup INT TERM
    trap 'rm -f "$TUNNEL_PID_FILE" "$TUNNEL_URL_FILE" "$TUNNEL_TYPE_FILE"' EXIT

    # Try Tailscale Funnel first
    if [[ "$TUNNEL_TYPE" != "localtunnel" ]] && has_tailscale && is_tailscale_connected; then
        if start_tailscale_funnel "false"; then
            using_tailscale=true
            sync_tunnel_url_to_remotes
        else
            echo_warn "Tailscale Funnel failed, falling back to Localtunnel..."
        fi
    fi

    # Fall back to Localtunnel
    if [[ "$using_tailscale" == "false" ]]; then
        if has_stable_tunnel; then
            using_localtunnel=true
            start_tunnel_and_get_url "false"
        else
            echo_warn "No tunnel configured."
            echo -e "  Run ${BOLD}local-tunnel --stable${NC} to setup Localtunnel."
            exit 1
        fi
    fi

    # Note: Remote server is the canonical Slack endpoint - no auto-update needed
    # This Mac tunnel provides /focus endpoint for Focus button forwarding
    echo ""
    if [[ "$using_tailscale" == "true" ]]; then
        echo -e "${GREEN}Tailscale Funnel connected${NC}"
    else
        echo -e "${GREEN}Localtunnel connected${NC}"
    fi
    echo -e "  URL: ${CYAN}${TUNNEL_URL}${NC}"
    echo -e "  ${DIM}Focus endpoint: ${TUNNEL_URL}/focus${NC}"
    echo -e "  ${DIM}Press Ctrl+C to stop.${NC}"
    echo ""

    # Keep running
    if [[ "$using_tailscale" == "true" ]]; then
        while true; do sleep 3600; done
    else
        wait "$TUNNEL_PID" 2>/dev/null || true
    fi
}

# =============================================================================
# Main
# =============================================================================

case "${1:-}" in
    --setup)
        cmd_setup
        ;;
    --update-token)
        cmd_update_token
        ;;
    --background)
        cmd_background
        ;;
    --stop)
        cmd_stop
        ;;
    --status)
        cmd_status
        ;;
    --use-tailscale)
        TUNNEL_TYPE="tailscale"
        shift
        case "${1:-}" in
            --background) cmd_background ;;
            "") cmd_interactive ;;
            *) echo_error "Unknown command after --use-tailscale: $1"; exit 1 ;;
        esac
        ;;
    --use-localtunnel)
        TUNNEL_TYPE="localtunnel"
        shift
        case "${1:-}" in
            --background) cmd_background ;;
            --stable|"") cmd_stable ;;
            *) echo_error "Unknown command after --use-localtunnel: $1"; exit 1 ;;
        esac
        ;;
    --help|-h)
        echo "Usage: local-tunnel [command]"
        echo ""
        echo "Commands:"
        echo "  (none)         Start tunnel (Tailscale if available, else Localtunnel)"
        echo "  --setup        Configure Slack tokens (for auto-URL updates)"
        echo "  --update-token Quick Slack token refresh when expired"
        echo "  --background   Start tunnel in background"
        echo "  --stop         Stop background tunnel"
        echo "  --status       Check tunnel status"
        echo ""
        echo "Backend options:"
        echo "  --use-tailscale    Force Tailscale Funnel"
        echo "  --use-localtunnel  Force Localtunnel"
        echo ""
        ;;
    --stable)
        cmd_stable
        ;;
    "")
        # Default: try Tailscale, fall back to Localtunnel setup
        if has_tailscale && is_tailscale_connected; then
            cmd_interactive
        else
            cmd_stable
        fi
        ;;
    *)
        echo_error "Unknown command: $1"
        echo "Run: local-tunnel --help"
        exit 1
        ;;
esac
