#!/bin/bash
# =============================================================================
# remote-tunnel - Remote relay for Slack button actions (Linux only)
#
# Runs on a Linux server (in tmux) to receive Slack button clicks when your
# Mac is closed. Auto-detects if Mac is reachable and proxies to it when possible.
#
# Uses Tailscale Funnel by default, falls back to Localtunnel if unavailable.
#
# Commands:
#   remote-tunnel           - Start tunnel (Tailscale if available, else Localtunnel)
#   remote-tunnel --setup   - Configure Slack tokens (for auto-URL updates)
#   remote-tunnel --background - Start tunnel in background
#   remote-tunnel --stop    - Stop background tunnel
#   remote-tunnel --status  - Check tunnel status
#
# Backend options:
#   remote-tunnel --use-tailscale    - Force Tailscale Funnel
#   remote-tunnel --use-localtunnel  - Force Localtunnel
# =============================================================================

set -uo pipefail

RELAY_PORT=8464
CLAUDE_DIR="$HOME/.claude"
SLACK_CONFIG_FILE="$CLAUDE_DIR/.slack-config"
RELAY_PID_FILE="$CLAUDE_DIR/.remote-relay.pid"
TUNNEL_PID_FILE="$CLAUDE_DIR/.remote-tunnel.pid"
TUNNEL_URL_FILE="$CLAUDE_DIR/.remote-tunnel-url"
TUNNEL_TYPE_FILE="$CLAUDE_DIR/.remote-tunnel-type"
WATCHDOG_PID_FILE="$CLAUDE_DIR/.remote-tunnel-watchdog.pid"
ACTIVITY_FILE="$CLAUDE_DIR/.relay-last-activity"
TUNNEL_LOG="$CLAUDE_DIR/remote-tunnel.log"
IDLE_TIMEOUT=3600  # 1 hour in seconds
LOCALTUNNEL_SUBDOMAIN_FILE="$CLAUDE_DIR/.remote-localtunnel-subdomain"
ENV_FILE="$CLAUDE_DIR/.env"

# Tunnel type: "tailscale" or "localtunnel" (set by --use-* flags)
TUNNEL_TYPE=""

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

echo_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
echo_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
echo_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# =============================================================================
# Platform check - Linux only
# =============================================================================
if [[ "$(uname)" == "Darwin" ]]; then
    echo_error "remote-tunnel is for Linux servers only."
    echo_info "On macOS, use: local-tunnel"
    exit 1
fi

# =============================================================================
# Tailscale Funnel helpers
# =============================================================================

has_tailscale() {
    command -v tailscale &>/dev/null
}

is_tailscale_connected() {
    tailscale status &>/dev/null
}

get_tailscale_dns_name() {
    tailscale status --json 2>/dev/null | jq -r '.Self.DNSName // empty' 2>/dev/null | sed 's/\.$//'
}

get_tailscale_funnel_url() {
    local dns_name
    dns_name=$(get_tailscale_dns_name)
    if [[ -n "$dns_name" ]]; then
        echo "https://${dns_name}"
    fi
}

is_tailscale_funnel_active() {
    local status
    status=$(tailscale funnel status --json 2>/dev/null)
    if [[ -n "$status" && "$status" != "{}" ]]; then
        echo "$status" | jq -e ".\"https://*:443\".Handlers | keys[] | select(. == \"/\")" &>/dev/null
    else
        return 1
    fi
}

start_tailscale_funnel() {
    local background="${1:-false}"
    local retry="${2:-false}"

    if ! has_tailscale; then
        echo_error "Tailscale not installed"
        return 1
    fi

    if ! is_tailscale_connected; then
        echo_error "Tailscale not connected. Run: sudo tailscale up"
        return 1
    fi

    local dns_name
    dns_name=$(get_tailscale_dns_name)
    if [[ -z "$dns_name" ]]; then
        echo_error "Could not get Tailscale DNS name"
        return 1
    fi

    TUNNEL_URL="https://${dns_name}"
    echo "$TUNNEL_URL" > "$TUNNEL_URL_FILE"
    echo "tailscale" > "$TUNNEL_TYPE_FILE"

    echo_info "Starting Tailscale Funnel..."

    # Use --bg flag to run in background
    tailscale funnel --bg "$RELAY_PORT" >/dev/null 2>&1

    # Verify funnel started
    sleep 1
    if is_tailscale_funnel_active; then
        echo_info "Tailscale Funnel started: $TUNNEL_URL"
        return 0
    else
        # Funnel failed - try to auto-enable it
        if [[ "$retry" == "false" ]]; then
            echo_warn "Tailscale Funnel not enabled in ACL policy"
            if enable_funnel_in_acl; then
                # Retry starting funnel
                echo_info "Retrying Tailscale Funnel..."
                start_tailscale_funnel "$background" "true"
                return $?
            fi
        fi
        echo_error "Tailscale Funnel failed to start"
        echo_error "Enable Funnel manually at: https://login.tailscale.com/admin/acls"
        return 1
    fi
}

stop_tailscale_funnel() {
    if has_tailscale && is_tailscale_funnel_active; then
        tailscale funnel off >/dev/null 2>&1 || true
        echo_info "Tailscale Funnel stopped"
        return 0
    fi
    return 1
}

# =============================================================================
# Tailscale API helpers (for auto-enabling Funnel)
# =============================================================================

# Load Tailscale API key from .env file
load_tailscale_api_key() {
    if [[ -f "$ENV_FILE" ]]; then
        # Source .env to get TAILSCALE_API_KEY (grep to avoid sourcing other vars)
        TAILSCALE_API_KEY=$(grep -E '^TAILSCALE_API_KEY=' "$ENV_FILE" 2>/dev/null | cut -d'=' -f2- | tr -d '"' | tr -d "'")
        [[ -n "$TAILSCALE_API_KEY" ]]
        return $?
    fi
    return 1
}

# Prompt user to add Tailscale API key to .env
prompt_tailscale_api_key() {
    echo ""
    echo -e "${CYAN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${CYAN}│${NC}  ${BOLD}Tailscale Funnel Setup Required${NC}                           ${CYAN}│${NC}"
    echo -e "${CYAN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  Funnel needs to be enabled in your Tailscale ACL policy."
    echo -e "  We can do this automatically with an API key."
    echo ""
    echo -e "  ${CYAN}1.${NC} Go to ${BOLD}https://login.tailscale.com/admin/settings/keys${NC}"
    echo -e "  ${CYAN}2.${NC} Click ${BOLD}Generate API key${NC}"
    echo -e "  ${CYAN}3.${NC} Copy the key (starts with tskey-api-...)"
    echo ""

    # Try to open browser (xdg-open on Linux)
    if command -v xdg-open &>/dev/null; then
        xdg-open "https://login.tailscale.com/admin/settings/keys" 2>/dev/null || true
    fi

    echo -ne "  ${YELLOW}?${NC} Paste your API key: "
    read -r TAILSCALE_API_KEY

    if [[ -z "$TAILSCALE_API_KEY" ]]; then
        echo_error "API key is required to enable Funnel"
        return 1
    fi

    # Validate key format
    if [[ ! "$TAILSCALE_API_KEY" =~ ^tskey-api- ]]; then
        echo_error "Invalid API key format. Should start with 'tskey-api-'"
        return 1
    fi

    # Save to .env file
    if [[ -f "$ENV_FILE" ]]; then
        # Remove existing TAILSCALE_API_KEY line if present
        grep -v '^TAILSCALE_API_KEY=' "$ENV_FILE" > "$ENV_FILE.tmp" 2>/dev/null || true
        mv "$ENV_FILE.tmp" "$ENV_FILE"
    fi
    echo "TAILSCALE_API_KEY=$TAILSCALE_API_KEY" >> "$ENV_FILE"
    chmod 600 "$ENV_FILE"
    echo_info "API key saved to $ENV_FILE"
    return 0
}

# Check if Funnel is enabled in the ACL policy
check_funnel_enabled_in_acl() {
    if ! load_tailscale_api_key; then
        return 1
    fi

    local response
    response=$(curl -s --max-time 10 "https://api.tailscale.com/api/v2/tailnet/-/acl" \
        -u "${TAILSCALE_API_KEY}:" 2>/dev/null)

    if [[ -z "$response" ]]; then
        return 1
    fi

    # Check for API error
    if echo "$response" | jq -e '.message' &>/dev/null; then
        return 1
    fi

    # Check if nodeAttrs contains funnel attribute
    if echo "$response" | jq -e '.nodeAttrs[]?.attr[]? | select(. == "funnel")' &>/dev/null; then
        return 0
    fi

    return 1
}

# Enable Funnel in the Tailscale ACL policy
enable_funnel_in_acl() {
    if ! load_tailscale_api_key; then
        if ! prompt_tailscale_api_key; then
            return 1
        fi
    fi

    echo_info "Checking current Tailscale ACL policy..."

    # Get current ACL (request JSON format, not HuJSON)
    local current_acl
    current_acl=$(curl -s --max-time 10 "https://api.tailscale.com/api/v2/tailnet/-/acl" \
        -u "${TAILSCALE_API_KEY}:" \
        -H "Accept: application/json" 2>/dev/null)

    if [[ -z "$current_acl" ]]; then
        echo_error "Failed to fetch current ACL policy"
        return 1
    fi

    # Check for API error
    local error_msg
    error_msg=$(echo "$current_acl" | jq -r '.message // empty' 2>/dev/null)
    if [[ -n "$error_msg" ]]; then
        echo_error "API error: $error_msg"
        echo_error "Check your TAILSCALE_API_KEY in $ENV_FILE"
        return 1
    fi

    # Check if funnel is already enabled
    if echo "$current_acl" | jq -e '.nodeAttrs[]?.attr[]? | select(. == "funnel")' &>/dev/null; then
        echo_info "Funnel is already enabled in ACL policy"
        return 0
    fi

    echo_info "Adding Funnel attribute to ACL policy..."

    # Add funnel to nodeAttrs
    # If nodeAttrs doesn't exist or is empty, create it
    # If it exists, append to it
    local updated_acl
    if echo "$current_acl" | jq -e '.nodeAttrs | length > 0' &>/dev/null; then
        # nodeAttrs exists - check if there's already a target: ["*"] entry
        if echo "$current_acl" | jq -e '.nodeAttrs[] | select(.target == ["*"])' &>/dev/null; then
            # Add funnel to existing wildcard target
            updated_acl=$(echo "$current_acl" | jq '
                .nodeAttrs = [.nodeAttrs[] |
                    if .target == ["*"] then
                        .attr = ((.attr // []) + ["funnel"] | unique)
                    else
                        .
                    end
                ]
            ')
        else
            # Add new entry for wildcard target with funnel
            updated_acl=$(echo "$current_acl" | jq '.nodeAttrs += [{"target": ["*"], "attr": ["funnel"]}]')
        fi
    else
        # nodeAttrs doesn't exist - create it
        updated_acl=$(echo "$current_acl" | jq '. + {"nodeAttrs": [{"target": ["*"], "attr": ["funnel"]}]}')
    fi

    # Update the ACL
    local update_response
    update_response=$(curl -s --max-time 10 -X POST "https://api.tailscale.com/api/v2/tailnet/-/acl" \
        -u "${TAILSCALE_API_KEY}:" \
        -H "Content-Type: application/json" \
        -H "Accept: application/json" \
        --data-raw "$updated_acl" 2>/dev/null)

    # Check for errors
    error_msg=$(echo "$update_response" | jq -r '.message // empty' 2>/dev/null)
    if [[ -n "$error_msg" ]]; then
        echo_error "Failed to update ACL: $error_msg"
        return 1
    fi

    echo_info "Funnel enabled in ACL policy!"
    echo -e "  ${DIM}Changes may take up to 10 seconds to propagate.${NC}"
    sleep 10
    return 0
}

# =============================================================================
# Localtunnel config (stable URL)
# =============================================================================

has_localtunnel_subdomain() {
    [[ -f "$LOCALTUNNEL_SUBDOMAIN_FILE" ]]
}

# =============================================================================
# Slack API helpers (reused from local-tunnel)
# =============================================================================

load_slack_config() {
    if [[ ! -f "$SLACK_CONFIG_FILE" ]]; then
        return 1
    fi
    source "$SLACK_CONFIG_FILE"
    return 0
}

save_slack_config() {
    cat > "$SLACK_CONFIG_FILE" << EOF
SLACK_APP_ID="$SLACK_APP_ID"
SLACK_ACCESS_TOKEN="$SLACK_ACCESS_TOKEN"
SLACK_REFRESH_TOKEN="$SLACK_REFRESH_TOKEN"
SLACK_TOKEN_EXPIRES="$SLACK_TOKEN_EXPIRES"
EOF
    chmod 600 "$SLACK_CONFIG_FILE"
}

# =============================================================================
# Localtunnel config (stable URL)
# =============================================================================

has_stable_tunnel() {
    [[ -f "$LOCALTUNNEL_SUBDOMAIN_FILE" ]]
}

get_localtunnel_subdomain() {
    cat "$LOCALTUNNEL_SUBDOMAIN_FILE" 2>/dev/null
}

is_token_expired() {
    local now
    now=$(date +%s)
    local buffer=300  # 5 minutes
    if [[ -z "${SLACK_TOKEN_EXPIRES:-}" ]] || [[ $((SLACK_TOKEN_EXPIRES - buffer)) -lt $now ]]; then
        return 0  # expired
    fi
    return 1  # not expired
}

rotate_slack_token() {
    # Check if refresh token exists
    if [[ -z "${SLACK_REFRESH_TOKEN:-}" ]]; then
        echo_error "No refresh token configured"
        echo_error "Run 'remote-tunnel --setup' to configure Slack"
        return 1
    fi

    echo_info "Refreshing Slack configuration token..."

    local response
    response=$(curl -s --max-time 30 -X POST "https://slack.com/api/tooling.tokens.rotate" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "refresh_token=${SLACK_REFRESH_TOKEN}")

    local ok
    ok=$(echo "$response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$response" | jq -r '.error // "unknown error"')
        echo_error "Failed to refresh token: $error"
        echo_error "Run 'remote-tunnel --setup' to reconfigure"
        return 1
    fi

    SLACK_ACCESS_TOKEN=$(echo "$response" | jq -r '.token')
    SLACK_REFRESH_TOKEN=$(echo "$response" | jq -r '.refresh_token')
    local exp
    exp=$(echo "$response" | jq -r '.exp')
    SLACK_TOKEN_EXPIRES="$exp"

    save_slack_config
    echo_info "Token refreshed successfully"
    return 0
}

update_slack_request_url() {
    local actions_url="$1"
    local events_url="$2"

    # Ensure token is valid
    if is_token_expired; then
        if ! rotate_slack_token; then
            return 1
        fi
    fi

    echo_info "Updating Slack Request URLs..."

    local manifest_response
    manifest_response=$(curl -s --max-time 30 -X POST "https://slack.com/api/apps.manifest.export" \
        -H "Authorization: Bearer ${SLACK_ACCESS_TOKEN}" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "app_id=${SLACK_APP_ID}")

    local ok
    ok=$(echo "$manifest_response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$manifest_response" | jq -r '.error // "unknown error"')
        echo_error "Failed to export manifest: $error"
        return 1
    fi

    # Update both interactivity URL (for buttons) and event_subscriptions URL (for thread replies)
    local updated_manifest
    updated_manifest=$(echo "$manifest_response" | jq --arg actions_url "$actions_url" --arg events_url "$events_url" '
        .manifest.settings.interactivity.is_enabled = true |
        .manifest.settings.interactivity.request_url = $actions_url |
        .manifest.settings.event_subscriptions.request_url = $events_url |
        .manifest
    ')

    local update_response
    update_response=$(curl -s --max-time 30 -X POST "https://slack.com/api/apps.manifest.update" \
        -H "Authorization: Bearer ${SLACK_ACCESS_TOKEN}" \
        -H "Content-Type: application/json" \
        -d "{\"app_id\": \"${SLACK_APP_ID}\", \"manifest\": ${updated_manifest}}")

    ok=$(echo "$update_response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$update_response" | jq -r '.error // "unknown error"')
        echo_error "Failed to update manifest: $error"
        local errors
        errors=$(echo "$update_response" | jq -r '.errors // empty')
        if [[ -n "$errors" ]]; then
            echo_error "Details: $errors"
        fi
        return 1
    fi

    echo_info "Slack URLs updated:"
    echo_info "  Actions: $actions_url"
    echo_info "  Events:  $events_url"
    return 0
}

# =============================================================================
# Remote relay helpers
# =============================================================================

find_relay_dist() {
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

    # Check installed location first
    if [[ -f "$CLAUDE_DIR/mcp-server-dist/dist/remote-relay.js" ]]; then
        echo "$CLAUDE_DIR/mcp-server-dist/dist/remote-relay.js"
        return 0
    fi

    # Check development location
    if [[ -f "$script_dir/../mcp-server/dist/remote-relay.js" ]]; then
        echo "$script_dir/../mcp-server/dist/remote-relay.js"
        return 0
    fi

    return 1
}

check_relay_running() {
    if curl -s "http://localhost:$RELAY_PORT/health" &>/dev/null; then
        return 0
    fi
    return 1
}

# Kill any orphan process on RELAY_PORT that's not tracked by our PID file
# Returns 0 if orphans were killed, 1 if port was clear
kill_orphan_relay() {
    local pid_file="$RELAY_PID_FILE"
    local tracked_pid=""
    local killed_orphan=false

    # Get tracked PID (if valid)
    if [[ -f "$pid_file" ]]; then
        tracked_pid=$(cat "$pid_file" 2>/dev/null)
        # Verify it's actually running
        if [[ -n "$tracked_pid" ]] && ! kill -0 "$tracked_pid" 2>/dev/null; then
            # Stale PID file - remove it
            rm -f "$pid_file"
            tracked_pid=""
        fi
    fi

    # Find any process listening on RELAY_PORT
    # Use ss on Linux (lsof may not be available)
    local port_pid=""
    if command -v lsof &>/dev/null; then
        port_pid=$(lsof -ti ":$RELAY_PORT" 2>/dev/null | head -1)
    elif command -v ss &>/dev/null; then
        # ss output format: find listening socket, extract PID
        port_pid=$(ss -tlnp "sport = :$RELAY_PORT" 2>/dev/null | grep -oP 'pid=\K[0-9]+' | head -1)
    elif command -v fuser &>/dev/null; then
        port_pid=$(fuser "$RELAY_PORT/tcp" 2>/dev/null | awk '{print $1}')
    fi

    if [[ -n "$port_pid" ]]; then
        if [[ "$port_pid" != "$tracked_pid" ]]; then
            # Orphan process found - kill it
            echo_warn "Killing orphan process on port $RELAY_PORT (PID: $port_pid)"
            kill "$port_pid" 2>/dev/null || true
            sleep 0.5
            # Force kill if still running
            if kill -0 "$port_pid" 2>/dev/null; then
                kill -9 "$port_pid" 2>/dev/null || true
                sleep 0.5
            fi
            killed_orphan=true
        fi
    fi

    # Clean up stale PID file if process doesn't match port
    if [[ -n "$tracked_pid" ]] && [[ "$tracked_pid" != "$port_pid" ]]; then
        rm -f "$pid_file"
    fi

    $killed_orphan && return 0 || return 1
}

start_relay() {
    local relay_path
    if ! relay_path=$(find_relay_dist); then
        echo_error "Remote relay not found."
        echo_error "Build the MCP server first: cd mcp-server && bun run build"
        exit 1
    fi

    # Kill any orphan process on the port first
    kill_orphan_relay || true

    echo_info "Starting remote relay..."
    nohup node "$relay_path" > "$CLAUDE_DIR/remote-relay.log" 2>&1 &
    local relay_pid=$!
    echo "$relay_pid" > "$RELAY_PID_FILE"

    # Wait for relay to start
    for i in {1..10}; do
        if check_relay_running; then
            echo_info "Remote relay started (PID: $relay_pid)"
            return 0
        fi
        sleep 0.5
    done

    echo_error "Remote relay failed to start. Check $CLAUDE_DIR/remote-relay.log"
    exit 1
}

stop_relay() {
    local pid_file="$RELAY_PID_FILE"
    local stopped=false

    # Kill tracked process from PID file
    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            stopped=true
        fi
        rm -f "$pid_file"
    fi

    # Also kill any orphan process on the port
    if kill_orphan_relay; then
        stopped=true
    fi

    if $stopped; then
        echo_info "Remote relay stopped"
    fi
}

# =============================================================================
# Idle watchdog (for --background mode)
# =============================================================================

start_watchdog() {
    touch "$ACTIVITY_FILE"

    (
        while true; do
            sleep 300  # Check every 5 minutes

            if [[ ! -f "$ACTIVITY_FILE" ]]; then
                continue
            fi

            local last now
            last=$(stat -c %Y "$ACTIVITY_FILE" 2>/dev/null)
            now=$(date +%s)

            # If stat failed, skip this check (don't treat as idle)
            if [[ -z "$last" || ! "$last" =~ ^[0-9]+$ ]]; then
                continue
            fi

            if [[ $((now - last)) -gt $IDLE_TIMEOUT ]]; then
                echo "$(date): Idle timeout ($IDLE_TIMEOUT seconds), shutting down" >> "$TUNNEL_LOG"

                if [[ -f "$TUNNEL_PID_FILE" ]]; then
                    local tunnel_pid
                    tunnel_pid=$(cat "$TUNNEL_PID_FILE")
                    kill "$tunnel_pid" 2>/dev/null || true
                    rm -f "$TUNNEL_PID_FILE"
                fi

                stop_relay
                rm -f "$ACTIVITY_FILE"
                rm -f "$WATCHDOG_PID_FILE"
                exit 0
            fi
        done
    ) &
    local watchdog_pid=$!
    echo "$watchdog_pid" > "$WATCHDOG_PID_FILE"
    echo_info "Idle watchdog started (timeout: ${IDLE_TIMEOUT}s)"
}

stop_watchdog() {
    if [[ -f "$WATCHDOG_PID_FILE" ]]; then
        local pid
        pid=$(cat "$WATCHDOG_PID_FILE")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
        fi
        rm -f "$WATCHDOG_PID_FILE"
    fi
}

# =============================================================================
# Start tunnel and get URL
# =============================================================================

start_tunnel_and_get_url() {
    local background="${1:-false}"
    local log_file="$CLAUDE_DIR/.remote-tunnel.log"

    # Kill any existing tunnel processes
    pkill -f "lt --port.*${RELAY_PORT}" 2>/dev/null || true
    rm -f "$TUNNEL_PID_FILE" "$TUNNEL_URL_FILE" "$log_file"
    sleep 0.5

    # Require stable tunnel configuration
    if ! has_stable_tunnel; then
        echo_error "Stable URL not configured."
        echo ""
        echo -e "  Run ${BOLD}remote-tunnel${NC} interactively to configure your subdomain."
        exit 1
    fi

    local subdomain
    subdomain=$(get_localtunnel_subdomain)

    if ! command -v lt &>/dev/null; then
        echo_warn "Localtunnel not installed. Installing..."
        if command -v npm &>/dev/null; then
            sudo npm install -g localtunnel
        else
            echo_error "Cannot install localtunnel."
            echo ""
            echo -e "  Install with: ${BOLD}sudo npm install -g localtunnel${NC}"
            exit 1
        fi
    fi

    echo_info "Starting Localtunnel (stable URL: ${subdomain}.loca.lt)..."

    if [[ "$background" == "true" ]]; then
        nohup lt --port "$RELAY_PORT" --subdomain "$subdomain" > "$log_file" 2>&1 &
    else
        lt --port "$RELAY_PORT" --subdomain "$subdomain" > "$log_file" 2>&1 &
    fi
    TUNNEL_PID=$!
    echo "$TUNNEL_PID" > "$TUNNEL_PID_FILE"

    # Wait for URL to appear
    local tunnel_url=""
    for i in {1..20}; do
        if [[ -f "$log_file" ]]; then
            tunnel_url=$(grep -oE 'https://[a-z0-9-]+\.loca\.lt' "$log_file" 2>/dev/null | head -1 || true)
            if [[ -n "$tunnel_url" ]]; then
                break
            fi
        fi
        sleep 0.5
    done

    if [[ -z "$tunnel_url" ]]; then
        echo_error "Failed to start localtunnel"
        cat "$log_file" 2>/dev/null | tail -5
        kill "$TUNNEL_PID" 2>/dev/null || true
        rm -f "$TUNNEL_PID_FILE"
        exit 1
    fi

    echo "$tunnel_url" > "$TUNNEL_URL_FILE"
    TUNNEL_URL="$tunnel_url"

    # Check if we got the subdomain we requested
    local expected_url="https://${subdomain}.loca.lt"
    if [[ "$tunnel_url" != "$expected_url" ]]; then
        echo_warn "Subdomain '$subdomain' unavailable - got random URL instead"
        echo_warn "Your stable subdomain may be in use. Try again in a few minutes,"
        echo_warn "or choose a new subdomain with: remote-tunnel --stable"
        echo ""
    fi

    echo_info "Tunnel started: $tunnel_url"
}

# =============================================================================
# --setup: Configure Slack (copy from Mac or manual)
# =============================================================================

cmd_setup() {
    echo ""
    echo -e "${BOLD}Remote Tunnel Setup${NC}"
    echo -e "${DIM}Configure Slack API tokens for button support${NC}"
    echo ""

    # Check dependencies
    if ! command -v jq &>/dev/null; then
        echo_error "jq is required but not installed."
        echo "  Install with: sudo apt install jq"
        exit 1
    fi

    if ! command -v lt &>/dev/null; then
        echo_error "Localtunnel is required but not installed."
        echo "  Install with: npm install -g localtunnel"
        exit 1
    fi

    # Check if config already exists
    if [[ -f "$SLACK_CONFIG_FILE" ]]; then
        echo_info "Slack config already exists at $SLACK_CONFIG_FILE"
        echo ""
        echo -ne "  ${YELLOW}?${NC} Replace existing config? [y/N] "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo_info "Keeping existing config"
            return 0
        fi
    fi

    echo ""
    echo -e "${CYAN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${CYAN}│${NC}  ${BOLD}Option 1: Copy config from Mac (recommended)${NC}              ${CYAN}│${NC}"
    echo -e "${CYAN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  Run this on your Mac:"
    echo -e "    ${BOLD}scp ~/.claude/.slack-config $(hostname):~/.claude/${NC}"
    echo ""
    echo -e "  Or run this here if you have SSH access to Mac:"
    echo -e "    ${BOLD}scp mac:~/.claude/.slack-config ~/.claude/${NC}"
    echo ""
    echo -e "${CYAN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${CYAN}│${NC}  ${BOLD}Option 2: Manual setup${NC}                                     ${CYAN}│${NC}"
    echo -e "${CYAN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  ${CYAN}1.${NC} Go to ${BOLD}https://api.slack.com/apps${NC}"
    echo -e "  ${CYAN}2.${NC} Copy the ${BOLD}App ID${NC} from your app"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Paste your App ID (or Enter to skip): "
    read -r SLACK_APP_ID

    if [[ -z "$SLACK_APP_ID" ]]; then
        echo_warn "Setup skipped. Copy config from Mac or run setup again."
        return 0
    fi

    if [[ ! "$SLACK_APP_ID" =~ ^A[A-Z0-9]+$ ]]; then
        echo_error "Invalid App ID format. Should start with 'A' followed by letters/numbers."
        exit 1
    fi

    echo ""
    echo -e "  ${CYAN}3.${NC} Scroll to ${BOLD}Your App Configuration Tokens${NC} at bottom of page"
    echo -e "  ${CYAN}4.${NC} Generate a token and paste the ${BOLD}Access Token${NC}:"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Access Token: "
    read -r SLACK_ACCESS_TOKEN

    if [[ -z "$SLACK_ACCESS_TOKEN" ]]; then
        echo_error "Access token is required"
        exit 1
    fi

    echo ""
    echo -e "  ${CYAN}5.${NC} Copy the ${BOLD}Refresh Token${NC}:"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Refresh Token: "
    read -r SLACK_REFRESH_TOKEN

    if [[ -z "$SLACK_REFRESH_TOKEN" ]]; then
        echo_error "Refresh token is required"
        exit 1
    fi

    SLACK_TOKEN_EXPIRES=$(($(date +%s) + 43200))
    save_slack_config

    echo ""
    echo_info "Configuration saved to $SLACK_CONFIG_FILE"

    # Also copy slack signing secret if provided
    echo ""
    echo -e "  ${CYAN}6.${NC} (Optional) Your Slack ${BOLD}Signing Secret${NC} for request verification:"
    echo -e "     ${DIM}Found at: Your App → Basic Information → Signing Secret${NC}"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Signing Secret (or Enter to skip): "
    read -r SIGNING_SECRET

    if [[ -n "$SIGNING_SECRET" ]]; then
        echo "$SIGNING_SECRET" > "$CLAUDE_DIR/slack-signing-secret"
        chmod 600 "$CLAUDE_DIR/slack-signing-secret"
        echo_info "Signing secret saved"
    fi

    echo ""
    echo -e "${GREEN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${GREEN}│${NC}  ${GREEN}✓${NC} ${BOLD}Setup Complete!${NC}                                          ${GREEN}│${NC}"
    echo -e "${GREEN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  ${BOLD}To start the tunnel:${NC}"
    echo -e "    remote-tunnel"
    echo ""
}

# =============================================================================
# --stable: Setup stable URL with Localtunnel and start tunnel
# =============================================================================

cmd_stable() {
    # Check if localtunnel is installed
    if ! command -v lt &>/dev/null; then
        echo_warn "Localtunnel not installed. Installing..."
        echo ""
        if command -v npm &>/dev/null; then
            npm install -g localtunnel
        else
            echo_error "npm not found. Please install Node.js first."
            exit 1
        fi
        echo ""
    fi

    # If already configured, ask if they want to reconfigure or just start
    if has_stable_tunnel; then
        local current
        current=$(get_localtunnel_subdomain)
        local tunnel_url="https://${current}.loca.lt"

        echo ""
        echo -e "  ${GREEN}✓${NC} Stable URL already configured: ${CYAN}${tunnel_url}${NC}"
        echo ""
        echo -ne "  ${YELLOW}?${NC} Change subdomain? [y/N] "
        read -r change_subdomain

        if [[ ! "$change_subdomain" =~ ^[Yy]$ ]]; then
            # Just start the tunnel with existing config
            echo ""
            cmd_interactive
            return
        fi
        echo ""
    fi

    # Setup flow
    echo ""
    echo -e "${BOLD}Stable Tunnel Setup${NC}"
    echo -e "${DIM}Get a URL that stays the same every time${NC}"
    echo ""

    echo -e "  ${GREEN}✓${NC} URL stays the same every restart"
    echo -e "  ${GREEN}✓${NC} No Slack tokens needed for URL updates"
    echo -e "  ${GREEN}✓${NC} Set Slack URLs once, never again"
    echo ""

    echo -e "  Choose a unique subdomain for your tunnel."
    echo -e "  ${DIM}Pick something unlikely to be taken (e.g., claude-remote-yourname)${NC}"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Subdomain: "
    read -r subdomain

    if [[ -z "$subdomain" ]]; then
        echo_error "Subdomain is required"
        exit 1
    fi

    # Remove any protocol or domain suffix if user pasted full URL
    subdomain="${subdomain#https://}"
    subdomain="${subdomain%.loca.lt}"
    subdomain="${subdomain%%/*}"

    # Validate subdomain (alphanumeric and hyphens only)
    if [[ ! "$subdomain" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$ ]]; then
        echo_error "Invalid subdomain. Use only letters, numbers, and hyphens."
        exit 1
    fi

    # Save subdomain
    echo "$subdomain" > "$LOCALTUNNEL_SUBDOMAIN_FILE"
    chmod 600 "$LOCALTUNNEL_SUBDOMAIN_FILE"

    local tunnel_url="https://${subdomain}.loca.lt"

    echo ""
    echo_info "Testing tunnel..."

    # Test the tunnel briefly
    local log_file="$CLAUDE_DIR/.localtunnel-test.log"
    rm -f "$log_file"

    lt --port "$RELAY_PORT" --subdomain "$subdomain" > "$log_file" 2>&1 &
    local test_pid=$!

    local connected=""
    for i in {1..10}; do
        if grep -q "your url is" "$log_file" 2>/dev/null; then
            connected="true"
            break
        fi
        sleep 1
    done

    kill "$test_pid" 2>/dev/null || true
    wait "$test_pid" 2>/dev/null || true

    if [[ -z "$connected" ]]; then
        echo_warn "Could not verify tunnel. The subdomain might be taken."
        echo -e "  ${DIM}Try a more unique name if it doesn't work.${NC}"
        cat "$log_file" 2>/dev/null | tail -3
    else
        echo -e "  ${GREEN}✓${NC} Tunnel works!"
    fi

    echo ""
    echo -e "${GREEN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${GREEN}│${NC}  ${GREEN}✓${NC} ${BOLD}Stable URL Configured!${NC}                                    ${GREEN}│${NC}"
    echo -e "${GREEN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  ${BOLD}Your stable URL:${NC} ${CYAN}${tunnel_url}${NC}"
    echo ""

    # Try to auto-update Slack if tokens exist
    local slack_updated=false
    if load_slack_config && [[ -n "${SLACK_APP_ID:-}" ]]; then
        echo_info "Updating Slack app settings..."
        if update_slack_request_url "${tunnel_url}/slack/actions" "${tunnel_url}/slack/events"; then
            slack_updated=true
            echo -e "  ${GREEN}✓${NC} Slack Request URLs updated automatically!"
            echo ""
        fi
    fi

    if [[ "$slack_updated" != "true" ]]; then
        echo -e "  ${BOLD}Update your Slack app (one-time only):${NC}"
        echo ""
        echo -e "  ${CYAN}1.${NC} Go to ${BOLD}https://api.slack.com/apps${NC} → your app"
        echo -e "  ${CYAN}2.${NC} ${BOLD}Interactivity & Shortcuts${NC} → Request URL:"
        echo -e "       ${BOLD}${tunnel_url}/slack/actions${NC}"
        echo -e "  ${CYAN}3.${NC} ${BOLD}Event Subscriptions${NC} → Request URL:"
        echo -e "       ${BOLD}${tunnel_url}/slack/events${NC}"
        echo ""
    fi

    # Start the tunnel
    echo_info "Starting tunnel..."
    echo ""
    cmd_interactive
}

# =============================================================================
# --background: Start tunnel in background
# =============================================================================

check_tunnel_running() {
    if [[ -f "$TUNNEL_PID_FILE" ]]; then
        local pid
        pid=$(cat "$TUNNEL_PID_FILE")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
    fi
    return 1
}

cmd_background() {
    if ! load_slack_config; then
        echo_error "Slack not configured. Run: remote-tunnel --setup"
        exit 1
    fi

    local relay_needs_start=true
    local tunnel_was_running=false
    local need_slack_update=false

    # Check relay status - verify PID file matches what's actually running
    if check_relay_running; then
        local tracked_pid=""
        local port_pid=""
        if [[ -f "$RELAY_PID_FILE" ]]; then
            tracked_pid=$(cat "$RELAY_PID_FILE" 2>/dev/null)
        fi
        # Find process on port
        if command -v lsof &>/dev/null; then
            port_pid=$(lsof -ti ":$RELAY_PORT" 2>/dev/null | head -1)
        elif command -v ss &>/dev/null; then
            port_pid=$(ss -tlnp "sport = :$RELAY_PORT" 2>/dev/null | grep -oP 'pid=\K[0-9]+' | head -1)
        fi

        if [[ -n "$tracked_pid" ]] && [[ "$tracked_pid" == "$port_pid" ]] && kill -0 "$tracked_pid" 2>/dev/null; then
            # Our tracked process is running correctly
            relay_needs_start=false
            echo_info "Remote relay already running (PID: $tracked_pid)"
        else
            # Orphan or mismatched process - will be cleaned up by start_relay
            echo_info "Cleaning up stale relay..."
        fi
    fi

    # Check tunnel status - Tailscale Funnel or Localtunnel
    if is_tailscale_funnel_active; then
        tunnel_was_running=true
        echo_info "Tailscale Funnel already running"
    elif check_tunnel_running; then
        tunnel_was_running=true
        echo_info "Localtunnel already running"
    fi

    # If both running correctly, nothing to do
    if [[ "$relay_needs_start" == "false" && "$tunnel_was_running" == "true" ]]; then
        echo_info "All services already running"
        cmd_status
        return 0
    fi

    # Start relay if needed
    if $relay_needs_start; then
        start_relay
    fi

    # Start tunnel if needed
    if [[ "$tunnel_was_running" == "false" ]]; then
        # Try Tailscale Funnel first (if available and not forced to use localtunnel)
        local tunnel_started=false
        if [[ "$TUNNEL_TYPE" != "localtunnel" ]] && has_tailscale && is_tailscale_connected; then
            if start_tailscale_funnel "true"; then
                tunnel_started=true
            else
                echo_warn "Tailscale Funnel failed, falling back to Localtunnel..."
            fi
        fi

        # Fall back to localtunnel
        if [[ "$tunnel_started" == "false" ]]; then
            if ! has_localtunnel_subdomain; then
                echo_error "No tunnel backend available."
                echo ""
                echo -e "  Either:"
                echo -e "    1. Enable Tailscale Funnel: ${BOLD}sudo tailscale funnel ${RELAY_PORT}${NC}"
                echo -e "    2. Configure Localtunnel: ${BOLD}remote-tunnel --stable${NC}"
                exit 1
            fi
            start_tunnel_and_get_url "true"
        fi
        need_slack_update=true
    fi

    # Update Slack Request URLs if we started a new tunnel
    if [[ "$need_slack_update" == "true" ]]; then
        if ! update_slack_request_url "${TUNNEL_URL}/slack/actions" "${TUNNEL_URL}/slack/events"; then
            echo_warn "Failed to update Slack, but tunnel is running"
            echo_warn "Manually set Request URLs:"
            echo_warn "  Actions: ${TUNNEL_URL}/slack/actions"
            echo_warn "  Events:  ${TUNNEL_URL}/slack/events"
        fi
    fi

    # Start/restart idle watchdog
    stop_watchdog 2>/dev/null || true
    start_watchdog

    touch "$ACTIVITY_FILE"

    echo_info "Remote tunnel running in background"
}

# =============================================================================
# --stop: Stop background tunnel
# =============================================================================

cmd_stop() {
    local stopped=false

    stop_watchdog && stopped=true

    # Stop Tailscale Funnel if active
    if stop_tailscale_funnel; then
        stopped=true
    fi

    # Stop Localtunnel if running
    if [[ -f "$TUNNEL_PID_FILE" ]]; then
        local pid
        pid=$(cat "$TUNNEL_PID_FILE")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            echo_info "Localtunnel stopped"
            stopped=true
        fi
        rm -f "$TUNNEL_PID_FILE"
    fi

    # Kill any remaining localtunnel processes on our port
    local stale_count=0
    while IFS= read -r pid; do
        if [[ -n "$pid" ]]; then
            kill "$pid" 2>/dev/null || true
            ((stale_count++)) || true
        fi
    done < <(pgrep -f "lt --port.*${RELAY_PORT}" 2>/dev/null || true)

    if [[ "$stale_count" -gt 0 ]]; then
        echo_info "Cleaned up $stale_count stale localtunnel process(es)"
        stopped=true
    fi

    # Remove tunnel URL and type files
    rm -f "$TUNNEL_URL_FILE" "$TUNNEL_TYPE_FILE"

    stop_relay && stopped=true

    rm -f "$ACTIVITY_FILE"

    if [[ "$stopped" == "true" ]]; then
        echo_info "All services stopped"
    else
        echo_info "No services were running"
    fi
}

# =============================================================================
# --status: Check tunnel status
# =============================================================================

cmd_status() {
    echo ""
    echo -e "${BOLD}Remote Tunnel Status${NC}"
    echo ""

    # Check Tailscale availability and status
    if has_tailscale && is_tailscale_connected; then
        local ts_dns
        ts_dns=$(get_tailscale_dns_name)
        if is_tailscale_funnel_active; then
            echo -e "  Backend:    ${GREEN}Tailscale Funnel${NC} (active)"
            echo -e "  URL:        ${CYAN}https://${ts_dns}${NC}"
        else
            echo -e "  Tailscale:  ${CYAN}Available${NC} (${ts_dns})"
            if has_localtunnel_subdomain; then
                local subdomain
                subdomain=$(get_localtunnel_subdomain)
                echo -e "  Localtunnel: ${CYAN}Configured${NC} (${subdomain}.loca.lt)"
            fi
        fi
    elif has_localtunnel_subdomain; then
        local subdomain
        subdomain=$(get_localtunnel_subdomain)
        echo -e "  Backend:    ${GREEN}Localtunnel${NC}"
        echo -e "  URL:        ${CYAN}https://${subdomain}.loca.lt${NC}"
    else
        echo -e "  Backend:    ${YELLOW}Not configured${NC}"
        echo -e "              ${DIM}Tailscale recommended, or run --stable for Localtunnel${NC}"
    fi
    echo ""

    # Check relay - detect orphans
    local relay_tracked_pid=""
    local relay_port_pid=""
    if [[ -f "$RELAY_PID_FILE" ]]; then
        relay_tracked_pid=$(cat "$RELAY_PID_FILE" 2>/dev/null)
    fi
    # Find process on port
    if command -v lsof &>/dev/null; then
        relay_port_pid=$(lsof -ti ":$RELAY_PORT" 2>/dev/null | head -1)
    elif command -v ss &>/dev/null; then
        relay_port_pid=$(ss -tlnp "sport = :$RELAY_PORT" 2>/dev/null | grep -oP 'pid=\K[0-9]+' | head -1)
    fi

    if check_relay_running; then
        if [[ -n "$relay_tracked_pid" ]] && [[ "$relay_tracked_pid" == "$relay_port_pid" ]]; then
            echo -e "  Relay:      ${GREEN}Running${NC} (PID: $relay_tracked_pid)"
        elif [[ -n "$relay_port_pid" ]]; then
            echo -e "  Relay:      ${YELLOW}Orphan process${NC} (PID: $relay_port_pid, not tracked)"
            echo -e "              ${DIM}Run: remote-tunnel --stop && remote-tunnel --background${NC}"
        else
            echo -e "  Relay:      ${GREEN}Running${NC}"
        fi
    else
        if [[ -n "$relay_tracked_pid" ]]; then
            echo -e "  Relay:      ${YELLOW}Stopped${NC} (stale PID file: $relay_tracked_pid)"
        else
            echo -e "  Relay:      ${YELLOW}Stopped${NC}"
        fi
    fi

    # Check tunnel - Tailscale Funnel or Localtunnel
    if is_tailscale_funnel_active; then
        echo -e "  Tunnel:     ${GREEN}Running${NC} (Tailscale Funnel)"
        if [[ -f "$TUNNEL_URL_FILE" ]]; then
            local url
            url=$(cat "$TUNNEL_URL_FILE")
            echo -e "  Actions:    ${CYAN}$url/slack/actions${NC}"
        fi
    elif [[ -f "$TUNNEL_PID_FILE" ]]; then
        local pid
        pid=$(cat "$TUNNEL_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "  Tunnel:     ${GREEN}Running${NC} (Localtunnel PID: $pid)"
            if [[ -f "$TUNNEL_URL_FILE" ]]; then
                local url
                url=$(cat "$TUNNEL_URL_FILE")
                echo -e "  Actions:    ${CYAN}$url/slack/actions${NC}"
            fi
        else
            echo -e "  Tunnel:     ${YELLOW}Stopped${NC} (stale PID file)"
        fi
    else
        echo -e "  Tunnel:     ${YELLOW}Stopped${NC}"
    fi

    # Check watchdog
    if [[ -f "$WATCHDOG_PID_FILE" ]]; then
        local pid
        pid=$(cat "$WATCHDOG_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "  Watchdog:   ${GREEN}Running${NC}"
        else
            echo -e "  Watchdog:   ${YELLOW}Stopped${NC}"
        fi
    else
        echo -e "  Watchdog:   ${YELLOW}Stopped${NC}"
    fi

    # Check Mac tunnel URL
    if [[ -f "$CLAUDE_DIR/.mac-tunnel-url" ]]; then
        local mac_url
        mac_url=$(cat "$CLAUDE_DIR/.mac-tunnel-url")
        echo -e "  Mac URL:    ${DIM}$mac_url${NC}"
    fi

    # Check last activity
    if [[ -f "$ACTIVITY_FILE" ]]; then
        local last now elapsed
        last=$(stat -c %Y "$ACTIVITY_FILE" 2>/dev/null || echo 0)
        now=$(date +%s)
        elapsed=$((now - last))
        local remaining=$((IDLE_TIMEOUT - elapsed))
        if [[ $remaining -gt 0 ]]; then
            echo -e "  Idle timer: ${DIM}${remaining}s until auto-stop${NC}"
        fi
    fi

    echo ""
}

# =============================================================================
# Default: Interactive mode
# =============================================================================

cmd_interactive() {
    echo ""
    echo -e "${BOLD}Remote Tunnel for Claude Slack Buttons${NC}"
    echo -e "${DIM}Receive Slack button clicks when your Mac is closed${NC}"
    echo ""

    local using_tailscale=false
    local using_localtunnel=false

    if ! load_slack_config; then
        echo_warn "Slack not configured yet."
        echo ""
        echo -ne "  ${YELLOW}?${NC} Run setup now? [Y/n] "
        read -r response
        if [[ "$response" =~ ^[Nn]$ ]]; then
            exit 0
        fi
        cmd_setup
        load_slack_config
    fi

    # Kill existing relay and start fresh (handles orphans)
    if check_relay_running; then
        echo_info "Stopping existing relay..."
        local old_pid
        old_pid=$(cat "$RELAY_PID_FILE" 2>/dev/null)
        if [[ -n "$old_pid" ]]; then
            kill "$old_pid" 2>/dev/null || true
            sleep 1
        fi
    fi
    start_relay

    # Cleanup on exit
    cleanup() {
        echo ""
        echo_info "Shutting down..."
        # Stop Tailscale Funnel if active
        stop_tailscale_funnel 2>/dev/null || true
        # Stop Localtunnel if running
        if [[ -n "${TUNNEL_PID:-}" ]]; then
            kill "$TUNNEL_PID" 2>/dev/null || true
        fi
        stop_relay
        rm -f "$TUNNEL_PID_FILE" "$TUNNEL_URL_FILE" "$TUNNEL_TYPE_FILE"
    }
    trap cleanup EXIT INT TERM

    # Try Tailscale Funnel first (if available and not forced to use localtunnel)
    if [[ "$TUNNEL_TYPE" != "localtunnel" ]] && has_tailscale && is_tailscale_connected; then
        if start_tailscale_funnel "false"; then
            using_tailscale=true
        else
            echo_warn "Tailscale Funnel failed, falling back to Localtunnel..."
        fi
    fi

    # Fall back to Localtunnel if Tailscale not available
    if [[ "$using_tailscale" == "false" ]]; then
        if has_localtunnel_subdomain; then
            using_localtunnel=true
            local subdomain
            subdomain=$(get_localtunnel_subdomain)
            echo_info "Using stable URL: https://${subdomain}.loca.lt"
            start_tunnel_and_get_url "false"
        else
            # No Tailscale, no stable Localtunnel - need setup
            echo_warn "No tunnel backend available."
            echo ""
            echo -e "  ${BOLD}Options:${NC}"
            echo -e "  ${CYAN}1.${NC} Install and connect Tailscale (recommended)"
            echo -e "  ${CYAN}2.${NC} Run ${BOLD}remote-tunnel --stable${NC} to setup Localtunnel"
            echo ""
            exit 1
        fi
    fi

    # Update Slack Request URLs
    if update_slack_request_url "${TUNNEL_URL}/slack/actions" "${TUNNEL_URL}/slack/events"; then
        echo ""
        if [[ "$using_tailscale" == "true" ]]; then
            echo -e "${GREEN}╭──────────────────────────────────────────────────────────────╮${NC}"
            echo -e "${GREEN}│${NC}  ${GREEN}✓${NC} ${BOLD}Tailscale Funnel connected!${NC}                               ${GREEN}│${NC}"
            echo -e "${GREEN}╰──────────────────────────────────────────────────────────────╯${NC}"
        else
            echo -e "${GREEN}╭──────────────────────────────────────────────────────────────╮${NC}"
            echo -e "${GREEN}│${NC}  ${GREEN}✓${NC} ${BOLD}Localtunnel connected!${NC}                                    ${GREEN}│${NC}"
            echo -e "${GREEN}╰──────────────────────────────────────────────────────────────╯${NC}"
        fi
        echo ""
        echo -e "  URL: ${CYAN}${TUNNEL_URL}${NC}"
        echo ""
        echo -e "  ${DIM}Slack URLs updated automatically.${NC}"
        echo -e "  ${DIM}Slack buttons and thread replies will now work.${NC}"
        echo -e "  ${DIM}Keep this running. Press Ctrl+C to stop.${NC}"
        echo ""
        echo -e "  ${BOLD}Note:${NC} Focus button won't switch windows (Mac not involved)."
        echo -e "  ${DIM}Only 1/2/Continue/Push buttons and thread replies work.${NC}"
    else
        echo ""
        echo -e "${YELLOW}╭──────────────────────────────────────────────────────────────╮${NC}"
        echo -e "${YELLOW}│${NC}  ${YELLOW}!${NC} ${BOLD}Could not auto-update Slack${NC}                               ${YELLOW}│${NC}"
        echo -e "${YELLOW}╰──────────────────────────────────────────────────────────────╯${NC}"
        echo ""
        echo -e "  Actions URL: ${CYAN}${TUNNEL_URL}/slack/actions${NC}"
        echo -e "  Events URL:  ${CYAN}${TUNNEL_URL}/slack/events${NC}"
        echo ""
        echo -e "  ${BOLD}Manually update in Slack:${NC}"
        echo -e "  ${CYAN}1.${NC} Go to ${BOLD}https://api.slack.com/apps/${SLACK_APP_ID}${NC}"
        echo -e "  ${CYAN}2.${NC} ${BOLD}Interactivity & Shortcuts${NC} → Set Request URL"
        echo -e "  ${CYAN}3.${NC} ${BOLD}Event Subscriptions${NC} → Set Request URL"
        echo -e "  ${CYAN}4.${NC} Click ${BOLD}Save Changes${NC} on each page"
        echo ""
        echo -e "  ${DIM}Keep this running. Press Ctrl+C to stop.${NC}"
    fi
    echo ""

    # Keep running - wait on tunnel process (Localtunnel) or just sleep (Tailscale)
    if [[ "$using_tailscale" == "true" ]]; then
        # Tailscale Funnel runs with --bg, so just sleep forever
        while true; do
            sleep 3600
        done
    else
        # Wait for Localtunnel process
        wait "$TUNNEL_PID" 2>/dev/null || true
    fi
}

# =============================================================================
# Main
# =============================================================================

case "${1:-}" in
    --setup)
        cmd_setup
        ;;
    --background)
        cmd_background
        ;;
    --stop)
        cmd_stop
        ;;
    --status)
        cmd_status
        ;;
    --use-tailscale)
        TUNNEL_TYPE="tailscale"
        shift
        case "${1:-}" in
            --background) cmd_background ;;
            "") cmd_interactive ;;
            *) echo_error "Unknown command after --use-tailscale: $1"; exit 1 ;;
        esac
        ;;
    --use-localtunnel)
        TUNNEL_TYPE="localtunnel"
        shift
        case "${1:-}" in
            --background) cmd_background ;;
            --stable|"") cmd_stable ;;
            *) echo_error "Unknown command after --use-localtunnel: $1"; exit 1 ;;
        esac
        ;;
    --help|-h)
        echo "Usage: remote-tunnel [command]"
        echo ""
        echo "Commands:"
        echo "  (none)         Start tunnel (Tailscale if available, else Localtunnel)"
        echo "  --setup        Configure Slack tokens (for auto-URL updates)"
        echo "  --background   Start tunnel in background"
        echo "  --stop         Stop background tunnel"
        echo "  --status       Check tunnel status"
        echo ""
        echo "Backend options:"
        echo "  --use-tailscale    Force Tailscale Funnel"
        echo "  --use-localtunnel  Force Localtunnel"
        echo ""
        ;;
    --stable)
        cmd_stable
        ;;
    "")
        # Default: try Tailscale, fall back to Localtunnel setup
        if has_tailscale && is_tailscale_connected; then
            cmd_interactive
        else
            cmd_stable
        fi
        ;;
    *)
        echo_error "Unknown command: $1"
        echo "Run: remote-tunnel --help"
        exit 1
        ;;
esac
