#!/bin/bash
# Focus helper - switches to the correct iTerm2/Terminal.app tab and/or tmux window
# Called by LaunchAgent when ClaudeFocus.app receives a claude-focus:// URL

# Secure log file in user-owned directory (not world-readable /tmp)
LOG_DIR="$HOME/.claude/logs"
LOG_FILE="$LOG_DIR/focus-debug.log"
mkdir -p "$LOG_DIR" && chmod 700 "$LOG_DIR"

URL="$1"
echo "$(date): Helper received: $URL" >> "$LOG_FILE"

# Parse URL and query string
URL_PATH="${URL#claude-focus://}"
QUERY_STRING=""
if [[ "$URL_PATH" == *"?"* ]]; then
    QUERY_STRING="${URL_PATH#*\?}"
    URL_PATH="${URL_PATH%%\?*}"
fi
IFS='/' read -r TYPE ARG1 ARG2 <<< "$URL_PATH"

# Parse action from query string
ACTION=""
if [[ -n "$QUERY_STRING" ]]; then
    # Extract action=value from query string
    for param in ${QUERY_STRING//&/ }; do
        key="${param%%=*}"
        value="${param#*=}"
        if [[ "$key" == "action" ]]; then
            ACTION="$value"
            break
        fi
    done
fi

# URL decode arguments (handles common percent-encoded characters)
url_decode() {
    local encoded="$1"
    # Use printf to decode percent-encoded sequences
    printf '%b' "${encoded//%/\\x}"
}

# Sanitize string for safe use in AppleScript
# Escapes backslashes and double quotes to prevent injection
sanitize_applescript() {
    local input="$1"
    # Allow empty strings (some URL types have optional args)
    if [[ -z "$input" ]]; then
        echo ""
        return 0
    fi
    # Reject any input containing characters that shouldn't be in TTY paths or session IDs
    # Valid chars: alphanumeric, dash, underscore, dot, slash, colon, equals (for tmux targets)
    if [[ ! "$input" =~ ^[a-zA-Z0-9_./:=-]+$ ]]; then
        echo "INVALID_INPUT"
        return 1
    fi
    # Escape backslashes first, then double quotes
    echo "$input" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

ARG1=$(url_decode "$ARG1")
ARG2=$(url_decode "$ARG2")

# Validate and sanitize inputs
ARG1=$(sanitize_applescript "$ARG1")
ARG2=$(sanitize_applescript "$ARG2")

# Exit if inputs are invalid
if [[ "$ARG1" == "INVALID_INPUT" ]] || [[ "$ARG2" == "INVALID_INPUT" ]]; then
    echo "$(date): Rejected invalid input - potential injection attempt" >> $LOG_FILE
    exit 1
fi

echo "$(date): Type=$TYPE ARG1=$ARG1 ARG2=$ARG2 ACTION=$ACTION" >> $LOG_FILE

# Map action parameter to input text (allowlist for security)
get_action_input() {
    local action="$1"
    case "$action" in
        1)        echo "1" ;;
        2)        echo "2" ;;
        continue) echo "Continue" ;;
        push)     echo "/push" ;;
        *)        echo "" ;;  # Unknown actions produce no input
    esac
}

# Send input to tmux pane
send_tmux_input() {
    local tmux_target="$1"
    local input="$2"
    if [[ -n "$input" && -n "$tmux_target" ]]; then
        echo "$(date): Sending input to tmux target $tmux_target: $input" >> $LOG_FILE
        $TMUX_BIN -S "$TMUX_SOCKET" send-keys -t "$tmux_target" "$input" Enter 2>/dev/null
    fi
}

# Send input to iTerm2 session (by TTY or ID)
send_iterm_input() {
    local property="$1"  # "tty" or "id"
    local target="$2"
    local input="$3"
    if [[ -n "$input" ]]; then
        echo "$(date): Sending input to iTerm2 ($property=$target): $input" >> $LOG_FILE
        osascript << APPLESCRIPT 2>/dev/null
tell application "iTerm2"
    repeat with w in windows
        repeat with t in tabs of w
            repeat with s in sessions of t
                if ($property of s) is "$target" then
                    tell s to write text "$input"
                    return
                end if
            end repeat
        end repeat
    end repeat
end tell
APPLESCRIPT
    fi
}

# Send input to Terminal.app (by TTY)
send_terminal_input() {
    local target_tty="$1"
    local input="$2"
    if [[ -n "$input" ]]; then
        echo "$(date): Sending input to Terminal.app (tty=$target_tty): $input" >> $LOG_FILE
        osascript << APPLESCRIPT 2>/dev/null
tell application "Terminal"
    repeat with w in windows
        repeat with t in tabs of w
            if (tty of t) is "$target_tty" then
                -- Use keystroke to send text to the terminal
                tell application "System Events"
                    tell process "Terminal"
                        keystroke "$input"
                        keystroke return
                    end tell
                end tell
                return
            end if
        end repeat
    end repeat
end tell
APPLESCRIPT
    fi
}

# Tmux utilities
TMUX_BIN=$(which tmux 2>/dev/null || echo /opt/homebrew/bin/tmux)
TMUX_SOCKET="/private/tmp/tmux-$(id -u)/default"

# Switch iTerm2 to the tab matching a session property
# Usage: switch_iterm_session <property> <value>
# property: "tty" or "id"
switch_iterm_session() {
    local property="$1"
    local target="$2"
    echo "$(date): Looking for iTerm2 session with $property=$target" >> $LOG_FILE

    local result
    result=$(osascript << APPLESCRIPT 2>&1
tell application "iTerm2"
    repeat with w in windows
        set tabIndex to 0
        repeat with t in tabs of w
            set tabIndex to tabIndex + 1
            repeat with s in sessions of t
                if ($property of s) is "$target" then
                    set index of w to 1
                    tell w to select tab tabIndex
                    activate
                    tell application "System Events"
                        set frontmost of process "iTerm2" to true
                    end tell
                    return "Switched to tab " & tabIndex & " for $property " & ($property of s)
                end if
            end repeat
        end repeat
    end repeat
    return "$property $target not found"
end tell
APPLESCRIPT
)
    echo "$(date): iTerm2 result: $result" >> $LOG_FILE
}

# Switch Terminal.app to the tab with the given TTY
switch_terminal_tab() {
    local target_tty="$1"
    echo "$(date): Looking for Terminal.app tab with tty=$target_tty" >> $LOG_FILE

    local result
    result=$(osascript << APPLESCRIPT 2>&1
tell application "Terminal"
    repeat with w in windows
        set tabIndex to 0
        repeat with t in tabs of w
            set tabIndex to tabIndex + 1
            if (tty of t) is "$target_tty" then
                set frontmost of w to true
                set selected tab of w to t
                activate
                tell application "System Events"
                    set frontmost of process "Terminal" to true
                end tell
                return "Switched to tab " & tabIndex & " for tty " & (tty of t)
            end if
        end repeat
    end repeat
    return "tty $target_tty not found"
end tell
APPLESCRIPT
)
    echo "$(date): Terminal.app result: $result" >> $LOG_FILE
}

# Switch tmux to the specified session:window and return the client TTY
switch_tmux_window() {
    local tmux_target="$1"
    local session="${tmux_target%%:*}"
    local window="${tmux_target#*:}"
    window="${window%%.*}"

    echo "$(date): Switching tmux to session=$session window=$window" >> $LOG_FILE

    local client_tty
    client_tty=$($TMUX_BIN -S "$TMUX_SOCKET" list-clients -t "$session" -F '#{client_tty}' 2>/dev/null | head -1)

    if [[ -n "$client_tty" ]]; then
        $TMUX_BIN -S "$TMUX_SOCKET" switch-client -c "$client_tty" -t "$session:$window" 2>/dev/null
        echo "$(date): Switched tmux client $client_tty to $session:$window" >> $LOG_FILE
    else
        $TMUX_BIN -S "$TMUX_SOCKET" select-window -t "$session:$window" 2>/dev/null
        echo "$(date): Selected tmux window $session:$window directly" >> $LOG_FILE
    fi

    echo "$client_tty"
}

# Get action input (if any)
ACTION_INPUT=$(get_action_input "$ACTION")

# Main logic
case "$TYPE" in
    iterm-tmux)
        # iTerm2 running tmux - switch iTerm tab then tmux window
        switch_iterm_session "tty" "$ARG1"
        switch_tmux_window "$ARG2"
        # Send input via tmux (more reliable than AppleScript)
        send_tmux_input "$ARG2" "$ACTION_INPUT"
        ;;
    iterm2)
        # Pure iTerm2 - ARG1 is the session UUID
        switch_iterm_session "id" "$ARG1"
        send_iterm_input "id" "$ARG1" "$ACTION_INPUT"
        ;;
    terminal-tmux)
        # Terminal.app running tmux - switch Terminal tab then tmux window
        switch_terminal_tab "$ARG1"
        switch_tmux_window "$ARG2"
        # Send input via tmux (more reliable than AppleScript)
        send_tmux_input "$ARG2" "$ACTION_INPUT"
        ;;
    terminal)
        # Pure Terminal.app - switch to the tab by TTY
        switch_terminal_tab "$ARG1"
        send_terminal_input "$ARG1" "$ACTION_INPUT"
        ;;
    tmux)
        # Pure tmux - switch tmux window, then try to find the terminal tab
        client_tty=$(switch_tmux_window "$ARG1")
        if [[ -n "$client_tty" ]]; then
            # Try iTerm first, then Terminal
            switch_iterm_session "tty" "$client_tty" 2>/dev/null || \
            switch_terminal_tab "$client_tty" 2>/dev/null
        else
            osascript -e 'tell application "iTerm2" to activate' 2>/dev/null || \
            osascript -e 'tell application "Terminal" to activate' 2>/dev/null
        fi
        # Send input via tmux
        send_tmux_input "$ARG1" "$ACTION_INPUT"
        ;;
esac
