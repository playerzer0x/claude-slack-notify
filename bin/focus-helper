#!/bin/bash
# Focus helper - switches to the correct iTerm2/Terminal.app tab and/or tmux window
# Called by LaunchAgent when ClaudeFocus.app receives a claude-focus:// URL

# Secure log file in user-owned directory (not world-readable /tmp)
LOG_DIR="$HOME/.claude/logs"
LOG_FILE="$LOG_DIR/focus-debug.log"
mkdir -p "$LOG_DIR" && chmod 700 "$LOG_DIR"

URL="$1"
echo "$(date): Helper received: $URL" >> "$LOG_FILE"

# Parse URL and query string
URL_PATH="${URL#claude-focus://}"
QUERY_STRING=""
if [[ "$URL_PATH" == *"?"* ]]; then
    QUERY_STRING="${URL_PATH#*\?}"
    URL_PATH="${URL_PATH%%\?*}"
fi
# Support up to 5 URL segments for ssh-linked: type/link_id/host/user/port/tmux_target
IFS='/' read -r TYPE ARG1 ARG2 ARG3 ARG4 ARG5 <<< "$URL_PATH"

# Parse action from query string
ACTION=""
if [[ -n "$QUERY_STRING" ]]; then
    # Extract action=value from query string
    for param in ${QUERY_STRING//&/ }; do
        key="${param%%=*}"
        value="${param#*=}"
        if [[ "$key" == "action" ]]; then
            ACTION="$value"
            break
        fi
    done
fi

# URL decode arguments (handles common percent-encoded characters)
url_decode() {
    local encoded="$1"
    # Use printf to decode percent-encoded sequences
    printf '%b' "${encoded//%/\\x}"
}

# Sanitize string for safe use in AppleScript
# Escapes backslashes and double quotes to prevent injection
sanitize_applescript() {
    local input="$1"
    # Allow empty strings (some URL types have optional args)
    if [[ -z "$input" ]]; then
        echo ""
        return 0
    fi
    # Reject any input containing characters that shouldn't be in TTY paths or session IDs
    # Valid chars: alphanumeric, dash, underscore, dot, slash, colon, equals (for tmux targets)
    if [[ ! "$input" =~ ^[a-zA-Z0-9_./:=-]+$ ]]; then
        echo "INVALID_INPUT"
        return 1
    fi
    # Escape backslashes first, then double quotes
    echo "$input" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

ARG1=$(url_decode "$ARG1")
ARG2=$(url_decode "$ARG2")
ARG3=$(url_decode "$ARG3")
ARG4=$(url_decode "$ARG4")
ARG5=$(url_decode "$ARG5")

# Validate and sanitize inputs
ARG1=$(sanitize_applescript "$ARG1")
ARG2=$(sanitize_applescript "$ARG2")
ARG3=$(sanitize_applescript "$ARG3")
ARG4=$(sanitize_applescript "$ARG4")
ARG5=$(sanitize_applescript "$ARG5")

# Exit if inputs are invalid
if [[ "$ARG1" == "INVALID_INPUT" ]] || [[ "$ARG2" == "INVALID_INPUT" ]] || \
   [[ "$ARG3" == "INVALID_INPUT" ]] || [[ "$ARG4" == "INVALID_INPUT" ]] || \
   [[ "$ARG5" == "INVALID_INPUT" ]]; then
    echo "$(date): Rejected invalid input - potential injection attempt" >> $LOG_FILE
    exit 1
fi

echo "$(date): Type=$TYPE ARG1=$ARG1 ARG2=$ARG2 ARG3=$ARG3 ARG4=$ARG4 ARG5=$ARG5 ACTION=$ACTION" >> $LOG_FILE

# Map action parameter to input text (allowlist for security)
get_action_input() {
    local action="$1"
    case "$action" in
        1)        echo "1" ;;
        2)        echo "2" ;;
        continue) echo "Continue" ;;
        push)     echo "/push" ;;
        *)        echo "" ;;  # Unknown actions produce no input
    esac
}

# Send input to tmux pane using gastown's robust pattern:
# 1. Send text with -l (literal) flag
# 2. Wait for paste to complete
# 3. Send Escape (exits vim mode if active, harmless otherwise)
# 4. Send Enter as separate command
send_tmux_input() {
    local tmux_target="$1"
    local input="$2"
    if [[ -n "$input" && -n "$tmux_target" ]]; then
        echo "$(date): Sending input to tmux target $tmux_target: $input" >> $LOG_FILE

        # Step 1: Send text in literal mode (handles special characters)
        local result
        result=$($TMUX_BIN -S "$TMUX_SOCKET" send-keys -t "$tmux_target" -l "$input" 2>&1)
        echo "$(date): send-keys -l result: $? - $result" >> $LOG_FILE

        # Step 2: Wait for paste to complete (tested requirement from gastown)
        sleep 0.2

        # Step 3: Send Escape to exit vim INSERT mode if enabled (harmless in normal mode)
        $TMUX_BIN -S "$TMUX_SOCKET" send-keys -t "$tmux_target" Escape 2>/dev/null
        sleep 0.1

        # Step 4: Send Enter as separate command (more reliable than appending)
        result=$($TMUX_BIN -S "$TMUX_SOCKET" send-keys -t "$tmux_target" Enter 2>&1)
        echo "$(date): send-keys Enter result: $? - $result" >> $LOG_FILE
    fi
}

# Send input to iTerm2 session (by TTY or ID)
# Uses "write text ... newline NO" then System Events Return key
# to avoid the newline-vs-carriage-return issue
send_iterm_input() {
    local property="$1"  # "tty" or "id"
    local target="$2"
    local input="$3"
    if [[ -n "$input" ]]; then
        echo "$(date): Sending input to iTerm2 ($property=$target): $input" >> $LOG_FILE
        osascript << APPLESCRIPT 2>/dev/null
tell application "iTerm2"
    repeat with w in windows
        repeat with t in tabs of w
            repeat with s in sessions of t
                if ($property of s) is "$target" then
                    -- Send text without newline
                    tell s to write text "$input" newline NO
                    -- Brief delay for text to be processed
                    delay 0.1
                    -- Send Return key via System Events
                    tell application "System Events"
                        key code 36 -- Return key
                    end tell
                    return
                end if
            end repeat
        end repeat
    end repeat
end tell
APPLESCRIPT
    fi
}

# Send input to Terminal.app (by TTY)
# Uses System Events keystroke with delay before return
send_terminal_input() {
    local target_tty="$1"
    local input="$2"
    if [[ -n "$input" ]]; then
        echo "$(date): Sending input to Terminal.app (tty=$target_tty): $input" >> $LOG_FILE
        osascript << APPLESCRIPT 2>/dev/null
tell application "Terminal"
    repeat with w in windows
        repeat with t in tabs of w
            if (tty of t) is "$target_tty" then
                tell application "System Events"
                    tell process "Terminal"
                        -- Send text
                        keystroke "$input"
                        -- Brief delay for text to be processed
                        delay 0.1
                        -- Send Return key
                        key code 36
                    end tell
                end tell
                return
            end if
        end repeat
    end repeat
end tell
APPLESCRIPT
    fi
}

# Tmux utilities
TMUX_BIN=$(which tmux 2>/dev/null || echo /opt/homebrew/bin/tmux)
TMUX_SOCKET="/private/tmp/tmux-$(id -u)/default"

# Links directory (for ssh-linked mode)
LINKS_DIR="$HOME/.claude/links"

# Switch remote tmux to the correct window/pane via SSH
switch_remote_tmux() {
    local ssh_host="$1"
    local ssh_user="$2"
    local ssh_port="$3"
    local tmux_target="$4"  # format: session:window.pane

    if [[ -n "$tmux_target" ]]; then
        echo "$(date): Switching remote tmux to $tmux_target via SSH" >> $LOG_FILE

        local ssh_cmd="ssh -o BatchMode=yes -o ConnectTimeout=5 -p $ssh_port $ssh_user@$ssh_host"

        # Extract session:window.pane components
        local session="${tmux_target%%:*}"
        local window_pane="${tmux_target#*:}"
        local window="${window_pane%%.*}"

        # Switch to the window and select the pane
        local result
        result=$($ssh_cmd "tmux select-window -t '$session:$window' 2>/dev/null; tmux select-pane -t '$tmux_target' 2>/dev/null" 2>&1)
        echo "$(date): Remote tmux switch result: $? - $result" >> $LOG_FILE
    fi
}

# Send input to remote tmux session via SSH
# Uses the same robust pattern as local tmux
send_ssh_tmux_input() {
    local ssh_host="$1"
    local ssh_user="$2"
    local ssh_port="$3"
    local tmux_target="$4"
    local input="$5"

    if [[ -n "$input" && -n "$tmux_target" ]]; then
        echo "$(date): Sending input via SSH to $ssh_user@$ssh_host:$ssh_port tmux $tmux_target: $input" >> $LOG_FILE

        # SSH command to send input to remote tmux
        # Uses BatchMode to fail fast if no key auth available
        # Uses -t to allocate PTY for tmux commands
        local ssh_cmd="ssh -o BatchMode=yes -o ConnectTimeout=5 -p $ssh_port $ssh_user@$ssh_host"

        # Escape input for shell quoting (single quotes with escaped single quotes)
        local escaped_input="${input//\'/\'\\\'\'}"

        # Step 1: Send text in literal mode
        local result
        result=$($ssh_cmd "tmux send-keys -t '$tmux_target' -l '$escaped_input'" 2>&1)
        local exit_code=$?
        echo "$(date): SSH send-keys -l result: $exit_code - $result" >> $LOG_FILE

        if [[ $exit_code -ne 0 ]]; then
            echo "$(date): SSH command failed - check SSH key authentication" >> $LOG_FILE
            return 1
        fi

        # Step 2: Wait for paste to complete
        sleep 0.2

        # Step 3: Send Escape to exit vim INSERT mode if enabled
        $ssh_cmd "tmux send-keys -t '$tmux_target' Escape" 2>/dev/null
        sleep 0.1

        # Step 4: Send Enter
        result=$($ssh_cmd "tmux send-keys -t '$tmux_target' Enter" 2>&1)
        echo "$(date): SSH send-keys Enter result: $? - $result" >> $LOG_FILE
    fi
}

# Switch iTerm2 to the tab matching a session property
# Usage: switch_iterm_session <property> <value>
# property: "tty" or "id"
#
# Uses window ID (stable integer) for verification instead of window name.
# Key insight: After `select w`, the target becomes `first window` in System Events.
# Includes retry loop with increasing delays for reliability.
switch_iterm_session() {
    local property="$1"
    local target="$2"
    echo "$(date): Looking for iTerm2 session with $property=$target" >> $LOG_FILE

    local result
    result=$(osascript << APPLESCRIPT 2>&1
tell application "iTerm2"
    -- Phase 1: Find target session and get window ID for verification
    set targetWindowId to 0
    set targetTabIndex to 0
    set targetWindow to missing value

    repeat with w in windows
        set tabIndex to 0
        repeat with t in tabs of w
            set tabIndex to tabIndex + 1
            repeat with s in sessions of t
                if ($property of s) is "$target" then
                    set targetWindowId to id of w
                    set targetTabIndex to tabIndex
                    set targetWindow to w
                    exit repeat
                end if
            end repeat
            if targetWindowId > 0 then exit repeat
        end repeat
        if targetWindowId > 0 then exit repeat
    end repeat

    if targetWindowId is 0 then
        return "$property $target not found"
    end if

    -- Phase 2: Focus sequence with retry loop (up to 3 attempts)
    set maxAttempts to 3
    set attemptNum to 0
    set focusSuccess to false

    repeat while attemptNum < maxAttempts and not focusSuccess
        set attemptNum to attemptNum + 1

        -- Select the tab within the window
        tell targetWindow to select tab targetTabIndex

        -- Make this the key window in iTerm2
        select targetWindow

        -- Delay 150ms for select to take effect
        delay 0.15

        -- Activate iTerm2
        activate

        -- Delay 100ms for activate
        delay 0.1

        -- Use System Events to raise the window
        -- After select, target window becomes first window in iTerm2
        tell application "System Events"
            tell process "iTerm2"
                set frontmost to true
                try
                    perform action "AXRaise" of first window
                on error errMsg
                    -- Log but continue - AXRaise can fail silently
                end try
            end tell
        end tell

        -- Delay 100ms for AXRaise
        delay 0.1

        -- Phase 3: Verify the correct window is focused by checking ID
        try
            set frontWindowId to id of first window
            if frontWindowId is equal to targetWindowId then
                set focusSuccess to true
            else
                -- Wrong window focused, wait longer before retry
                delay (0.2 * attemptNum)
            end if
        on error
            -- Could not verify, assume success on last attempt
            if attemptNum is maxAttempts then
                set focusSuccess to true
            end if
        end try
    end repeat

    if focusSuccess then
        return "SUCCESS: Focused window id " & targetWindowId & " tab " & targetTabIndex & " for $property $target"
    else
        return "FOCUS_FAILED: Requested window id " & targetWindowId & " but could not verify focus after " & maxAttempts & " attempts"
    end if
end tell
APPLESCRIPT
)
    echo "$(date): iTerm2 result: $result" >> $LOG_FILE
}

# Switch Terminal.app to the tab with the given TTY
switch_terminal_tab() {
    local target_tty="$1"
    echo "$(date): Looking for Terminal.app tab with tty=$target_tty" >> $LOG_FILE

    local result
    result=$(osascript << APPLESCRIPT 2>&1
tell application "Terminal"
    repeat with w in windows
        set tabIndex to 0
        repeat with t in tabs of w
            set tabIndex to tabIndex + 1
            if (tty of t) is "$target_tty" then
                set frontmost of w to true
                set selected tab of w to t
                activate
                tell application "System Events"
                    set frontmost of process "Terminal" to true
                end tell
                return "Switched to tab " & tabIndex & " for tty " & (tty of t)
            end if
        end repeat
    end repeat
    return "tty $target_tty not found"
end tell
APPLESCRIPT
)
    echo "$(date): Terminal.app result: $result" >> $LOG_FILE
}

# Switch tmux to the specified session:window and return the client TTY
switch_tmux_window() {
    local tmux_target="$1"
    local session="${tmux_target%%:*}"
    local window="${tmux_target#*:}"
    window="${window%%.*}"

    echo "$(date): Switching tmux to session=$session window=$window" >> $LOG_FILE

    local client_tty
    client_tty=$($TMUX_BIN -S "$TMUX_SOCKET" list-clients -t "$session" -F '#{client_tty}' 2>/dev/null | head -1)

    if [[ -n "$client_tty" ]]; then
        $TMUX_BIN -S "$TMUX_SOCKET" switch-client -c "$client_tty" -t "$session:$window" 2>/dev/null
        echo "$(date): Switched tmux client $client_tty to $session:$window" >> $LOG_FILE
    else
        $TMUX_BIN -S "$TMUX_SOCKET" select-window -t "$session:$window" 2>/dev/null
        echo "$(date): Selected tmux window $session:$window directly" >> $LOG_FILE
    fi

    echo "$client_tty"
}

# Get action input (if any)
ACTION_INPUT=$(get_action_input "$ACTION")

# Main logic
case "$TYPE" in
    iterm-tmux)
        # iTerm2 running tmux - send input first (works in background), then focus
        send_tmux_input "$ARG2" "$ACTION_INPUT"
        switch_iterm_session "tty" "$ARG1"
        switch_tmux_window "$ARG2"
        ;;
    iterm2)
        # Pure iTerm2 - ARG1 is the session UUID
        switch_iterm_session "id" "$ARG1"
        send_iterm_input "id" "$ARG1" "$ACTION_INPUT"
        ;;
    terminal-tmux)
        # Terminal.app running tmux - send input first, then focus
        send_tmux_input "$ARG2" "$ACTION_INPUT"
        switch_terminal_tab "$ARG1"
        switch_tmux_window "$ARG2"
        ;;
    terminal)
        # Pure Terminal.app - switch to the tab by TTY
        switch_terminal_tab "$ARG1"
        send_terminal_input "$ARG1" "$ACTION_INPUT"
        ;;
    tmux)
        # Pure tmux - send input first, then switch and focus
        send_tmux_input "$ARG1" "$ACTION_INPUT"
        client_tty=$(switch_tmux_window "$ARG1")
        if [[ -n "$client_tty" ]]; then
            # Try iTerm first, then Terminal
            switch_iterm_session "tty" "$client_tty" 2>/dev/null || \
            switch_terminal_tab "$client_tty" 2>/dev/null
        else
            osascript -e 'tell application "iTerm2" to activate' 2>/dev/null || \
            osascript -e 'tell application "Terminal" to activate' 2>/dev/null
        fi
        ;;
    ssh-linked)
        # SSH with linked local terminal
        # ARG1=link_id, ARG2=host, ARG3=user, ARG4=port, ARG5=tmux_target
        link_id="$ARG1"
        ssh_host="$ARG2"
        ssh_user="$ARG3"
        ssh_port="$ARG4"
        remote_tmux_target="$ARG5"

        echo "$(date): SSH-linked: link=$link_id host=$ssh_host user=$ssh_user port=$ssh_port tmux=$remote_tmux_target" >> "$LOG_FILE"

        # Step 1: Focus LOCAL terminal using link info
        link_file="$LINKS_DIR/${link_id}.json"
        if [[ -f "$link_file" ]]; then
            local_type=$(grep -o '"term_type": *"[^"]*"' "$link_file" | cut -d'"' -f4)
            local_target=$(grep -o '"term_target": *"[^"]*"' "$link_file" | cut -d'"' -f4)

            echo "$(date): Link found: local_type=$local_type local_target=$local_target" >> "$LOG_FILE"

            case "$local_type" in
                iterm2)
                    switch_iterm_session "id" "$local_target"
                    ;;
                iterm-tmux)
                    local_tty="${local_target%%|*}"
                    local_tmux="${local_target#*|}"
                    switch_iterm_session "tty" "$local_tty"
                    switch_tmux_window "$local_tmux"
                    ;;
                terminal-tmux)
                    local_tty="${local_target%%|*}"
                    local_tmux="${local_target#*|}"
                    switch_terminal_tab "$local_tty"
                    switch_tmux_window "$local_tmux"
                    ;;
                terminal)
                    switch_terminal_tab "$local_target"
                    ;;
                tmux)
                    client_tty=$(switch_tmux_window "$local_target")
                    if [[ -n "$client_tty" ]]; then
                        switch_iterm_session "tty" "$client_tty" 2>/dev/null || \
                        switch_terminal_tab "$client_tty" 2>/dev/null
                    fi
                    ;;
                *)
                    echo "$(date): Unknown local term type: $local_type" >> "$LOG_FILE"
                    ;;
            esac
        else
            echo "$(date): Link file not found: $link_file" >> "$LOG_FILE"
        fi

        # Step 2: Switch remote tmux to the correct window/pane
        if [[ -n "$remote_tmux_target" ]]; then
            switch_remote_tmux "$ssh_host" "$ssh_user" "$ssh_port" "$remote_tmux_target"
        fi

        # Step 3: Send input to REMOTE via SSH (if action specified)
        if [[ -n "$ACTION_INPUT" && -n "$remote_tmux_target" ]]; then
            send_ssh_tmux_input "$ssh_host" "$ssh_user" "$ssh_port" "$remote_tmux_target" "$ACTION_INPUT"
        fi
        ;;
    ssh-tmux)
        # Direct SSH + tmux (no local terminal link)
        # ARG1=host, ARG2=user, ARG3=port, ARG4=tmux_target
        ssh_host="$ARG1"
        ssh_user="$ARG2"
        ssh_port="$ARG3"
        remote_tmux_target="$ARG4"

        echo "$(date): SSH-tmux (direct): host=$ssh_host user=$ssh_user port=$ssh_port tmux=$remote_tmux_target" >> "$LOG_FILE"

        # Switch remote tmux to correct window/pane
        if [[ -n "$remote_tmux_target" ]]; then
            switch_remote_tmux "$ssh_host" "$ssh_user" "$ssh_port" "$remote_tmux_target"
        fi

        # Send input to remote
        if [[ -n "$ACTION_INPUT" && -n "$remote_tmux_target" ]]; then
            send_ssh_tmux_input "$ssh_host" "$ssh_user" "$ssh_port" "$remote_tmux_target" "$ACTION_INPUT"
        fi
        ;;
    jupyter-tmux)
        # JupyterLab terminal in Chrome + remote tmux
        # ARG1=link_id, ARG2=host, ARG3=user, ARG4=port, ARG5=tmux_target
        link_id="$ARG1"
        ssh_host="$ARG2"
        ssh_user="$ARG3"
        ssh_port="$ARG4"
        remote_tmux_target="$ARG5"

        echo "$(date): Jupyter-tmux: link=$link_id host=$ssh_host user=$ssh_user port=$ssh_port tmux=$remote_tmux_target" >> "$LOG_FILE"

        # Step 1: Focus Chrome tab with JupyterLab URL from link file
        link_file="$LINKS_DIR/${link_id}.json"
        if [[ -f "$link_file" ]]; then
            jupyter_url=$(grep -o '"jupyter_url": *"[^"]*"' "$link_file" | cut -d'"' -f4)

            if [[ -n "$jupyter_url" ]]; then
                echo "$(date): Focusing Chrome tab with URL containing: $jupyter_url" >> "$LOG_FILE"

                # Focus Chrome and find tab matching the JupyterLab URL
                osascript << APPLESCRIPT 2>/dev/null
tell application "Google Chrome"
    set found to false
    repeat with w in windows
        set tabIndex to 0
        repeat with t in tabs of w
            set tabIndex to tabIndex + 1
            if URL of t contains "$jupyter_url" or "$jupyter_url" contains URL of t then
                set index of w to 1
                set active tab index of w to tabIndex
                activate
                tell application "System Events"
                    set frontmost of process "Google Chrome" to true
                end tell
                set found to true
                exit repeat
            end if
        end repeat
        if found then exit repeat
    end repeat
    if not found then
        activate
    end if
end tell
APPLESCRIPT
            fi
        else
            echo "$(date): Link file not found: $link_file" >> "$LOG_FILE"
            # Just activate Chrome as fallback
            osascript -e 'tell application "Google Chrome" to activate' 2>/dev/null
        fi

        # Step 2: Switch remote tmux to correct window/pane
        if [[ -n "$remote_tmux_target" ]]; then
            switch_remote_tmux "$ssh_host" "$ssh_user" "$ssh_port" "$remote_tmux_target"
        fi

        # Step 3: Send input to remote via SSH
        if [[ -n "$ACTION_INPUT" && -n "$remote_tmux_target" ]]; then
            send_ssh_tmux_input "$ssh_host" "$ssh_user" "$ssh_port" "$remote_tmux_target" "$ACTION_INPUT"
        fi
        ;;
esac
