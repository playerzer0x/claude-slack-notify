#!/bin/bash
# Focus helper - switches to the correct iTerm2/Terminal.app tab and/or tmux window
# Called by LaunchAgent when ClaudeFocus.app receives a claude-focus:// URL

# Secure log file in user-owned directory (not world-readable /tmp)
LOG_DIR="$HOME/.claude/logs"
LOG_FILE="$LOG_DIR/focus-debug.log"
mkdir -p "$LOG_DIR" && chmod 700 "$LOG_DIR"

URL="$1"
echo "$(date): Helper received: $URL" >> "$LOG_FILE"

# Parse URL and query string
URL_PATH="${URL#claude-focus://}"
QUERY_STRING=""
if [[ "$URL_PATH" == *"?"* ]]; then
    QUERY_STRING="${URL_PATH#*\?}"
    URL_PATH="${URL_PATH%%\?*}"
fi
# Support up to 5 URL segments for ssh-linked: type/link_id/host/user/port/tmux_target
IFS='/' read -r TYPE ARG1 ARG2 ARG3 ARG4 ARG5 <<< "$URL_PATH"

# Parse query string parameters
ACTION=""
TEXT_INPUT=""
PARAM_URL=""
PARAM_HOST=""
PARAM_NAME=""
if [[ -n "$QUERY_STRING" ]]; then
    # Extract parameters from query string
    for param in ${QUERY_STRING//&/ }; do
        key="${param%%=*}"
        value="${param#*=}"
        if [[ "$key" == "action" ]]; then
            ACTION="$value"
        elif [[ "$key" == "text" ]]; then
            # URL decode the text
            TEXT_INPUT=$(printf '%b' "${value//%/\\x}")
        elif [[ "$key" == "url" ]]; then
            PARAM_URL=$(printf '%b' "${value//%/\\x}")
        elif [[ "$key" == "host" ]]; then
            PARAM_HOST=$(printf '%b' "${value//%/\\x}")
        elif [[ "$key" == "name" ]]; then
            PARAM_NAME=$(printf '%b' "${value//%/\\x}")
        fi
    done
fi

# URL decode arguments (handles common percent-encoded characters)
url_decode() {
    local encoded="$1"
    # Use printf to decode percent-encoded sequences
    printf '%b' "${encoded//%/\\x}"
}

# Sanitize string for safe use in AppleScript
# Escapes backslashes and double quotes to prevent injection
sanitize_applescript() {
    local input="$1"
    # Allow empty strings (some URL types have optional args)
    if [[ -z "$input" ]]; then
        echo ""
        return 0
    fi
    # Reject any input containing characters that shouldn't be in TTY paths or session IDs
    # Valid chars: alphanumeric, dash, underscore, dot, slash, colon, equals (for tmux targets)
    if [[ ! "$input" =~ ^[a-zA-Z0-9_./:=-]+$ ]]; then
        echo "INVALID_INPUT"
        return 1
    fi
    # Escape backslashes first, then double quotes
    echo "$input" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

ARG1=$(url_decode "$ARG1")
ARG2=$(url_decode "$ARG2")
ARG3=$(url_decode "$ARG3")
ARG4=$(url_decode "$ARG4")
ARG5=$(url_decode "$ARG5")

# Validate and sanitize inputs
ARG1=$(sanitize_applescript "$ARG1")
ARG2=$(sanitize_applescript "$ARG2")
ARG3=$(sanitize_applescript "$ARG3")
ARG4=$(sanitize_applescript "$ARG4")
ARG5=$(sanitize_applescript "$ARG5")

# Exit if inputs are invalid
if [[ "$ARG1" == "INVALID_INPUT" ]] || [[ "$ARG2" == "INVALID_INPUT" ]] || \
   [[ "$ARG3" == "INVALID_INPUT" ]] || [[ "$ARG4" == "INVALID_INPUT" ]] || \
   [[ "$ARG5" == "INVALID_INPUT" ]]; then
    echo "$(date): Rejected invalid input - potential injection attempt" >> $LOG_FILE
    exit 1
fi

echo "$(date): Type=$TYPE ARG1=$ARG1 ARG2=$ARG2 ARG3=$ARG3 ARG4=$ARG4 ARG5=$ARG5 ACTION=$ACTION" >> $LOG_FILE

# Map action parameter to input text (allowlist for security)
get_action_input() {
    local action="$1"
    case "$action" in
        1)        echo "1" ;;
        2)        echo "2" ;;
        continue) echo "Continue" ;;
        push)     echo "/push" ;;
        *)        echo "" ;;  # Unknown actions produce no input
    esac
}

# Send input to tmux pane using gastown's robust pattern:
# 1. Send text with -l (literal) flag
# 2. Wait for paste to complete
# 3. Send Escape (exits vim mode if active, harmless otherwise)
# 4. Send Enter as separate command
send_tmux_input() {
    local tmux_target="$1"
    local input="$2"
    if [[ -n "$input" && -n "$tmux_target" ]]; then
        echo "$(date): Sending input to tmux target $tmux_target: $input" >> $LOG_FILE

        # Step 1: Send text in literal mode (handles special characters)
        local result
        result=$($TMUX_BIN -S "$TMUX_SOCKET" send-keys -t "$tmux_target" -l "$input" 2>&1)
        echo "$(date): send-keys -l result: $? - $result" >> $LOG_FILE

        # Step 2: Wait for paste to complete (tested requirement from gastown)
        sleep 0.2

        # Step 3: Send Enter as separate command (more reliable than appending)
        # NOTE: Removed Escape key - it was interrupting Claude Code.
        # Vim mode users should manually exit insert mode before clicking buttons.
        result=$($TMUX_BIN -S "$TMUX_SOCKET" send-keys -t "$tmux_target" Enter 2>&1)
        echo "$(date): send-keys Enter result: $? - $result" >> $LOG_FILE
    fi
}

# Send input to iTerm2 session (by TTY or ID)
# Switches to the specific session first, then uses System Events for Return
# (Claude Code/iTerm has quirks with newline characters, System Events is more reliable)
send_iterm_input() {
    local property="$1"  # "tty" or "id"
    local target="$2"
    local input="$3"
    if [[ -n "$input" ]]; then
        echo "$(date): Sending input to iTerm2 ($property=$target): $input" >> $LOG_FILE
        osascript << APPLESCRIPT 2>/dev/null
tell application "iTerm2"
    repeat with w in windows
        repeat with t in tabs of w
            repeat with s in sessions of t
                if ($property of s) is "$target" then
                    -- First: switch to this specific session
                    select s
                    set index of w to 1
                    activate
                    -- Wait for focus to settle
                    delay 0.15
                    -- Send text without newline
                    tell s to write text "$input" newline NO
                    -- Wait for text to appear
                    delay 0.1
                    -- Use System Events for Return (now that correct session is frontmost)
                    tell application "System Events"
                        key code 36
                    end tell
                    return
                end if
            end repeat
        end repeat
    end repeat
end tell
APPLESCRIPT
    fi
}

# Send input to Terminal.app (by TTY)
# Uses System Events keystroke with delay before return
# Must select the correct tab first before sending keystrokes
send_terminal_input() {
    local target_tty="$1"
    local input="$2"
    if [[ -n "$input" ]]; then
        echo "$(date): Sending input to Terminal.app (tty=$target_tty): $input" >> $LOG_FILE

        # Special case: "frontmost" sends to the active Terminal window
        if [[ "$target_tty" == "frontmost" ]]; then
            osascript << APPLESCRIPT 2>/dev/null
tell application "Terminal"
    activate
    delay 0.1
    tell application "System Events"
        tell process "Terminal"
            keystroke "$input"
            delay 0.1
            key code 36
        end tell
    end tell
end tell
APPLESCRIPT
            return
        fi

        osascript << APPLESCRIPT 2>/dev/null
tell application "Terminal"
    repeat with w in windows
        repeat with t in tabs of w
            if (tty of t) is "$target_tty" then
                -- Bring window to front and select the tab
                set frontmost of w to true
                set selected of t to true
                activate
                delay 0.1
                -- Now send keystrokes to the frontmost window
                tell application "System Events"
                    tell process "Terminal"
                        keystroke "$input"
                        delay 0.1
                        key code 36
                    end tell
                end tell
                return
            end if
        end repeat
    end repeat
end tell
APPLESCRIPT
    fi
}

# Tmux utilities
TMUX_BIN=$(which tmux 2>/dev/null || echo /opt/homebrew/bin/tmux)
TMUX_SOCKET="/private/tmp/tmux-$(id -u)/default"

# Links directory (for ssh-linked mode)
LINKS_DIR="$HOME/.claude/links"

# Switch remote tmux to the correct window/pane via SSH
switch_remote_tmux() {
    local ssh_host="$1"
    local ssh_user="$2"
    local ssh_port="$3"
    local tmux_target="$4"  # format: session:window.pane

    if [[ -n "$tmux_target" ]]; then
        echo "$(date): Switching remote tmux to $tmux_target via SSH" >> $LOG_FILE

        local ssh_cmd="ssh -o BatchMode=yes -o ConnectTimeout=5 -p $ssh_port $ssh_user@$ssh_host"

        # Extract session:window.pane components
        local session="${tmux_target%%:*}"
        local window_pane="${tmux_target#*:}"
        local window="${window_pane%%.*}"

        # Switch to the window and select the pane
        local result
        result=$($ssh_cmd "tmux select-window -t '$session:$window' 2>/dev/null; tmux select-pane -t '$tmux_target' 2>/dev/null" 2>&1)
        echo "$(date): Remote tmux switch result: $? - $result" >> $LOG_FILE
    fi
}

# Send input to remote tmux session via SSH
# Uses the same robust pattern as local tmux
send_ssh_tmux_input() {
    local ssh_host="$1"
    local ssh_user="$2"
    local ssh_port="$3"
    local tmux_target="$4"
    local input="$5"

    if [[ -n "$input" && -n "$tmux_target" ]]; then
        echo "$(date): Sending input via SSH to $ssh_user@$ssh_host:$ssh_port tmux $tmux_target: $input" >> $LOG_FILE

        # SSH command to send input to remote tmux
        # Uses BatchMode to fail fast if no key auth available
        # Uses -t to allocate PTY for tmux commands
        local ssh_cmd="ssh -o BatchMode=yes -o ConnectTimeout=5 -p $ssh_port $ssh_user@$ssh_host"

        # Escape input for shell quoting (single quotes with escaped single quotes)
        local escaped_input="${input//\'/\'\\\'\'}"

        # Step 1: Send text in literal mode
        local result
        result=$($ssh_cmd "tmux send-keys -t '$tmux_target' -l '$escaped_input'" 2>&1)
        local exit_code=$?
        echo "$(date): SSH send-keys -l result: $exit_code - $result" >> $LOG_FILE

        if [[ $exit_code -ne 0 ]]; then
            echo "$(date): SSH command failed - check SSH key authentication" >> $LOG_FILE
            return 1
        fi

        # Step 2: Wait for paste to complete
        sleep 0.2

        # Step 3: Send Enter
        # NOTE: Removed Escape key - it was interrupting Claude Code.
        # Vim mode users should manually exit insert mode before clicking buttons.
        result=$($ssh_cmd "tmux send-keys -t '$tmux_target' Enter" 2>&1)
        echo "$(date): SSH send-keys Enter result: $? - $result" >> $LOG_FILE
    fi
}

# Switch iTerm2 to the tab matching a session property
# Usage: switch_iterm_session <property> <value>
# property: "tty" or "id"
#
# Handles multi-monitor setups with fullscreen windows in different Spaces.
# Uses window ID (stable integer) for verification.
# Detects fullscreen state and applies appropriate delays for Space switching.
switch_iterm_session() {
    local property="$1"
    local target="$2"
    echo "$(date): Looking for iTerm2 session with $property=$target" >> $LOG_FILE

    local result
    result=$(osascript << APPLESCRIPT 2>&1
tell application "iTerm2"
    -- Phase 1: Find target session and get window info for verification
    set targetWindowId to 0
    set targetTabIndex to 0
    set targetWindow to missing value
    set targetWindowIndex to 0

    set winIndex to 0
    repeat with w in windows
        set winIndex to winIndex + 1
        set tabIndex to 0
        repeat with t in tabs of w
            set tabIndex to tabIndex + 1
            repeat with s in sessions of t
                if ($property of s) is "$target" then
                    set targetWindowId to id of w
                    set targetTabIndex to tabIndex
                    set targetWindow to w
                    set targetWindowIndex to winIndex
                    exit repeat
                end if
            end repeat
            if targetWindowId > 0 then exit repeat
        end repeat
        if targetWindowId > 0 then exit repeat
    end repeat

    if targetWindowId is 0 then
        return "$property $target not found"
    end if

    -- Check if target window is in fullscreen (requires different handling)
    set isFullscreen to false
    try
        tell application "System Events"
            tell process "iTerm2"
                -- Find the window by matching position in window list
                set winCount to count of windows
                if targetWindowIndex â‰¤ winCount then
                    set isFullscreen to value of attribute "AXFullScreen" of window targetWindowIndex
                end if
            end tell
        end tell
    on error
        -- Can't determine fullscreen state, assume normal
        set isFullscreen to false
    end try

    -- Phase 2: Focus sequence with retry loop (up to 4 attempts for fullscreen)
    set maxAttempts to 3
    if isFullscreen then set maxAttempts to 4
    set attemptNum to 0
    set focusSuccess to false
    set baseDelay to 0.15
    if isFullscreen then set baseDelay to 0.3

    repeat while attemptNum < maxAttempts and not focusSuccess
        set attemptNum to attemptNum + 1

        -- Step 1: Select the tab within the window
        tell targetWindow to select tab targetTabIndex

        -- Step 2: Make this window front in iTerm2's window ordering
        -- This is crucial for multi-window scenarios
        set index of targetWindow to 1

        -- Step 3: Select window to give it keyboard focus
        select targetWindow

        -- Delay for iTerm2 to process (longer for fullscreen/Space switching)
        delay baseDelay

        -- Step 4: Activate iTerm2 - this triggers Space switch if needed
        activate

        -- Longer delay for Space switching animation
        if isFullscreen or attemptNum > 1 then
            delay 0.4
        else
            delay 0.15
        end if

        -- Step 5: Use System Events to ensure window is raised
        tell application "System Events"
            tell process "iTerm2"
                set frontmost to true
                delay 0.05
                try
                    -- After setting index to 1, target should be first window
                    perform action "AXRaise" of first window
                on error
                    -- AXRaise failed, try setting frontmost again
                    set frontmost to true
                end try
            end tell
        end tell

        -- Delay for AXRaise
        delay 0.1

        -- Phase 3: Verify the correct window is focused
        try
            set frontWindowId to id of first window
            if frontWindowId is equal to targetWindowId then
                set focusSuccess to true
            else
                -- Wrong window focused
                -- On retry, try more aggressive approach
                if attemptNum < maxAttempts then
                    delay (0.3 * attemptNum)
                    -- Try activating again - sometimes helps with Space switching
                    activate
                    delay 0.2
                end if
            end if
        on error errMsg
            -- Could not verify, assume success on last attempt
            if attemptNum is maxAttempts then
                set focusSuccess to true
            end if
        end try
    end repeat

    -- Final aggressive attempt if still not focused
    if not focusSuccess then
        -- One more try with maximum delays
        set index of targetWindow to 1
        select targetWindow
        delay 0.5
        activate
        delay 0.5
        tell application "System Events"
            tell process "iTerm2"
                set frontmost to true
                delay 0.1
                try
                    perform action "AXRaise" of first window
                end try
            end tell
        end tell
        -- Check one more time
        try
            set frontWindowId to id of first window
            if frontWindowId is equal to targetWindowId then
                set focusSuccess to true
            end if
        end try
    end if

    if focusSuccess then
        if isFullscreen then
            return "SUCCESS: Focused fullscreen window id " & targetWindowId & " tab " & targetTabIndex & " for $property $target"
        else
            return "SUCCESS: Focused window id " & targetWindowId & " tab " & targetTabIndex & " for $property $target"
        end if
    else
        return "FOCUS_FAILED: Requested window id " & targetWindowId & " (fullscreen=" & isFullscreen & ") but front window has different id after " & maxAttempts & " attempts"
    end if
end tell
APPLESCRIPT
)
    echo "$(date): iTerm2 result: $result" >> $LOG_FILE
}

# Switch Terminal.app to the tab with the given TTY
switch_terminal_tab() {
    local target_tty="$1"
    echo "$(date): Looking for Terminal.app tab with tty=$target_tty" >> $LOG_FILE

    # Special case: "frontmost" just activates Terminal.app
    if [[ "$target_tty" == "frontmost" ]]; then
        osascript -e 'tell application "Terminal" to activate'
        osascript -e 'tell application "System Events" to set frontmost of process "Terminal" to true'
        echo "$(date): Terminal.app activated (frontmost)" >> $LOG_FILE
        return
    fi

    local result
    result=$(osascript << APPLESCRIPT 2>&1
tell application "Terminal"
    repeat with w in windows
        set tabIndex to 0
        repeat with t in tabs of w
            set tabIndex to tabIndex + 1
            if (tty of t) is "$target_tty" then
                set frontmost of w to true
                set selected tab of w to t
                activate
                tell application "System Events"
                    set frontmost of process "Terminal" to true
                end tell
                return "Switched to tab " & tabIndex & " for tty " & (tty of t)
            end if
        end repeat
    end repeat
    return "tty $target_tty not found"
end tell
APPLESCRIPT
)
    echo "$(date): Terminal.app result: $result" >> $LOG_FILE
}

# Switch tmux to the specified session:window and return the client TTY
switch_tmux_window() {
    local tmux_target="$1"
    local session="${tmux_target%%:*}"
    local window="${tmux_target#*:}"
    window="${window%%.*}"

    echo "$(date): Switching tmux to session=$session window=$window" >> $LOG_FILE

    local client_tty
    client_tty=$($TMUX_BIN -S "$TMUX_SOCKET" list-clients -t "$session" -F '#{client_tty}' 2>/dev/null | head -1)

    if [[ -n "$client_tty" ]]; then
        $TMUX_BIN -S "$TMUX_SOCKET" switch-client -c "$client_tty" -t "$session:$window" 2>/dev/null
        echo "$(date): Switched tmux client $client_tty to $session:$window" >> $LOG_FILE
    else
        $TMUX_BIN -S "$TMUX_SOCKET" select-window -t "$session:$window" 2>/dev/null
        echo "$(date): Selected tmux window $session:$window directly" >> $LOG_FILE
    fi

    echo "$client_tty"
}

# Get action input (if any)
# TEXT_INPUT from ?text= takes priority over action mapping
if [[ -n "$TEXT_INPUT" ]]; then
    ACTION_INPUT="$TEXT_INPUT"
else
    ACTION_INPUT=$(get_action_input "$ACTION")
fi

# Main logic
case "$TYPE" in
    iterm-tmux)
        # iTerm2 running tmux - send input first (works in background), then focus
        send_tmux_input "$ARG2" "$ACTION_INPUT"
        switch_iterm_session "tty" "$ARG1"
        switch_tmux_window "$ARG2"
        ;;
    iterm2)
        # Pure iTerm2 - ARG1 is the session UUID
        focus_result=$(switch_iterm_session "id" "$ARG1")
        if [[ "$focus_result" == SUCCESS* ]]; then
            send_iterm_input "id" "$ARG1" "$ACTION_INPUT"
        else
            echo "$(date): Skipping input - focus failed: $focus_result" >> $LOG_FILE
        fi
        ;;
    terminal-tmux)
        # Terminal.app running tmux - send input first, then focus
        send_tmux_input "$ARG2" "$ACTION_INPUT"
        switch_terminal_tab "$ARG1"
        switch_tmux_window "$ARG2"
        ;;
    terminal)
        # Pure Terminal.app - switch to the tab by TTY
        switch_terminal_tab "$ARG1"
        send_terminal_input "$ARG1" "$ACTION_INPUT"
        ;;
    tmux)
        # Pure tmux - send input first, then switch and focus
        send_tmux_input "$ARG1" "$ACTION_INPUT"
        client_tty=$(switch_tmux_window "$ARG1")
        if [[ -n "$client_tty" ]]; then
            # Try iTerm first, then Terminal
            switch_iterm_session "tty" "$client_tty" 2>/dev/null || \
            switch_terminal_tab "$client_tty" 2>/dev/null
        else
            osascript -e 'tell application "iTerm2" to activate' 2>/dev/null || \
            osascript -e 'tell application "Terminal" to activate' 2>/dev/null
        fi
        ;;
    ssh-linked)
        # SSH with linked local terminal
        # ARG1=link_id, ARG2=host, ARG3=user, ARG4=port, ARG5=tmux_target
        link_id="$ARG1"
        ssh_host="$ARG2"
        ssh_user="$ARG3"
        ssh_port="$ARG4"
        remote_tmux_target="$ARG5"

        echo "$(date): SSH-linked: link=$link_id host=$ssh_host user=$ssh_user port=$ssh_port tmux=$remote_tmux_target" >> "$LOG_FILE"

        # Step 1: Focus LOCAL terminal using link info
        link_file="$LINKS_DIR/${link_id}.json"
        if [[ -f "$link_file" ]]; then
            local_type=$(grep -o '"term_type": *"[^"]*"' "$link_file" | cut -d'"' -f4)
            local_target=$(grep -o '"term_target": *"[^"]*"' "$link_file" | cut -d'"' -f4)

            echo "$(date): Link found: local_type=$local_type local_target=$local_target" >> "$LOG_FILE"

            case "$local_type" in
                iterm2)
                    switch_iterm_session "id" "$local_target"
                    ;;
                iterm-tmux)
                    local_tty="${local_target%%|*}"
                    local_tmux="${local_target#*|}"
                    switch_iterm_session "tty" "$local_tty"
                    switch_tmux_window "$local_tmux"
                    ;;
                terminal-tmux)
                    local_tty="${local_target%%|*}"
                    local_tmux="${local_target#*|}"
                    switch_terminal_tab "$local_tty"
                    switch_tmux_window "$local_tmux"
                    ;;
                terminal)
                    switch_terminal_tab "$local_target"
                    ;;
                tmux)
                    client_tty=$(switch_tmux_window "$local_target")
                    if [[ -n "$client_tty" ]]; then
                        switch_iterm_session "tty" "$client_tty" 2>/dev/null || \
                        switch_terminal_tab "$client_tty" 2>/dev/null
                    fi
                    ;;
                *)
                    echo "$(date): Unknown local term type: $local_type" >> "$LOG_FILE"
                    ;;
            esac
        else
            echo "$(date): Link file not found: $link_file" >> "$LOG_FILE"
        fi

        # Step 2: Switch remote tmux to the correct window/pane
        if [[ -n "$remote_tmux_target" ]]; then
            switch_remote_tmux "$ssh_host" "$ssh_user" "$ssh_port" "$remote_tmux_target"
        fi

        # Step 3: Send input to REMOTE via SSH (if action specified)
        if [[ -n "$ACTION_INPUT" && -n "$remote_tmux_target" ]]; then
            send_ssh_tmux_input "$ssh_host" "$ssh_user" "$ssh_port" "$remote_tmux_target" "$ACTION_INPUT"
        fi
        ;;
    ssh-tmux)
        # Direct SSH + tmux (no local terminal link)
        # ARG1=host, ARG2=user, ARG3=port, ARG4=tmux_target
        ssh_host="$ARG1"
        ssh_user="$ARG2"
        ssh_port="$ARG3"
        remote_tmux_target="$ARG4"

        echo "$(date): SSH-tmux (direct): host=$ssh_host user=$ssh_user port=$ssh_port tmux=$remote_tmux_target" >> "$LOG_FILE"

        # Switch remote tmux to correct window/pane
        if [[ -n "$remote_tmux_target" ]]; then
            switch_remote_tmux "$ssh_host" "$ssh_user" "$ssh_port" "$remote_tmux_target"
        fi

        # Send input to remote
        if [[ -n "$ACTION_INPUT" && -n "$remote_tmux_target" ]]; then
            send_ssh_tmux_input "$ssh_host" "$ssh_user" "$ssh_port" "$remote_tmux_target" "$ACTION_INPUT"
        fi
        ;;
    jupyter-tmux)
        # JupyterLab terminal in Chrome + remote tmux
        # ARG1=link_id, ARG2=host, ARG3=user, ARG4=port, ARG5=tmux_target
        link_id="$ARG1"
        ssh_host="$ARG2"
        ssh_user="$ARG3"
        ssh_port="$ARG4"
        remote_tmux_target="$ARG5"

        echo "$(date): Jupyter-tmux: link=$link_id host=$ssh_host user=$ssh_user port=$ssh_port tmux=$remote_tmux_target" >> "$LOG_FILE"

        # Step 1: Focus Chrome tab with JupyterLab URL from link file
        link_file="$LINKS_DIR/${link_id}.json"
        if [[ -f "$link_file" ]]; then
            jupyter_url=$(grep -o '"jupyter_url": *"[^"]*"' "$link_file" | cut -d'"' -f4)

            if [[ -n "$jupyter_url" ]]; then
                echo "$(date): Focusing Chrome tab with URL containing: $jupyter_url" >> "$LOG_FILE"

                # Focus Chrome and find tab matching the JupyterLab URL
                osascript << APPLESCRIPT 2>/dev/null
tell application "Google Chrome"
    set found to false
    repeat with w in windows
        set tabIndex to 0
        repeat with t in tabs of w
            set tabIndex to tabIndex + 1
            if URL of t contains "$jupyter_url" or "$jupyter_url" contains URL of t then
                set index of w to 1
                set active tab index of w to tabIndex
                activate
                tell application "System Events"
                    set frontmost of process "Google Chrome" to true
                end tell
                set found to true
                exit repeat
            end if
        end repeat
        if found then exit repeat
    end repeat
    if not found then
        activate
    end if
end tell
APPLESCRIPT
            fi
        else
            echo "$(date): Link file not found: $link_file" >> "$LOG_FILE"
            # Just activate Chrome as fallback
            osascript -e 'tell application "Google Chrome" to activate' 2>/dev/null
        fi

        # Step 2: Switch remote tmux to correct window/pane
        if [[ -n "$remote_tmux_target" ]]; then
            switch_remote_tmux "$ssh_host" "$ssh_user" "$ssh_port" "$remote_tmux_target"
        fi

        # Step 3: Send input to remote via SSH
        if [[ -n "$ACTION_INPUT" && -n "$remote_tmux_target" ]]; then
            send_ssh_tmux_input "$ssh_host" "$ssh_user" "$ssh_port" "$remote_tmux_target" "$ACTION_INPUT"
        fi
        ;;
    jupyter-link)
        # Create JupyterLab link file from URL parameters
        # URL format: claude-focus://jupyter-link/{link_id}?url={jupyter_url}&host={ssh_host}&name={instance_name}
        link_id="$ARG1"
        jupyter_url="$PARAM_URL"
        ssh_host="$PARAM_HOST"
        instance_name="${PARAM_NAME:-jupyter}"

        echo "$(date): Creating jupyter link: id=$link_id url=$jupyter_url host=$ssh_host name=$instance_name" >> "$LOG_FILE"

        if [[ -z "$link_id" || -z "$jupyter_url" || -z "$ssh_host" ]]; then
            echo "$(date): Error: Missing required parameters for jupyter-link" >> "$LOG_FILE"
            osascript -e 'display notification "Missing link parameters" with title "Claude Slack Notify"'
            exit 1
        fi

        # Create links directory if needed
        mkdir -p "$LINKS_DIR"

        # Get current user for SSH
        ssh_user=$(whoami)
        ssh_port="22"

        # Create the link file
        link_file="$LINKS_DIR/${link_id}.json"
        cat > "$link_file" << EOF
{
  "link_id": "${link_id}",
  "instance_name": "${instance_name}",
  "term_type": "jupyter-tmux",
  "jupyter_url": "${jupyter_url}",
  "ssh_host": "${ssh_host}",
  "ssh_user": "${ssh_user}",
  "ssh_port": "${ssh_port}",
  "created_at": "$(date -Iseconds)"
}
EOF

        echo "$(date): Link file created: $link_file" >> "$LOG_FILE"

        # Close the setup tab (the one with claude-focus:// URL) and switch to JupyterLab
        osascript << 'APPLESCRIPT' 2>/dev/null
tell application "Google Chrome"
    -- Find and close the claude-focus:// tab
    repeat with w in windows
        set tabIndex to 0
        repeat with t in tabs of w
            set tabIndex to tabIndex + 1
            if URL of t starts with "claude-focus://" then
                close t
                exit repeat
            end if
        end repeat
    end repeat

    -- Find and focus the JupyterLab tab
    repeat with w in windows
        set tabIndex to 0
        repeat with t in tabs of w
            set tabIndex to tabIndex + 1
            if URL of t contains "jupyter" or URL of t contains "lab" then
                set index of w to 1
                set active tab index of w to tabIndex
                activate
                exit repeat
            end if
        end repeat
    end repeat
end tell
APPLESCRIPT

        # Show success notification
        osascript -e "display notification \"JupyterLab link created! Focus button will now work.\" with title \"Claude Slack Notify\" sound name \"Glass\""
        ;;
esac
