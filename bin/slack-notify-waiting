#!/bin/bash
# Hook wrapper for when Claude is waiting for user input
# Starts a background watcher that notifies after 30s if user doesn't respond
# Called on: Stop, SubagentStop, Notification (idle_prompt), PermissionRequest

STDIN_DATA=$(cat)
CLAUDE_DIR="${HOME}/.claude"
INSTANCES_DIR="${CLAUDE_DIR}/instances"

# Extract session_id from hook data
if command -v jq &>/dev/null; then
    SESSION_ID=$(echo "$STDIN_DATA" | jq -r '.session_id // empty' 2>/dev/null)
else
    SESSION_ID=$(echo "$STDIN_DATA" | grep -o '"session_id":"[^"]*"' | sed 's/"session_id":"//;s/"$//' 2>/dev/null)
fi

# Require SESSION_ID - don't fall back to unreliable $PPID
if [[ -z "$SESSION_ID" ]]; then
    # No session_id means we can't reliably identify the session - skip silently
    exit 0
fi
INSTANCE_ID="$SESSION_ID"

# Validate INSTANCE_ID format
if [[ ! "$INSTANCE_ID" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    exit 0
fi

INSTANCE_FILE="${INSTANCES_DIR}/${INSTANCE_ID}.json"
WAIT_FILE="/tmp/claude-waiting-${INSTANCE_ID}"
CONTEXT_FILE="/tmp/claude-waiting-ctx-${INSTANCE_ID}"

# Only work for registered instances
if [[ ! -f "$INSTANCE_FILE" ]]; then
    exit 0
fi

# Kill any existing watcher for this instance (prevents stacking)
WATCHER_PID_FILE="/tmp/claude-watcher-pid-${INSTANCE_ID}"
if [[ -f "$WATCHER_PID_FILE" ]]; then
    OLD_PID=$(cat "$WATCHER_PID_FILE" 2>/dev/null)
    if [[ -n "$OLD_PID" ]] && kill -0 "$OLD_PID" 2>/dev/null; then
        kill "$OLD_PID" 2>/dev/null
    fi
    rm -f "$WATCHER_PID_FILE"
fi

# Clean up old files
rm -f "$WAIT_FILE" "$CONTEXT_FILE"

# Tool formatter for rich context extraction (matches claude-slack-notify)
TOOL_FORMATTER='
def format_tool:
    if .name == "Bash" then
        "⏳ Bash: " + ((.input.command // "") | split("\n")[0] | .[0:80]) +
        (if (.input.description // "") != "" then " (" + .input.description + ")" else "" end)
    elif .name == "Edit" then
        "⏳ Edit: " + (.input.file_path // "") +
        (if (.input.old_string // "") != "" then " (replacing " + ((.input.old_string // "") | .[0:30]) + "...)" else "" end)
    elif .name == "Write" then
        "⏳ Write: " + (.input.file_path // "")
    elif .name == "Read" then
        "⏳ Read: " + (.input.file_path // "")
    elif .name == "Glob" then
        "⏳ Glob: " + (.input.pattern // "")
    elif .name == "Grep" then
        "⏳ Grep: " + (.input.pattern // "")
    elif .name == "AskUserQuestion" then
        [.input.questions[] |
            "❓ " + .question + "\n" +
            ([.options // [] | to_entries[] |
                "   " + ((.key + 1) | tostring) + ". " + .value.label +
                (if (.value.description // "") != "" then " - " + .value.description else "" end)
            ] | join("\n"))
        ] | join("\n\n")
    elif .name == "Task" then
        "⏳ Task (" + (.input.subagent_type // "agent") + "): " +
        (if (.input.description // "") != "" then .input.description
         elif (.input.prompt // "") != "" then ((.input.prompt // "") | .[0:100])
         else "running subagent" end)
    elif .name == "WebFetch" then
        "⏳ WebFetch: " + (.input.url // "")
    elif .name == "WebSearch" then
        "⏳ WebSearch: " + (.input.query // "")
    elif .name == "EnterPlanMode" then
        "⏳ Entering plan mode"
    elif .name == "ExitPlanMode" then
        "⏳ Exiting plan mode - awaiting approval"
    elif (.name | startswith("mcp__")) then
        "⏳ MCP: " + ((.name | split("__") | .[1:] | join("/")) // .name)
    else
        "⏳ " + .name +
        (if (.input.description // "") != "" then ": " + .input.description
         elif (.input.file_path // "") != "" then ": " + .input.file_path
         elif (.input.prompt // "") != "" then ": " + ((.input.prompt // "") | .[0:80])
         else "" end)
    end;
format_tool
'

# Extract context from the hook event
CONTEXT=""
if command -v jq &>/dev/null && [[ -n "$STDIN_DATA" ]]; then
    HOOK_EVENT=$(echo "$STDIN_DATA" | jq -r '.hook_event_name // empty' 2>/dev/null)

    # Try to get context from notification message
    NOTIF_MSG=$(echo "$STDIN_DATA" | jq -r '.message // empty' 2>/dev/null)

    # Try to get tool info for permission requests (direct from hook data)
    TOOL_NAME=$(echo "$STDIN_DATA" | jq -r '.tool_name // empty' 2>/dev/null)
    if [[ -n "$TOOL_NAME" ]]; then
        # Use the full tool formatter for rich context
        CONTEXT=$(echo "$STDIN_DATA" | jq -r '{name: .tool_name, input: .tool_input} | '"$TOOL_FORMATTER" 2>/dev/null)
    fi

    # Get context from transcript (for Stop/SubagentStop events or when no direct tool info)
    TRANSCRIPT_PATH=$(echo "$STDIN_DATA" | jq -r '.transcript_path // empty' 2>/dev/null)
    if [[ -n "$TRANSCRIPT_PATH" && -f "$TRANSCRIPT_PATH" ]]; then
        # Extract full assistant message content (text + tool calls with rich formatting)
        TRANSCRIPT_CONTEXT=$(tac "$TRANSCRIPT_PATH" 2>/dev/null | while read -r line; do
            MSG_TYPE=$(echo "$line" | jq -r '.type // empty' 2>/dev/null)
            if [[ "$MSG_TYPE" == "assistant" ]]; then
                # Build full content: text blocks + formatted tool descriptions
                FULL_CONTENT=$(echo "$line" | jq -r '
                    if .message.content then
                        [.message.content[] |
                            if .type == "text" then
                                .text
                            elif .type == "tool_use" then
                                {name: .name, input: .input} | '"$TOOL_FORMATTER"'
                            else
                                empty
                            end
                        ] | map(select(. != null and . != "")) | join("\n\n") | .[0:1000]
                    else
                        empty
                    end
                ' 2>/dev/null)
                if [[ -n "$FULL_CONTENT" ]]; then
                    echo "$FULL_CONTENT"
                    break
                fi
            fi
        done)

        # Use transcript context if we don't have direct tool context, or append it
        if [[ -z "$CONTEXT" && -n "$TRANSCRIPT_CONTEXT" ]]; then
            CONTEXT="$TRANSCRIPT_CONTEXT"
        elif [[ -n "$CONTEXT" && -n "$TRANSCRIPT_CONTEXT" && "$CONTEXT" != "$TRANSCRIPT_CONTEXT" ]]; then
            # If we have both, prefer the more detailed one (transcript usually has more context)
            if [[ ${#TRANSCRIPT_CONTEXT} -gt ${#CONTEXT} ]]; then
                CONTEXT="$TRANSCRIPT_CONTEXT"
            fi
        fi
    fi

    # Append notification message if present and different from context
    if [[ -n "$NOTIF_MSG" && "$CONTEXT" != *"$NOTIF_MSG"* ]]; then
        if [[ -n "$CONTEXT" ]]; then
            CONTEXT="${CONTEXT}

---
_${NOTIF_MSG}_"
        else
            CONTEXT="$NOTIF_MSG"
        fi
    fi
fi

# Create wait file marker
date +%s > "$WAIT_FILE"

# Save context if we have any
if [[ -n "$CONTEXT" ]]; then
    echo "$CONTEXT" > "$CONTEXT_FILE"
fi

# Start the background watcher
nohup "$HOME/.claude/bin/slack-notify-stale-watcher" "$INSTANCE_ID" "$WAIT_FILE" "$CONTEXT_FILE" </dev/null >/dev/null 2>&1 &
WATCHER_PID=$!
echo "$WATCHER_PID" > "$WATCHER_PID_FILE"

exit 0
