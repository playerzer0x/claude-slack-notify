#!/bin/bash
# Claude Slack Notifier - Multi-instance aware with clickable focus buttons

CLAUDE_DIR="${HOME}/.claude"
WEBHOOK_FILE="${CLAUDE_DIR}/slack-webhook-url"
INSTANCES_DIR="${CLAUDE_DIR}/instances"
MIN_DURATION="${CLAUDE_NOTIFY_MIN_SECONDS:-30}"

# Get instance ID - use parent PID to be consistent across hook calls
INSTANCE_ID="${CLAUDE_INSTANCE_ID:-$PPID}"

# Validate INSTANCE_ID to prevent path traversal attacks
# Only allow alphanumeric characters, underscore, and hyphen
if [[ ! "$INSTANCE_ID" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    echo "Error: Invalid INSTANCE_ID format" >&2
    exit 1
fi

INSTANCE_FILE="${INSTANCES_DIR}/${INSTANCE_ID}.json"
TIMESTAMP_FILE="/tmp/claude-prompt-start-${INSTANCE_ID}"

# -----------------------------------------------------------------------------
# Detect terminal environment and build focus URL
# Sets: TERM_TYPE, TERM_TARGET, FOCUS_URL
# -----------------------------------------------------------------------------
# URL encode a string (encode all non-alphanumeric except - _ . ~)
url_encode() {
    local string="$1"
    local length="${#string}"
    local encoded=""
    local c
    for (( i = 0; i < length; i++ )); do
        c="${string:i:1}"
        case "$c" in
            [a-zA-Z0-9._~-]) encoded+="$c" ;;
            *) encoded+=$(printf '%%%02X' "'$c") ;;
        esac
    done
    echo "$encoded"
}

# Escape string for safe embedding in JSON
# Handles: backslash, double quote, newline, carriage return, tab
json_escape() {
    local str="$1"
    str="${str//\\/\\\\}"      # Escape backslashes first
    str="${str//\"/\\\"}"      # Escape double quotes
    str="${str//$'\n'/\\n}"    # Escape newlines
    str="${str//$'\r'/\\r}"    # Escape carriage returns
    str="${str//$'\t'/\\t}"    # Escape tabs
    echo "$str"
}

get_tmux_target() {
    # Get the controlling TTY for this process tree
    # We need to find the TTY that corresponds to our tmux pane
    local my_tty=""

    # Try to get TTY from PPID (the Claude process's shell)
    # Use CLAUDE_INSTANCE_ID if set (it's the Claude process PID)
    local check_pid="${CLAUDE_INSTANCE_ID:-$PPID}"
    my_tty=$(ps -p "$check_pid" -o tty= 2>/dev/null | tr -d ' ')

    # Normalize TTY format (add /dev/ prefix if missing)
    if [[ -n "$my_tty" && "$my_tty" != "??" && "$my_tty" != "?" ]]; then
        [[ "$my_tty" != /dev/* ]] && my_tty="/dev/$my_tty"

        # Look up which tmux pane has this TTY
        local pane_info
        pane_info=$(tmux list-panes -a -F '#{pane_tty} #{session_name}:#{window_index}.#{pane_index}' 2>/dev/null | grep "^${my_tty} " | head -1)

        if [[ -n "$pane_info" ]]; then
            # Extract session:window.pane from the output
            echo "${pane_info#* }"
            return
        fi
    fi

    # Fallback to display-message (works when called from the active pane)
    local session window pane
    session=$(tmux display-message -p '#{session_name}' 2>/dev/null)
    window=$(tmux display-message -p '#{window_index}' 2>/dev/null)
    pane=$(tmux display-message -p '#{pane_index}' 2>/dev/null)
    echo "${session}:${window}.${pane}"
}

detect_terminal() {
    TERM_TYPE="unknown"
    TERM_TARGET=""
    FOCUS_URL=""

    # Detect OS
    local os_type
    case "$(uname -s)" in
        MINGW*|MSYS*|CYGWIN*) os_type="windows" ;;
        Linux)
            if [[ -n "$WSL_DISTRO_NAME" ]] || grep -qi microsoft /proc/version 2>/dev/null; then
                os_type="wsl"
            else
                os_type="linux"
            fi
            ;;
        Darwin) os_type="macos" ;;
        *) os_type="unknown" ;;
    esac

    # ---------------------------------------------------------------------
    # Windows Terminal detection (runs in WSL, Git Bash, MSYS2, Cygwin)
    # ---------------------------------------------------------------------
    if [[ "$os_type" == "wsl" || "$os_type" == "windows" ]]; then
        if [[ -n "$WT_SESSION" ]]; then
            # Windows Terminal detected
            if [[ -n "$TMUX" ]]; then
                local tmux_target
                tmux_target=$(get_tmux_target)
                TERM_TYPE="wt-tmux"
                TERM_TARGET="${WT_SESSION}|${tmux_target}"
                FOCUS_URL="claude-focus://wt-tmux/$(url_encode "$WT_SESSION")/$(url_encode "$tmux_target")"
            else
                TERM_TYPE="windows-terminal"
                TERM_TARGET="$WT_SESSION"
                FOCUS_URL="claude-focus://windows-terminal/$(url_encode "$WT_SESSION")"
            fi
            return
        elif [[ -n "$ConEmuPID" ]]; then
            # ConEmu/Cmder detected
            TERM_TYPE="conemu"
            TERM_TARGET="$ConEmuPID"
            FOCUS_URL="claude-focus://conemu/$(url_encode "$ConEmuPID")"
            return
        elif [[ "$os_type" == "wsl" ]]; then
            # WSL without Windows Terminal - identify by WSL distro and window
            local wsl_window_id
            wsl_window_id="${WSL_DISTRO_NAME:-wsl}-$$"
            if [[ -n "$TMUX" ]]; then
                local tmux_target
                tmux_target=$(get_tmux_target)
                TERM_TYPE="wsl-tmux"
                TERM_TARGET="${wsl_window_id}|${tmux_target}"
                FOCUS_URL="claude-focus://wsl-tmux/$(url_encode "$wsl_window_id")/$(url_encode "$tmux_target")"
            else
                TERM_TYPE="wsl"
                TERM_TARGET="$wsl_window_id"
                FOCUS_URL="claude-focus://wsl/$(url_encode "$wsl_window_id")"
            fi
            return
        elif [[ "$os_type" == "windows" ]]; then
            # Git Bash / MSYS2 / Cygwin without Windows Terminal
            local mintty_pid="${MINTTY_PID:-$PPID}"
            TERM_TYPE="mintty"
            TERM_TARGET="$mintty_pid"
            FOCUS_URL="claude-focus://mintty/$(url_encode "$mintty_pid")"
            return
        fi
    fi

    # ---------------------------------------------------------------------
    # macOS terminal detection
    # ---------------------------------------------------------------------
    if [[ "$os_type" == "macos" ]]; then
        if [[ -n "$TMUX" ]]; then
            local tmux_target client_tty term_app client_termtype
            tmux_target=$(get_tmux_target)
            client_tty=$(tmux display-message -p '#{client_tty}' 2>/dev/null)
            client_termtype=$(tmux display-message -p '#{client_termtype}' 2>/dev/null)

            # Detect which terminal app is running tmux
            # Use client_termtype (most reliable), fall back to ITERM_SESSION_ID
            if [[ "$client_termtype" == *"iTerm"* ]] || [[ -n "$ITERM_SESSION_ID" ]]; then
                term_app="iterm"
            else
                term_app="terminal"
            fi

            if [[ -n "$client_tty" ]]; then
                TERM_TYPE="${term_app}-tmux"
                TERM_TARGET="${client_tty}|${tmux_target}"
                FOCUS_URL="claude-focus://${term_app}-tmux/$(url_encode "$client_tty")/$(url_encode "$tmux_target")"
            else
                TERM_TYPE="tmux"
                TERM_TARGET="$tmux_target"
                FOCUS_URL="claude-focus://tmux/$(url_encode "$tmux_target")"
            fi
        elif [[ -n "$ITERM_SESSION_ID" ]]; then
            TERM_TYPE="iterm2"
            TERM_TARGET="${ITERM_SESSION_ID#*:}"
            FOCUS_URL="claude-focus://iterm2/${TERM_TARGET}"
        elif [[ "$__CFBundleIdentifier" == "com.apple.Terminal" || "$TERM_PROGRAM" == "Apple_Terminal" ]]; then
            # Terminal.app - get TTY of current tab via AppleScript (works even in subshells)
            local terminal_tty
            terminal_tty=$(osascript -e 'tell application "Terminal" to return tty of selected tab of front window' 2>/dev/null)
            if [[ -n "$terminal_tty" ]]; then
                TERM_TYPE="terminal"
                TERM_TARGET="$terminal_tty"
                FOCUS_URL="claude-focus://terminal/$(url_encode "$terminal_tty")"
            fi
        fi
        return
    fi

    # ---------------------------------------------------------------------
    # Linux terminal detection (non-WSL)
    # ---------------------------------------------------------------------
    if [[ "$os_type" == "linux" ]]; then
        if [[ -n "$TMUX" ]]; then
            local tmux_target client_tty
            tmux_target=$(get_tmux_target)
            client_tty=$(tmux display-message -p '#{client_tty}' 2>/dev/null)
            if [[ -n "$client_tty" ]]; then
                TERM_TYPE="linux-tmux"
                TERM_TARGET="${client_tty}|${tmux_target}"
                FOCUS_URL="claude-focus://linux-tmux/$(url_encode "$client_tty")/$(url_encode "$tmux_target")"
            else
                TERM_TYPE="tmux"
                TERM_TARGET="$tmux_target"
                FOCUS_URL="claude-focus://tmux/$(url_encode "$tmux_target")"
            fi
        elif [[ -n "$GNOME_TERMINAL_SERVICE" ]]; then
            TERM_TYPE="gnome-terminal"
            TERM_TARGET="$$"
            FOCUS_URL="claude-focus://gnome-terminal/$(url_encode "$$")"
        elif [[ -n "$KONSOLE_DBUS_SESSION" ]]; then
            TERM_TYPE="konsole"
            TERM_TARGET="$KONSOLE_DBUS_SESSION"
            FOCUS_URL="claude-focus://konsole/$(url_encode "$KONSOLE_DBUS_SESSION")"
        elif [[ "$TERM_PROGRAM" == "vscode" ]]; then
            TERM_TYPE="vscode"
            TERM_TARGET="$$"
            FOCUS_URL="claude-focus://vscode/$(url_encode "$$")"
        fi
    fi
}

# -----------------------------------------------------------------------------
# Register a new instance
# -----------------------------------------------------------------------------
if [[ "$1" == "register" ]]; then
    mkdir -p "$INSTANCES_DIR"

    INSTANCE_NAME="$2"
    if [[ -z "$INSTANCE_NAME" ]]; then
        ADJECTIVES=("red" "blue" "green" "purple" "orange" "silver" "golden" "cosmic" "swift" "bright" "dark" "wild" "calm" "bold" "quick")
        NOUNS=("wolf" "hawk" "bear" "lion" "tiger" "eagle" "falcon" "dragon" "phoenix" "raven" "fox" "panther" "cobra" "shark" "storm")
        COLORS=("amber" "coral" "jade" "ruby" "onyx" "ivory" "copper" "bronze" "teal" "indigo" "crimson" "azure" "scarlet" "violet" "emerald")
        ITEMS=("coffee" "thunder" "shadow" "crystal" "ember" "breeze" "river" "mountain" "forest" "ocean" "sunrise" "comet" "glacier" "canyon" "meadow")
        INSTANCE_NAME="${ADJECTIVES[$RANDOM % ${#ADJECTIVES[@]}]}-${NOUNS[$RANDOM % ${#NOUNS[@]}]}-${COLORS[$RANDOM % ${#COLORS[@]}]}-${ITEMS[$RANDOM % ${#ITEMS[@]}]}"
    fi

    detect_terminal
    HOSTNAME=$(hostname -s 2>/dev/null || echo "unknown")

    cat > "$INSTANCE_FILE" << EOF
{
  "id": "${INSTANCE_ID}",
  "name": "${INSTANCE_NAME}",
  "hostname": "${HOSTNAME}",
  "term_type": "${TERM_TYPE}",
  "term_target": "${TERM_TARGET}",
  "focus_url": "${FOCUS_URL}",
  "registered_at": "$(date -Iseconds)"
}
EOF

    echo "$INSTANCE_NAME"
    exit 0
fi

# -----------------------------------------------------------------------------
# List registered instances
# -----------------------------------------------------------------------------
if [[ "$1" == "list" ]]; then
    if [[ -d "$INSTANCES_DIR" ]]; then
        for f in "$INSTANCES_DIR"/*.json; do
            [[ -f "$f" ]] || continue
            NAME=$(grep -o '"name": *"[^"]*"' "$f" | cut -d'"' -f4)
            HOST=$(grep -o '"hostname": *"[^"]*"' "$f" | cut -d'"' -f4)
            TERM=$(grep -o '"term_type": *"[^"]*"' "$f" | cut -d'"' -f4)
            TARGET=$(grep -o '"term_target": *"[^"]*"' "$f" | cut -d'"' -f4)
            echo "$NAME @ $HOST ($TERM $TARGET)"
        done
    fi
    exit 0
fi

# -----------------------------------------------------------------------------
# Start timing
# Usage: claude-slack-notify start
# -----------------------------------------------------------------------------
if [[ "$1" == "start" ]]; then
    # Only work for registered instances (prevents sub-agents from creating timers)
    if [[ ! -f "$INSTANCE_FILE" ]]; then
        exit 0
    fi

    # Only start a new timer if one isn't already running
    # This preserves the original start time across multiple rapid tool calls
    if [[ ! -f "$TIMESTAMP_FILE" ]]; then
        date +%s > "$TIMESTAMP_FILE"
    fi
    exit 0
fi

# -----------------------------------------------------------------------------
# Check elapsed time and notify if needed
# Usage: claude-slack-notify check [context]
# Stop hook passes transcript_path in stdin JSON
# -----------------------------------------------------------------------------
if [[ "$1" == "check" ]]; then
    # Only work for registered instances (prevents sub-agents from notifying)
    if [[ ! -f "$INSTANCE_FILE" ]]; then
        exit 0
    fi

    if [[ -f "$TIMESTAMP_FILE" ]]; then
        START_TIME=$(cat "$TIMESTAMP_FILE")
        NOW=$(date +%s)
        ELAPSED=$((NOW - START_TIME))

        # Only notify and clear timestamp if elapsed >= threshold
        # This preserves timing across multiple rapid tool calls
        if [[ $ELAPSED -lt $MIN_DURATION ]]; then
            exit 0
        fi

        # Threshold exceeded - clear timestamp and notify
        rm -f "$TIMESTAMP_FILE"

        # Try to get Claude's last message from transcript
        CONTEXT=""
        if [[ ! -t 0 ]]; then
            STDIN_DATA=$(timeout 1 cat 2>/dev/null || true)
            if [[ -n "$STDIN_DATA" ]] && command -v jq &>/dev/null; then
                TRANSCRIPT_PATH=$(echo "$STDIN_DATA" | jq -r '.transcript_path // empty' 2>/dev/null)
                if [[ -n "$TRANSCRIPT_PATH" && -f "$TRANSCRIPT_PATH" ]]; then
                    # Get last assistant message from transcript (JSONL format)
                    # Look for the last line with type=assistant and extract first 100 chars of message
                    LAST_MSG=$(tac "$TRANSCRIPT_PATH" 2>/dev/null | while read -r line; do
                        MSG_TYPE=$(echo "$line" | jq -r '.type // empty' 2>/dev/null)
                        if [[ "$MSG_TYPE" == "assistant" ]]; then
                            # Extract text content from message
                            TEXT=$(echo "$line" | jq -r '
                                if .message.content then
                                    [.message.content[] | select(.type == "text") | .text] | join(" ")
                                else
                                    empty
                                end
                            ' 2>/dev/null)
                            if [[ -n "$TEXT" ]]; then
                                echo "$TEXT"
                                break
                            fi
                        fi
                    done)
                    if [[ -n "$LAST_MSG" ]]; then
                        CONTEXT="$LAST_MSG"
                    fi
                fi
            fi
        fi

        # Build message
        if [[ -n "$CONTEXT" ]]; then
            MESSAGE="${CONTEXT} (${ELAPSED}s)"
        else
            MESSAGE="Task completed (${ELAPSED}s)"
        fi
    else
        exit 0
    fi
else
    MESSAGE="${1:-Ready for input}"
fi

STATUS="${2:-waiting}"

# -----------------------------------------------------------------------------
# Get webhook URL
# -----------------------------------------------------------------------------
if [[ -f "$WEBHOOK_FILE" ]]; then
    WEBHOOK_URL=$(cat "$WEBHOOK_FILE")
elif [[ -n "$SLACK_WEBHOOK_URL" ]]; then
    WEBHOOK_URL="$SLACK_WEBHOOK_URL"
else
    exit 0
fi

# -----------------------------------------------------------------------------
# Load instance info and detect terminal
# -----------------------------------------------------------------------------
INSTANCE_NAME="Claude"
HOSTNAME=$(hostname -s 2>/dev/null || echo "unknown")

if [[ -f "$INSTANCE_FILE" ]]; then
    INSTANCE_NAME=$(grep -o '"name": *"[^"]*"' "$INSTANCE_FILE" | cut -d'"' -f4)
    HOSTNAME=$(grep -o '"hostname": *"[^"]*"' "$INSTANCE_FILE" | cut -d'"' -f4)
fi

# Dynamically detect current terminal (tmux window/pane can change)
detect_terminal

# Fallback to stored values if detection failed (for Docker containers, etc.)
if [[ "$TERM_TYPE" == "unknown" && -f "$INSTANCE_FILE" ]]; then
    TERM_TYPE=$(grep -o '"term_type": *"[^"]*"' "$INSTANCE_FILE" | cut -d'"' -f4)
    TERM_TARGET=$(grep -o '"term_target": *"[^"]*"' "$INSTANCE_FILE" | cut -d'"' -f4)
    FOCUS_URL=$(grep -o '"focus_url": *"[^"]*"' "$INSTANCE_FILE" | cut -d'"' -f4)
fi

# -----------------------------------------------------------------------------
# Build notification
# -----------------------------------------------------------------------------
case "$STATUS" in
    started)  COLOR="#36a64f" ;;
    waiting)  COLOR="#ff9800" ;;
    error)    COLOR="#ff0000" ;;
    *)        COLOR="#3AA3E3" ;;
esac

# Build location string (keep it short for Slack display)
LOCATION="$HOSTNAME"
if [[ -n "$TERM_TYPE" && "$TERM_TYPE" != "unknown" ]]; then
    # Extract just the tmux session:window.pane if present (skip the /dev/tty part)
    DISPLAY_TARGET="$TERM_TARGET"
    if [[ "$TERM_TARGET" == *"|"* ]]; then
        DISPLAY_TARGET="${TERM_TARGET#*|}"
    fi
    # Simplify term type for display
    case "$TERM_TYPE" in
        iterm-tmux|terminal-tmux|wt-tmux|wsl-tmux|linux-tmux)
            LOCATION="$HOSTNAME (tmux $DISPLAY_TARGET)" ;;
        *)
            LOCATION="$HOSTNAME ($TERM_TYPE)" ;;
    esac
fi

# Escape all user-controllable values for safe JSON embedding
SAFE_INSTANCE_NAME=$(json_escape "$INSTANCE_NAME")
SAFE_HOSTNAME=$(json_escape "$HOSTNAME")
SAFE_LOCATION=$(json_escape "$LOCATION")
SAFE_MESSAGE=$(json_escape "$MESSAGE")
SAFE_FOCUS_URL=$(json_escape "$FOCUS_URL")

# Build button block if we have a focus URL
BUTTON_BLOCK=""
if [[ -n "$FOCUS_URL" ]]; then
    # Create URLs for each action (append query param to focus URL)
    URL_1=$(json_escape "${FOCUS_URL}?action=1")
    URL_2=$(json_escape "${FOCUS_URL}?action=2")
    URL_CONTINUE=$(json_escape "${FOCUS_URL}?action=continue")
    URL_PUSH=$(json_escape "${FOCUS_URL}?action=push")

    BUTTON_BLOCK=",{
      \"type\": \"actions\",
      \"elements\": [
        {
          \"type\": \"button\",
          \"text\": { \"type\": \"plain_text\", \"text\": \"Focus\" },
          \"url\": \"${SAFE_FOCUS_URL}\"
        },
        {
          \"type\": \"button\",
          \"text\": { \"type\": \"plain_text\", \"text\": \"1\" },
          \"url\": \"${URL_1}\"
        },
        {
          \"type\": \"button\",
          \"text\": { \"type\": \"plain_text\", \"text\": \"2\" },
          \"url\": \"${URL_2}\"
        },
        {
          \"type\": \"button\",
          \"text\": { \"type\": \"plain_text\", \"text\": \"Continue\" },
          \"url\": \"${URL_CONTINUE}\"
        },
        {
          \"type\": \"button\",
          \"text\": { \"type\": \"plain_text\", \"text\": \"Push\", \"emoji\": true },
          \"url\": \"${URL_PUSH}\",
          \"style\": \"primary\"
        }
      ]
    }"
fi

curl -s -X POST -H 'Content-type: application/json' \
  --data "{
    \"attachments\": [
      {
        \"fallback\": \"${SAFE_INSTANCE_NAME}: ${SAFE_MESSAGE}\",
        \"color\": \"${COLOR}\",
        \"blocks\": [
          {
            \"type\": \"section\",
            \"text\": {
              \"type\": \"mrkdwn\",
              \"text\": \"*${SAFE_INSTANCE_NAME}* on \`${SAFE_LOCATION}\`\n${SAFE_MESSAGE}\"
            }
          }${BUTTON_BLOCK}
        ]
      }
    ]
  }" \
  "$WEBHOOK_URL" > /dev/null 2>&1
