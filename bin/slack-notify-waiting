#!/bin/bash
# Hook wrapper for when Claude is waiting for user input
# Starts a background watcher that notifies after 30s if user doesn't respond
# Called on: Stop, SubagentStop, Notification (idle_prompt), PermissionRequest

STDIN_DATA=$(cat)
CLAUDE_DIR="${HOME}/.claude"
INSTANCES_DIR="${CLAUDE_DIR}/instances"

# Extract session_id from hook data
if command -v jq &>/dev/null; then
    SESSION_ID=$(echo "$STDIN_DATA" | jq -r '.session_id // empty' 2>/dev/null)
else
    SESSION_ID=$(echo "$STDIN_DATA" | grep -o '"session_id":"[^"]*"' | sed 's/"session_id":"//;s/"$//' 2>/dev/null)
fi

# Require SESSION_ID - don't fall back to unreliable $PPID
if [[ -z "$SESSION_ID" ]]; then
    # No session_id means we can't reliably identify the session - skip silently
    exit 0
fi
INSTANCE_ID="$SESSION_ID"

# Validate INSTANCE_ID format
if [[ ! "$INSTANCE_ID" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    exit 0
fi

INSTANCE_FILE="${INSTANCES_DIR}/${INSTANCE_ID}.json"
WAIT_FILE="/tmp/claude-waiting-${INSTANCE_ID}"
CONTEXT_FILE="/tmp/claude-waiting-ctx-${INSTANCE_ID}"
QUESTION_OPTS_FILE="/tmp/claude-question-opts-${INSTANCE_ID}.json"
TRANSCRIPT_PATH_FILE="/tmp/claude-transcript-path-${INSTANCE_ID}"

# Only work for registered instances
if [[ ! -f "$INSTANCE_FILE" ]]; then
    exit 0
fi

# Kill any existing watcher for this instance (prevents stacking)
WATCHER_PID_FILE="/tmp/claude-watcher-pid-${INSTANCE_ID}"
if [[ -f "$WATCHER_PID_FILE" ]]; then
    OLD_PID=$(cat "$WATCHER_PID_FILE" 2>/dev/null)
    if [[ -n "$OLD_PID" ]] && kill -0 "$OLD_PID" 2>/dev/null; then
        kill "$OLD_PID" 2>/dev/null
    fi
    rm -f "$WATCHER_PID_FILE"
fi

# Clean up old files
rm -f "$WAIT_FILE" "$CONTEXT_FILE" "$QUESTION_OPTS_FILE" "$TRANSCRIPT_PATH_FILE"

# Tool formatter for rich context extraction (matches claude-slack-notify)
TOOL_FORMATTER='
def format_tool:
    if .name == "Bash" then
        "â³ Bash: " + ((.input.command // "") | split("\n")[0] | .[0:80]) +
        (if (.input.description // "") != "" then " (" + .input.description + ")" else "" end)
    elif .name == "Edit" then
        "â³ Edit: " + (.input.file_path // "") +
        (if (.input.old_string // "") != "" then " (replacing " + ((.input.old_string // "") | .[0:30]) + "...)" else "" end)
    elif .name == "Write" then
        "â³ Write: " + (.input.file_path // "")
    elif .name == "Read" then
        "â³ Read: " + (.input.file_path // "") +
        (if (.input.offset // 0) > 0 then " (from line " + ((.input.offset // 0) | tostring) + ")" else "" end)
    elif .name == "Glob" or .name == "Search" then
        "â³ " + .name + ": " + (.input.pattern // "") +
        (if (.input.path // "") != "" then " in " + .input.path else "" end)
    elif .name == "Grep" then
        "â³ Grep: " + (.input.pattern // "") +
        (if (.input.path // "") != "" then " in " + .input.path else "" end)
    elif .name == "AskUserQuestion" then
        [.input.questions[] |
            "â“ " + .question + "\n" +
            ([.options // [] | to_entries[] |
                "   " + ((.key + 1) | tostring) + ". " + .value.label +
                (if (.value.description // "") != "" then " - " + .value.description else "" end)
            ] | join("\n"))
        ] | join("\n\n")
    elif .name == "Task" then
        "â³ Task (" + (.input.subagent_type // "agent") + "): " +
        (if (.input.description // "") != "" then .input.description
         elif (.input.prompt // "") != "" then ((.input.prompt // "") | .[0:100])
         else "running subagent" end)
    elif .name == "WebFetch" then
        "â³ WebFetch: " + (.input.url // "")
    elif .name == "WebSearch" then
        "â³ WebSearch: " + (.input.query // "")
    elif .name == "Skill" then
        "â³ Skill: /" + (.input.skill // "")
    elif .name == "EnterPlanMode" then
        "â³ Entering plan mode"
    elif .name == "ExitPlanMode" then
        "â³ Exiting plan mode - awaiting approval"
    elif .name == "NotebookEdit" then
        "â³ NotebookEdit: " + (.input.notebook_path // "") +
        (if (.input.edit_mode // "") != "" then " (" + .input.edit_mode + ")" else "" end)
    elif .name == "TodoWrite" then
        "â³ TodoWrite: " + (
            [.input.todos[]? | select(.status == "in_progress") | .content] |
            if length > 0 then "Working on: " + (.[0] // "")
            else ([.input.todos[]?.content] | length | tostring) + " tasks"
            end
        )
    elif .name == "TaskCreate" then
        "â³ TaskCreate: " + (.input.subject // "new task")
    elif .name == "TaskUpdate" then
        "â³ TaskUpdate: " + (.input.taskId // "") +
        (if (.input.status // "") != "" then " â†’ " + .input.status else "" end)
    elif .name == "TaskGet" then
        "â³ TaskGet: " + (.input.taskId // "")
    elif .name == "TaskList" then
        "â³ TaskList"
    elif .name == "TaskOutput" then
        "â³ TaskOutput: " + (.input.task_id // "")
    elif .name == "KillShell" then
        "â³ KillShell: " + (.input.shell_id // "")
    elif (.name | contains("browser_navigate")) then
        "â³ ðŸŒ Navigate: " + (.input.url // "")
    elif (.name | contains("browser_click")) then
        "â³ ðŸ–±ï¸ Click: " + (.input.element // "element")
    elif (.name | contains("browser_type")) then
        "â³ âŒ¨ï¸ Type: " + ((.input.text // "") | .[0:40]) + (if (.input.element // "") != "" then " in " + .input.element else "" end)
    elif (.name | contains("browser_snapshot")) then
        "â³ ðŸ“¸ Browser snapshot"
    elif (.name | contains("browser_take_screenshot")) then
        "â³ ðŸ“· Screenshot" + (if (.input.element // "") != "" then ": " + .input.element else "" end)
    elif (.name | contains("browser_fill_form")) then
        "â³ ðŸ“ Fill form: " + ((.input.fields // []) | length | tostring) + " fields"
    elif (.name | contains("browser_select_option")) then
        "â³ ðŸ“‹ Select: " + ((.input.values // []) | join(", "))
    elif (.name | contains("browser_hover")) then
        "â³ ðŸ‘† Hover: " + (.input.element // "element")
    elif (.name | contains("browser_press_key")) then
        "â³ âŒ¨ï¸ Press: " + (.input.key // "key")
    elif (.name | contains("browser_wait_for")) then
        "â³ â³ Wait: " + (if (.input.text // "") != "" then "\"" + .input.text + "\"" elif (.input.time // 0) > 0 then (.input.time | tostring) + "s" else "condition" end)
    elif (.name | startswith("mcp__")) then
        "â³ MCP: " + ((.name | split("__") | .[1:] | join("/")) // .name) +
        (if (.input | keys | length) > 0 then
            " (" + ([.input | to_entries[] | select(.value != null and .value != "") | .key + "=" + (.value | tostring | .[0:30])] | .[0:3] | join(", ")) + ")"
         else "" end)
    else
        "â³ " + .name +
        (if (.input.description // "") != "" then ": " + .input.description
         elif (.input.file_path // "") != "" then ": " + .input.file_path
         elif (.input.pattern // "") != "" then ": " + .input.pattern + (if (.input.path // "") != "" then " in " + .input.path else "" end)
         elif (.input.prompt // "") != "" then ": " + ((.input.prompt // "") | .[0:80])
         elif (.input | keys | length) > 0 then ": " + ([.input | to_entries[] | select(.value != null and .value != "") | .key + "=" + (.value | tostring | .[0:30])] | .[0:2] | join(", "))
         else "" end)
    end;
format_tool
'

# Extract context from the hook event
CONTEXT=""
if command -v jq &>/dev/null && [[ -n "$STDIN_DATA" ]]; then
    HOOK_EVENT=$(echo "$STDIN_DATA" | jq -r '.hook_event_name // empty' 2>/dev/null)

    # Try to get context from notification message
    NOTIF_MSG=$(echo "$STDIN_DATA" | jq -r '.message // empty' 2>/dev/null)

    # Try to get tool info for permission requests (direct from hook data)
    TOOL_NAME=$(echo "$STDIN_DATA" | jq -r '.tool_name // empty' 2>/dev/null)
    if [[ -n "$TOOL_NAME" ]]; then
        # Use the full tool formatter for rich context
        CONTEXT=$(echo "$STDIN_DATA" | jq -r '{name: .tool_name, input: .tool_input} | '"$TOOL_FORMATTER" 2>/dev/null)

        # For AskUserQuestion, extract options for dynamic buttons
        if [[ "$TOOL_NAME" == "AskUserQuestion" ]]; then
            echo "$STDIN_DATA" | jq -c '[.tool_input.questions[]? | {
                question: .question,
                header: .header,
                multiSelect: .multiSelect,
                options: [.options[]? | {label: .label, description: .description}]
            }]' > "$QUESTION_OPTS_FILE" 2>/dev/null || rm -f "$QUESTION_OPTS_FILE"
        fi
    fi

    # Get context from transcript (for Stop/SubagentStop events or when no direct tool info)
    TRANSCRIPT_PATH=$(echo "$STDIN_DATA" | jq -r '.transcript_path // empty' 2>/dev/null)
    if [[ -n "$TRANSCRIPT_PATH" && -f "$TRANSCRIPT_PATH" ]]; then
        # Save transcript path for stale watcher to use
        echo "$TRANSCRIPT_PATH" > "$TRANSCRIPT_PATH_FILE"
        # Extract full assistant message content (text + tool calls with rich formatting)
        TRANSCRIPT_CONTEXT=$(tac "$TRANSCRIPT_PATH" 2>/dev/null | while read -r line; do
            MSG_TYPE=$(echo "$line" | jq -r '.type // empty' 2>/dev/null)
            if [[ "$MSG_TYPE" == "assistant" ]]; then
                # Build full content: text blocks + formatted tool descriptions
                FULL_CONTENT=$(echo "$line" | jq -r '
                    if .message.content then
                        [.message.content[] |
                            if .type == "text" then
                                .text
                            elif .type == "tool_use" then
                                {name: .name, input: .input} | '"$TOOL_FORMATTER"'
                            else
                                empty
                            end
                        ] | map(select(. != null and . != "")) | join("\n\n") | .[0:1000]
                    else
                        empty
                    end
                ' 2>/dev/null)
                if [[ -n "$FULL_CONTENT" ]]; then
                    echo "$FULL_CONTENT"
                    break
                fi
            fi
        done)

        # NOTE: Don't extract AskUserQuestion here - the transcript may not be updated yet
        # when the Stop hook fires. The stale watcher will extract 30s later when
        # the transcript is definitely updated.

        # Use transcript context if we don't have direct tool context, or append it
        if [[ -z "$CONTEXT" && -n "$TRANSCRIPT_CONTEXT" ]]; then
            CONTEXT="$TRANSCRIPT_CONTEXT"
        elif [[ -n "$CONTEXT" && -n "$TRANSCRIPT_CONTEXT" && "$CONTEXT" != "$TRANSCRIPT_CONTEXT" ]]; then
            # If we have both, prefer the more detailed one (transcript usually has more context)
            if [[ ${#TRANSCRIPT_CONTEXT} -gt ${#CONTEXT} ]]; then
                CONTEXT="$TRANSCRIPT_CONTEXT"
            fi
        fi
    fi

    # Append notification message if present and different from context
    if [[ -n "$NOTIF_MSG" && "$CONTEXT" != *"$NOTIF_MSG"* ]]; then
        if [[ -n "$CONTEXT" ]]; then
            CONTEXT="${CONTEXT}

---
_${NOTIF_MSG}_"
        else
            CONTEXT="$NOTIF_MSG"
        fi
    fi
fi

# Create wait file marker
date +%s > "$WAIT_FILE"

# Save context if we have any
if [[ -n "$CONTEXT" ]]; then
    echo "$CONTEXT" > "$CONTEXT_FILE"
fi

# Start the background watcher
nohup "$HOME/.claude/bin/slack-notify-stale-watcher" "$INSTANCE_ID" "$WAIT_FILE" "$CONTEXT_FILE" </dev/null >/dev/null 2>&1 &
WATCHER_PID=$!
echo "$WATCHER_PID" > "$WATCHER_PID_FILE"

exit 0
