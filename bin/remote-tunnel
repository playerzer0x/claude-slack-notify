#!/bin/bash
# =============================================================================
# remote-tunnel - Remote relay for Slack button actions (Linux only)
#
# Runs on a Linux server (in tmux) to receive Slack button clicks when your
# Mac is closed. Auto-detects if Mac is reachable and proxies to it when possible.
#
# Commands:
#   remote-tunnel           - Start tunnel (interactive)
#   remote-tunnel --setup   - Copy config from Mac or configure manually
#   remote-tunnel --background - Start tunnel in background
#   remote-tunnel --stop    - Stop background tunnel
#   remote-tunnel --status  - Check tunnel status
# =============================================================================

set -uo pipefail

RELAY_PORT=8464
CLAUDE_DIR="$HOME/.claude"
SLACK_CONFIG_FILE="$CLAUDE_DIR/.slack-config"
RELAY_PID_FILE="$CLAUDE_DIR/.remote-relay.pid"
TUNNEL_PID_FILE="$CLAUDE_DIR/.remote-tunnel.pid"
TUNNEL_URL_FILE="$CLAUDE_DIR/.remote-tunnel-url"
WATCHDOG_PID_FILE="$CLAUDE_DIR/.remote-tunnel-watchdog.pid"
ACTIVITY_FILE="$CLAUDE_DIR/.relay-last-activity"
TUNNEL_LOG="$CLAUDE_DIR/remote-tunnel.log"
IDLE_TIMEOUT=3600  # 1 hour in seconds

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

echo_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
echo_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
echo_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# =============================================================================
# Platform check - Linux only
# =============================================================================
if [[ "$(uname)" == "Darwin" ]]; then
    echo_error "remote-tunnel is for Linux servers only."
    echo_info "On macOS, use: slack-tunnel"
    exit 1
fi

# =============================================================================
# Slack API helpers (reused from slack-tunnel)
# =============================================================================

load_slack_config() {
    if [[ ! -f "$SLACK_CONFIG_FILE" ]]; then
        return 1
    fi
    source "$SLACK_CONFIG_FILE"
    return 0
}

save_slack_config() {
    cat > "$SLACK_CONFIG_FILE" << EOF
SLACK_APP_ID="$SLACK_APP_ID"
SLACK_ACCESS_TOKEN="$SLACK_ACCESS_TOKEN"
SLACK_REFRESH_TOKEN="$SLACK_REFRESH_TOKEN"
SLACK_TOKEN_EXPIRES="$SLACK_TOKEN_EXPIRES"
EOF
    chmod 600 "$SLACK_CONFIG_FILE"
}

is_token_expired() {
    local now
    now=$(date +%s)
    local buffer=300  # 5 minutes
    if [[ -z "${SLACK_TOKEN_EXPIRES:-}" ]] || [[ $((SLACK_TOKEN_EXPIRES - buffer)) -lt $now ]]; then
        return 0  # expired
    fi
    return 1  # not expired
}

rotate_slack_token() {
    echo_info "Refreshing Slack configuration token..."

    local response
    response=$(curl -s --max-time 30 -X POST "https://slack.com/api/tooling.tokens.rotate" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "refresh_token=${SLACK_REFRESH_TOKEN}")

    local ok
    ok=$(echo "$response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$response" | jq -r '.error // "unknown error"')
        echo_error "Failed to refresh token: $error"
        echo_error "Run 'remote-tunnel --setup' to reconfigure"
        return 1
    fi

    SLACK_ACCESS_TOKEN=$(echo "$response" | jq -r '.token')
    SLACK_REFRESH_TOKEN=$(echo "$response" | jq -r '.refresh_token')
    local exp
    exp=$(echo "$response" | jq -r '.exp')
    SLACK_TOKEN_EXPIRES="$exp"

    save_slack_config
    echo_info "Token refreshed successfully"
    return 0
}

update_slack_request_url() {
    local new_url="$1"

    # Ensure token is valid
    if is_token_expired; then
        if ! rotate_slack_token; then
            return 1
        fi
    fi

    echo_info "Updating Slack Request URL..."

    local manifest_response
    manifest_response=$(curl -s --max-time 30 -X POST "https://slack.com/api/apps.manifest.export" \
        -H "Authorization: Bearer ${SLACK_ACCESS_TOKEN}" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "app_id=${SLACK_APP_ID}")

    local ok
    ok=$(echo "$manifest_response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$manifest_response" | jq -r '.error // "unknown error"')
        echo_error "Failed to export manifest: $error"
        return 1
    fi

    local updated_manifest
    updated_manifest=$(echo "$manifest_response" | jq --arg url "$new_url" '
        .manifest.settings.interactivity.is_enabled = true |
        .manifest.settings.interactivity.request_url = $url |
        .manifest
    ')

    local update_response
    update_response=$(curl -s --max-time 30 -X POST "https://slack.com/api/apps.manifest.update" \
        -H "Authorization: Bearer ${SLACK_ACCESS_TOKEN}" \
        -H "Content-Type: application/json" \
        -d "{\"app_id\": \"${SLACK_APP_ID}\", \"manifest\": ${updated_manifest}}")

    ok=$(echo "$update_response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$update_response" | jq -r '.error // "unknown error"')
        echo_error "Failed to update manifest: $error"
        local errors
        errors=$(echo "$update_response" | jq -r '.errors // empty')
        if [[ -n "$errors" ]]; then
            echo_error "Details: $errors"
        fi
        return 1
    fi

    echo_info "Slack Request URL updated to: $new_url"
    return 0
}

# =============================================================================
# Remote relay helpers
# =============================================================================

find_relay_dist() {
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

    # Check installed location first
    if [[ -f "$CLAUDE_DIR/mcp-server-dist/dist/remote-relay.js" ]]; then
        echo "$CLAUDE_DIR/mcp-server-dist/dist/remote-relay.js"
        return 0
    fi

    # Check development location
    if [[ -f "$script_dir/../mcp-server/dist/remote-relay.js" ]]; then
        echo "$script_dir/../mcp-server/dist/remote-relay.js"
        return 0
    fi

    return 1
}

check_relay_running() {
    if curl -s "http://localhost:$RELAY_PORT/health" &>/dev/null; then
        return 0
    fi
    return 1
}

start_relay() {
    local relay_path
    if ! relay_path=$(find_relay_dist); then
        echo_error "Remote relay not found."
        echo_error "Build the MCP server first: cd mcp-server && bun run build"
        exit 1
    fi

    echo_info "Starting remote relay..."
    nohup node "$relay_path" > "$CLAUDE_DIR/remote-relay.log" 2>&1 &
    local relay_pid=$!
    echo "$relay_pid" > "$RELAY_PID_FILE"

    # Wait for relay to start
    for i in {1..10}; do
        if check_relay_running; then
            echo_info "Remote relay started (PID: $relay_pid)"
            return 0
        fi
        sleep 0.5
    done

    echo_error "Remote relay failed to start. Check $CLAUDE_DIR/remote-relay.log"
    exit 1
}

stop_relay() {
    if [[ -f "$RELAY_PID_FILE" ]]; then
        local pid
        pid=$(cat "$RELAY_PID_FILE")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            rm -f "$RELAY_PID_FILE"
            echo_info "Remote relay stopped"
        fi
    fi
}

# =============================================================================
# Idle watchdog (for --background mode)
# =============================================================================

start_watchdog() {
    touch "$ACTIVITY_FILE"

    (
        while true; do
            sleep 300  # Check every 5 minutes

            if [[ ! -f "$ACTIVITY_FILE" ]]; then
                continue
            fi

            local last now
            last=$(stat -c %Y "$ACTIVITY_FILE" 2>/dev/null || echo 0)
            now=$(date +%s)

            if [[ $((now - last)) -gt $IDLE_TIMEOUT ]]; then
                echo "$(date): Idle timeout ($IDLE_TIMEOUT seconds), shutting down" >> "$TUNNEL_LOG"

                if [[ -f "$TUNNEL_PID_FILE" ]]; then
                    local tunnel_pid
                    tunnel_pid=$(cat "$TUNNEL_PID_FILE")
                    kill "$tunnel_pid" 2>/dev/null || true
                    rm -f "$TUNNEL_PID_FILE"
                fi

                stop_relay
                rm -f "$ACTIVITY_FILE"
                rm -f "$WATCHDOG_PID_FILE"
                exit 0
            fi
        done
    ) &
    local watchdog_pid=$!
    echo "$watchdog_pid" > "$WATCHDOG_PID_FILE"
    echo_info "Idle watchdog started (timeout: ${IDLE_TIMEOUT}s)"
}

stop_watchdog() {
    if [[ -f "$WATCHDOG_PID_FILE" ]]; then
        local pid
        pid=$(cat "$WATCHDOG_PID_FILE")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
        fi
        rm -f "$WATCHDOG_PID_FILE"
    fi
}

# =============================================================================
# Start tunnel and get URL
# =============================================================================

start_tunnel_and_get_url() {
    local background="${1:-false}"

    # Check cloudflared installed
    if ! command -v cloudflared &>/dev/null; then
        echo_error "cloudflared not installed."
        echo ""
        echo -e "  Install with:"
        echo -e "    Debian/Ubuntu: See https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/downloads/"
        echo -e "    Or use: curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb && sudo dpkg -i cloudflared.deb"
        exit 1
    fi

    # Kill any existing cloudflared tunnels on our port
    pkill -f "cloudflared tunnel.*localhost:${RELAY_PORT}" 2>/dev/null || true
    rm -f "$TUNNEL_PID_FILE" "$TUNNEL_URL_FILE"
    sleep 0.5

    echo_info "Starting Cloudflare Quick Tunnel..."

    local log_file="$CLAUDE_DIR/.remote-cloudflared.log"
    rm -f "$log_file"

    if [[ "$background" == "true" ]]; then
        nohup cloudflared tunnel --url "http://localhost:$RELAY_PORT" > "$log_file" 2>&1 &
    else
        cloudflared tunnel --url "http://localhost:$RELAY_PORT" > "$log_file" 2>&1 &
    fi
    TUNNEL_PID=$!
    echo "$TUNNEL_PID" > "$TUNNEL_PID_FILE"

    # Wait for URL to appear in logs
    local tunnel_url=""
    for i in {1..30}; do
        if [[ -f "$log_file" ]]; then
            tunnel_url=$(grep -oE 'https://[a-z0-9-]+\.trycloudflare\.com' "$log_file" 2>/dev/null | tail -1 || true)
            if [[ -n "$tunnel_url" ]]; then
                break
            fi
        fi
        sleep 0.5
    done

    if [[ -z "$tunnel_url" ]]; then
        echo_error "Failed to get tunnel URL"
        cat "$log_file" 2>/dev/null | tail -10
        kill "$TUNNEL_PID" 2>/dev/null || true
        rm -f "$TUNNEL_PID_FILE"
        exit 1
    fi

    echo "$tunnel_url" > "$TUNNEL_URL_FILE"
    TUNNEL_URL="$tunnel_url"
    echo_info "Tunnel started: $tunnel_url"
}

# =============================================================================
# --setup: Configure Slack (copy from Mac or manual)
# =============================================================================

cmd_setup() {
    echo ""
    echo -e "${BOLD}Remote Tunnel Setup${NC}"
    echo -e "${DIM}Configure Slack API tokens for button support${NC}"
    echo ""

    # Check dependencies
    if ! command -v jq &>/dev/null; then
        echo_error "jq is required but not installed."
        echo "  Install with: sudo apt install jq"
        exit 1
    fi

    if ! command -v cloudflared &>/dev/null; then
        echo_error "cloudflared is required but not installed."
        echo "  See: https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/downloads/"
        exit 1
    fi

    # Check if config already exists
    if [[ -f "$SLACK_CONFIG_FILE" ]]; then
        echo_info "Slack config already exists at $SLACK_CONFIG_FILE"
        echo ""
        echo -ne "  ${YELLOW}?${NC} Replace existing config? [y/N] "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo_info "Keeping existing config"
            return 0
        fi
    fi

    echo ""
    echo -e "${CYAN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${CYAN}│${NC}  ${BOLD}Option 1: Copy config from Mac (recommended)${NC}              ${CYAN}│${NC}"
    echo -e "${CYAN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  Run this on your Mac:"
    echo -e "    ${BOLD}scp ~/.claude/.slack-config $(hostname):~/.claude/${NC}"
    echo ""
    echo -e "  Or run this here if you have SSH access to Mac:"
    echo -e "    ${BOLD}scp mac:~/.claude/.slack-config ~/.claude/${NC}"
    echo ""
    echo -e "${CYAN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${CYAN}│${NC}  ${BOLD}Option 2: Manual setup${NC}                                     ${CYAN}│${NC}"
    echo -e "${CYAN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  ${CYAN}1.${NC} Go to ${BOLD}https://api.slack.com/apps${NC}"
    echo -e "  ${CYAN}2.${NC} Copy the ${BOLD}App ID${NC} from your app"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Paste your App ID (or Enter to skip): "
    read -r SLACK_APP_ID

    if [[ -z "$SLACK_APP_ID" ]]; then
        echo_warn "Setup skipped. Copy config from Mac or run setup again."
        return 0
    fi

    if [[ ! "$SLACK_APP_ID" =~ ^A[A-Z0-9]+$ ]]; then
        echo_error "Invalid App ID format. Should start with 'A' followed by letters/numbers."
        exit 1
    fi

    echo ""
    echo -e "  ${CYAN}3.${NC} Scroll to ${BOLD}Your App Configuration Tokens${NC} at bottom of page"
    echo -e "  ${CYAN}4.${NC} Generate a token and paste the ${BOLD}Access Token${NC}:"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Access Token: "
    read -r SLACK_ACCESS_TOKEN

    if [[ -z "$SLACK_ACCESS_TOKEN" ]]; then
        echo_error "Access token is required"
        exit 1
    fi

    echo ""
    echo -e "  ${CYAN}5.${NC} Copy the ${BOLD}Refresh Token${NC}:"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Refresh Token: "
    read -r SLACK_REFRESH_TOKEN

    if [[ -z "$SLACK_REFRESH_TOKEN" ]]; then
        echo_error "Refresh token is required"
        exit 1
    fi

    SLACK_TOKEN_EXPIRES=$(($(date +%s) + 43200))
    save_slack_config

    echo ""
    echo_info "Configuration saved to $SLACK_CONFIG_FILE"

    # Also copy slack signing secret if provided
    echo ""
    echo -e "  ${CYAN}6.${NC} (Optional) Your Slack ${BOLD}Signing Secret${NC} for request verification:"
    echo -e "     ${DIM}Found at: Your App → Basic Information → Signing Secret${NC}"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Signing Secret (or Enter to skip): "
    read -r SIGNING_SECRET

    if [[ -n "$SIGNING_SECRET" ]]; then
        echo "$SIGNING_SECRET" > "$CLAUDE_DIR/slack-signing-secret"
        chmod 600 "$CLAUDE_DIR/slack-signing-secret"
        echo_info "Signing secret saved"
    fi

    echo ""
    echo -e "${GREEN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${GREEN}│${NC}  ${GREEN}✓${NC} ${BOLD}Setup Complete!${NC}                                          ${GREEN}│${NC}"
    echo -e "${GREEN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  ${BOLD}To start the tunnel:${NC}"
    echo -e "    remote-tunnel"
    echo ""
}

# =============================================================================
# --background: Start tunnel in background
# =============================================================================

check_tunnel_running() {
    if [[ -f "$TUNNEL_PID_FILE" ]]; then
        local pid
        pid=$(cat "$TUNNEL_PID_FILE")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
    fi
    return 1
}

cmd_background() {
    if ! load_slack_config; then
        echo_error "Slack not configured. Run: remote-tunnel --setup"
        exit 1
    fi

    local relay_was_running=false
    local tunnel_was_running=false
    local need_slack_update=false

    # Check relay status
    if check_relay_running; then
        relay_was_running=true
        echo_info "Remote relay already running"
    fi

    # Check tunnel status
    if check_tunnel_running; then
        tunnel_was_running=true
        echo_info "Tunnel already running"
    fi

    # If both running, nothing to do
    if [[ "$relay_was_running" == "true" && "$tunnel_was_running" == "true" ]]; then
        echo_info "All services already running"
        cmd_status
        return 0
    fi

    # Start relay if needed
    if [[ "$relay_was_running" == "false" ]]; then
        start_relay
    fi

    # Start tunnel if needed
    if [[ "$tunnel_was_running" == "false" ]]; then
        start_tunnel_and_get_url "true"
        need_slack_update=true
    fi

    # Update Slack Request URL if we started a new tunnel
    if [[ "$need_slack_update" == "true" ]]; then
        if ! update_slack_request_url "${TUNNEL_URL}/slack/actions"; then
            echo_warn "Failed to update Slack, but tunnel is running"
            echo_warn "Manually set Request URL to: ${TUNNEL_URL}/slack/actions"
        fi
    fi

    # Start/restart idle watchdog
    stop_watchdog 2>/dev/null || true
    start_watchdog

    touch "$ACTIVITY_FILE"

    echo_info "Remote tunnel running in background (PID: $TUNNEL_PID)"
}

# =============================================================================
# --stop: Stop background tunnel
# =============================================================================

cmd_stop() {
    local stopped=false

    stop_watchdog && stopped=true

    if [[ -f "$TUNNEL_PID_FILE" ]]; then
        local pid
        pid=$(cat "$TUNNEL_PID_FILE")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            stopped=true
        fi
        rm -f "$TUNNEL_PID_FILE"
    fi

    # Kill any remaining cloudflared tunnels on our port
    local stale_count=0
    while IFS= read -r pid; do
        if [[ -n "$pid" ]]; then
            kill "$pid" 2>/dev/null || true
            ((stale_count++)) || true
        fi
    done < <(pgrep -f "cloudflared tunnel.*localhost:${RELAY_PORT}" 2>/dev/null || true)

    if [[ "$stale_count" -gt 0 || "$stopped" == "true" ]]; then
        echo_info "Tunnel stopped"
        stopped=true
    fi

    rm -f "$TUNNEL_URL_FILE"

    stop_relay && stopped=true

    rm -f "$ACTIVITY_FILE"

    if [[ "$stopped" == "true" ]]; then
        echo_info "All services stopped"
    else
        echo_info "No services were running"
    fi
}

# =============================================================================
# --status: Check tunnel status
# =============================================================================

cmd_status() {
    echo ""
    echo -e "${BOLD}Remote Tunnel Status${NC}"
    echo ""

    # Check Slack config
    if [[ -f "$SLACK_CONFIG_FILE" ]]; then
        load_slack_config
        echo -e "  Slack App:  ${CYAN}$SLACK_APP_ID${NC}"
        if is_token_expired; then
            echo -e "  Token:      ${YELLOW}Expired (will refresh on next use)${NC}"
        else
            echo -e "  Token:      ${GREEN}Valid${NC}"
        fi
    else
        echo -e "  Slack:      ${YELLOW}Not configured${NC} (run: remote-tunnel --setup)"
    fi
    echo ""

    # Check relay
    if check_relay_running; then
        local relay_pid=""
        if [[ -f "$RELAY_PID_FILE" ]]; then
            relay_pid=$(cat "$RELAY_PID_FILE")
        fi
        echo -e "  Relay:      ${GREEN}Running${NC}${relay_pid:+ (PID: $relay_pid)}"
    else
        echo -e "  Relay:      ${YELLOW}Stopped${NC}"
    fi

    # Check tunnel
    if [[ -f "$TUNNEL_PID_FILE" ]]; then
        local pid
        pid=$(cat "$TUNNEL_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "  Tunnel:     ${GREEN}Running${NC} (PID: $pid)"
            if [[ -f "$TUNNEL_URL_FILE" ]]; then
                local url
                url=$(cat "$TUNNEL_URL_FILE")
                echo -e "  URL:        ${CYAN}$url/slack/actions${NC}"
            fi
        else
            echo -e "  Tunnel:     ${YELLOW}Stopped${NC} (stale PID file)"
        fi
    else
        echo -e "  Tunnel:     ${YELLOW}Stopped${NC}"
    fi

    # Check watchdog
    if [[ -f "$WATCHDOG_PID_FILE" ]]; then
        local pid
        pid=$(cat "$WATCHDOG_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "  Watchdog:   ${GREEN}Running${NC}"
        else
            echo -e "  Watchdog:   ${YELLOW}Stopped${NC}"
        fi
    else
        echo -e "  Watchdog:   ${YELLOW}Stopped${NC}"
    fi

    # Check Mac tunnel URL
    if [[ -f "$CLAUDE_DIR/.mac-tunnel-url" ]]; then
        local mac_url
        mac_url=$(cat "$CLAUDE_DIR/.mac-tunnel-url")
        echo -e "  Mac URL:    ${DIM}$mac_url${NC}"
    fi

    # Check last activity
    if [[ -f "$ACTIVITY_FILE" ]]; then
        local last now elapsed
        last=$(stat -c %Y "$ACTIVITY_FILE" 2>/dev/null || echo 0)
        now=$(date +%s)
        elapsed=$((now - last))
        local remaining=$((IDLE_TIMEOUT - elapsed))
        if [[ $remaining -gt 0 ]]; then
            echo -e "  Idle timer: ${DIM}${remaining}s until auto-stop${NC}"
        fi
    fi

    echo ""
}

# =============================================================================
# Default: Interactive mode
# =============================================================================

cmd_interactive() {
    echo ""
    echo -e "${BOLD}Remote Tunnel for Claude Slack Buttons${NC}"
    echo -e "${DIM}Receive Slack button clicks when your Mac is closed${NC}"
    echo ""

    if ! load_slack_config; then
        echo_warn "Slack not configured yet."
        echo ""
        echo -ne "  ${YELLOW}?${NC} Run setup now? [Y/n] "
        read -r response
        if [[ "$response" =~ ^[Nn]$ ]]; then
            exit 0
        fi
        cmd_setup
        load_slack_config
    fi

    # Start relay if not running
    if ! check_relay_running; then
        start_relay
    fi

    # Cleanup on exit
    cleanup() {
        echo ""
        echo_info "Shutting down..."
        if [[ -n "${TUNNEL_PID:-}" ]]; then
            kill "$TUNNEL_PID" 2>/dev/null || true
        fi
        stop_relay
        rm -f "$TUNNEL_PID_FILE" "$TUNNEL_URL_FILE"
    }
    trap cleanup EXIT INT TERM

    # Start tunnel
    start_tunnel_and_get_url "false"

    # Update Slack Request URL
    if update_slack_request_url "${TUNNEL_URL}/slack/actions"; then
        echo ""
        echo -e "${GREEN}╭──────────────────────────────────────────────────────────────╮${NC}"
        echo -e "${GREEN}│${NC}  ${GREEN}✓${NC} ${BOLD}Slack Request URL updated!${NC}                               ${GREEN}│${NC}"
        echo -e "${GREEN}╰──────────────────────────────────────────────────────────────╯${NC}"
        echo ""
        echo -e "  Tunnel URL: ${CYAN}${TUNNEL_URL}/slack/actions${NC}"
        echo ""
        echo -e "  ${DIM}Slack buttons will now send input to this Linux server.${NC}"
        echo -e "  ${DIM}Keep this running. Press Ctrl+C to stop.${NC}"
        echo ""
        echo -e "  ${BOLD}Note:${NC} Focus button won't switch windows (Mac not involved)."
        echo -e "  ${DIM}Only 1/2/Continue/Push buttons work.${NC}"
    else
        echo ""
        echo -e "${YELLOW}╭──────────────────────────────────────────────────────────────╮${NC}"
        echo -e "${YELLOW}│${NC}  ${YELLOW}!${NC} ${BOLD}Could not auto-update Slack${NC}                               ${YELLOW}│${NC}"
        echo -e "${YELLOW}╰──────────────────────────────────────────────────────────────╯${NC}"
        echo ""
        echo -e "  Tunnel URL: ${CYAN}${TUNNEL_URL}/slack/actions${NC}"
        echo ""
        echo -e "  ${BOLD}Manually update in Slack:${NC}"
        echo -e "  ${CYAN}1.${NC} Go to ${BOLD}https://api.slack.com/apps/${SLACK_APP_ID}${NC}"
        echo -e "  ${CYAN}2.${NC} Click ${BOLD}Interactivity & Shortcuts${NC}"
        echo -e "  ${CYAN}3.${NC} Update ${BOLD}Request URL${NC} to the URL above"
        echo -e "  ${CYAN}4.${NC} Click ${BOLD}Save Changes${NC}"
    fi
    echo ""

    # Keep running until interrupted
    wait "$TUNNEL_PID" 2>/dev/null || true
}

# =============================================================================
# Main
# =============================================================================

case "${1:-}" in
    --setup)
        cmd_setup
        ;;
    --background)
        cmd_background
        ;;
    --stop)
        cmd_stop
        ;;
    --status)
        cmd_status
        ;;
    --help|-h)
        echo "Usage: remote-tunnel [command]"
        echo ""
        echo "Commands:"
        echo "  (none)        Interactive mode - start tunnel in foreground"
        echo "  --setup       Configure Slack API tokens (copy from Mac or manual)"
        echo "  --background  Start tunnel in background"
        echo "  --stop        Stop background tunnel"
        echo "  --status      Check tunnel status"
        echo ""
        echo "This runs on Linux servers to receive Slack button clicks when your"
        echo "Mac is closed. Auto-detects if Mac is reachable and proxies when possible."
        echo ""
        echo "Workflow:"
        echo "  1. Copy Slack config from Mac: scp mac:~/.claude/.slack-config ~/.claude/"
        echo "  2. Start tunnel: remote-tunnel --background"
        echo "  3. In Claude: /slack-notify"
        echo ""
        ;;
    "")
        cmd_interactive
        ;;
    *)
        echo_error "Unknown command: $1"
        echo "Run: remote-tunnel --help"
        exit 1
        ;;
esac
