#!/bin/bash
# Claude Slack Notifier - Multi-instance aware with clickable focus buttons

CLAUDE_DIR="${HOME}/.claude"
WEBHOOK_FILE="${CLAUDE_DIR}/slack-webhook-url"
SLACK_CONFIG="${CLAUDE_DIR}/.slack-config"
THREADS_DIR="${CLAUDE_DIR}/threads"
INSTANCES_DIR="${CLAUDE_DIR}/instances"
LINKS_DIR="${CLAUDE_DIR}/links"
MIN_DURATION="${CLAUDE_NOTIFY_MIN_SECONDS:-30}"

# Get instance ID - MUST be set by hooks via CLAUDE_INSTANCE_ID
# Never fall back to $PPID as it's unreliable across sessions
if [[ -z "$CLAUDE_INSTANCE_ID" ]]; then
    # For commands that don't need instance ID (like 'update', 'status'), allow empty
    # For notification/register commands, the calling hook must set CLAUDE_INSTANCE_ID
    INSTANCE_ID=""
else
    INSTANCE_ID="$CLAUDE_INSTANCE_ID"
fi

# Validate INSTANCE_ID to prevent path traversal attacks (if set)
# Only allow alphanumeric characters, underscore, and hyphen
if [[ -n "$INSTANCE_ID" && ! "$INSTANCE_ID" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    echo "Error: Invalid INSTANCE_ID format" >&2
    exit 1
fi

# Instance file path (may be empty if INSTANCE_ID not set)
INSTANCE_FILE=""
[[ -n "$INSTANCE_ID" ]] && INSTANCE_FILE="${INSTANCES_DIR}/${INSTANCE_ID}.json"
TIMESTAMP_FILE="/tmp/claude-prompt-start-${INSTANCE_ID}"

# -----------------------------------------------------------------------------
# Generate a random 4-word instance name (e.g., golden-shark-azure-coffee)
# -----------------------------------------------------------------------------
generate_instance_name() {
    local ADJECTIVES=("red" "blue" "green" "purple" "orange" "silver" "golden" "cosmic" "swift" "bright" "dark" "wild" "calm" "bold" "quick")
    local NOUNS=("wolf" "hawk" "bear" "lion" "tiger" "eagle" "falcon" "dragon" "phoenix" "raven" "fox" "panther" "cobra" "shark" "storm")
    local COLORS=("amber" "coral" "jade" "ruby" "onyx" "ivory" "copper" "bronze" "teal" "indigo" "crimson" "azure" "scarlet" "violet" "emerald")
    local ITEMS=("coffee" "thunder" "shadow" "crystal" "ember" "breeze" "river" "mountain" "forest" "ocean" "sunrise" "comet" "glacier" "canyon" "meadow")
    echo "${ADJECTIVES[$RANDOM % ${#ADJECTIVES[@]}]}-${NOUNS[$RANDOM % ${#NOUNS[@]}]}-${COLORS[$RANDOM % ${#COLORS[@]}]}-${ITEMS[$RANDOM % ${#ITEMS[@]}]}"
}

# -----------------------------------------------------------------------------
# Sanitize hostname for use as filename (session persistence)
# Converts special chars to underscores, truncates long names with hash suffix
# -----------------------------------------------------------------------------
sanitize_hostname() {
    local hostname="$1"
    local safe_host
    # Replace all non-alphanumeric chars (except _ and -) with underscore
    safe_host=$(echo "$hostname" | sed 's/[^a-zA-Z0-9_-]/_/g')
    # Truncate long hostnames (>50 chars) with hash suffix
    if [[ ${#safe_host} -gt 50 ]]; then
        local hash
        hash=$(echo "$hostname" | md5sum | head -c 8)
        safe_host="${safe_host:0:50}_${hash}"
    fi
    echo "$safe_host"
}

# -----------------------------------------------------------------------------
# Session management helpers for multi-session remote support
# -----------------------------------------------------------------------------

# Acquire an exclusive lock for session operations on a host
# Args: $1 = host directory path
# Global lock state for release function
_LOCK_TYPE=""
_LOCK_DIR=""

# Returns: 0 on success, exits on failure
acquire_session_lock() {
    local host_dir="$1"
    mkdir -p "$host_dir"
    local lockfile="$host_dir/.lock"

    # Cross-platform locking: use flock if available, mkdir-based otherwise
    if command -v flock &>/dev/null; then
        # Linux (and some other systems): use flock
        _LOCK_TYPE="flock"
        exec 200>"$lockfile"
        if ! flock -n 200; then
            echo "Another remote command is running for this host. Please wait." >&2
            exit 1
        fi
    else
        # macOS, Windows (Git Bash/MSYS2), others: use mkdir-based locking
        _LOCK_TYPE="mkdir"
        _LOCK_DIR="$host_dir/.lockdir"
        if ! mkdir "$_LOCK_DIR" 2>/dev/null; then
            # Check if lock is stale (older than 1 hour)
            if [[ -d "$_LOCK_DIR" ]]; then
                local lock_age
                # stat syntax differs: -f %m for macOS/BSD, -c %Y for GNU
                if [[ "$(uname)" == "Darwin" ]]; then
                    lock_age=$(($(date +%s) - $(stat -f %m "$_LOCK_DIR" 2>/dev/null || echo 0)))
                else
                    lock_age=$(($(date +%s) - $(stat -c %Y "$_LOCK_DIR" 2>/dev/null || echo 0)))
                fi
                if [[ $lock_age -gt 3600 ]]; then
                    rm -rf "$_LOCK_DIR"
                    mkdir "$_LOCK_DIR" 2>/dev/null || {
                        echo "Another remote command is running for this host. Please wait." >&2
                        exit 1
                    }
                else
                    echo "Another remote command is running for this host. Please wait." >&2
                    exit 1
                fi
            fi
        fi
        # Set up cleanup trap (backup, release_session_lock is preferred)
        trap 'rm -rf "$_LOCK_DIR" 2>/dev/null' EXIT
    fi
}

# Release the session lock (call before exec to avoid holding lock during SSH)
release_session_lock() {
    if [[ "$_LOCK_TYPE" == "flock" ]]; then
        # Close the file descriptor to release flock
        exec 200>&-
    elif [[ "$_LOCK_TYPE" == "mkdir" && -n "$_LOCK_DIR" ]]; then
        rm -rf "$_LOCK_DIR" 2>/dev/null
        # Clear trap since we've already cleaned up
        trap - EXIT
    fi
    _LOCK_TYPE=""
    _LOCK_DIR=""
}

# Migrate from old single-file format to new directory format
# Args: $1 = sessions base dir, $2 = safe hostname
# Returns: 0 on success (or already migrated/no old file)
migrate_session_format() {
    local sessions_dir="$1"
    local safe_host="$2"
    local old_file="$sessions_dir/${safe_host}.json"
    local new_dir="$sessions_dir/${safe_host}"

    # Skip if already migrated or no old file
    [[ -d "$new_dir" ]] && return 0
    [[ ! -f "$old_file" ]] && return 0

    # Extract instance name from old file
    local instance_name
    instance_name=$(grep -o '"instance_name": *"[^"]*"' "$old_file" | cut -d'"' -f4)
    [[ -z "$instance_name" ]] && instance_name="migrated-session"

    # Atomic: create temp dir, copy, rename, then remove old
    local tmp_dir="$sessions_dir/.migrate-${safe_host}-$$"
    mkdir -p "$tmp_dir" || return 1
    cp "$old_file" "$tmp_dir/${instance_name}.json" || { rm -rf "$tmp_dir"; return 1; }
    mv "$tmp_dir" "$new_dir" || { rm -rf "$tmp_dir"; return 1; }
    rm -f "$old_file"
    return 0
}

# Query remote host for active tmux sessions
# Args: $1 = hostname
# Returns: 0 with session names on stdout, 1 on error
query_remote_sessions() {
    local host="$1"
    local output status
    output=$(ssh -o ConnectTimeout=5 -o BatchMode=yes "$host" \
        "tmux list-sessions -F '#{session_name}'" 2>&1)
    status=$?

    if [[ $status -ne 0 ]]; then
        if [[ "$output" == *"no server running"* ]] || [[ "$output" == *"no sessions"* ]]; then
            # No tmux sessions - this is fine
            echo ""
            return 0
        elif [[ "$output" == *"Permission denied"* ]]; then
            echo "Error: SSH authentication failed for $host" >&2
            return 1
        elif [[ "$output" == *"Connection refused"* ]] || [[ "$output" == *"timed out"* ]]; then
            echo "Error: Cannot connect to $host" >&2
            return 1
        fi
        # Unknown error - show it
        echo "SSH error: $output" >&2
        return 1
    fi
    echo "$output"
}

# Check if a specific tmux session exists on remote
# Args: $1 = hostname, $2 = session name
# Returns: 0 if exists, 1 if not
check_session_exists() {
    local host="$1" session="$2"
    ssh -o ConnectTimeout=5 -o BatchMode=yes "$host" \
        "tmux has-session -t '$session'" 2>/dev/null
}

# Validate session name format
# Args: $1 = session name
# Returns: 0 if valid, exits with error if invalid
validate_session_name() {
    local name="$1"
    if [[ ! "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        echo "Error: Session name can only contain letters, numbers, underscores, and hyphens" >&2
        exit 1
    fi
    if [[ ${#name} -gt 50 ]]; then
        echo "Error: Session name too long (max 50 characters)" >&2
        exit 1
    fi
}

# -----------------------------------------------------------------------------
# Interactive menu with arrow key navigation
# -----------------------------------------------------------------------------

# Color palette for session names (12 distinct colors)
MENU_COLORS=(
    $'\033[38;5;39m'   # Bright blue
    $'\033[38;5;208m'  # Orange
    $'\033[38;5;42m'   # Green
    $'\033[38;5;205m'  # Pink
    $'\033[38;5;226m'  # Yellow
    $'\033[38;5;141m'  # Purple
    $'\033[38;5;81m'   # Cyan
    $'\033[38;5;196m'  # Red
    $'\033[38;5;118m'  # Lime
    $'\033[38;5;213m'  # Magenta
    $'\033[38;5;220m'  # Gold
    $'\033[38;5;51m'   # Aqua
)
MENU_RESET=$'\033[0m'
MENU_DIM=$'\033[2m'
MENU_BOLD=$'\033[1m'
MENU_REVERSE=$'\033[7m'

# Get a consistent color for a session name (hash-based)
get_session_color() {
    local session="$1"
    local hash=0
    for ((i = 0; i < ${#session}; i++)); do
        hash=$(( (hash * 31 + $(printf '%d' "'${session:$i:1}")) % ${#MENU_COLORS[@]} ))
    done
    echo "${MENU_COLORS[$hash]}"
}

# Draw the interactive menu
# Args: $1 = selected index, $2+ = menu items (format: "label|description")
draw_menu() {
    local selected="$1"
    shift
    local -a items=("$@")
    local total=${#items[@]}

    # Move cursor up to redraw (if not first draw)
    if [[ -n "$MENU_DRAWN" ]]; then
        printf '\033[%dA' "$((total + 1))" >&2
    fi
    MENU_DRAWN=1

    local i=0
    for item in "${items[@]}"; do
        local label="${item%%|*}"
        local desc="${item#*|}"
        local color=""
        local prefix="   "
        local suffix=""

        # Get color for this item (except "New session")
        if [[ "$label" != "New session" ]]; then
            color=$(get_session_color "$label")
        fi

        if [[ $i -eq $selected ]]; then
            prefix="${MENU_BOLD}${MENU_REVERSE} › "
            suffix=" ${MENU_RESET}"
            if [[ -n "$color" ]]; then
                printf '%s%s%s%s%s %s%s%s\n' "$prefix" "$color" "$label" "$MENU_RESET" "$MENU_REVERSE" "$MENU_DIM" "$desc" "$suffix" >&2
            else
                printf '%s%s %s%s%s\n' "$prefix" "$label" "$MENU_DIM" "$desc" "$suffix" >&2
            fi
        else
            if [[ -n "$color" ]]; then
                printf '%s%s%s%s  %s%s%s\n' "$prefix" "$color" "$label" "$MENU_RESET" "$MENU_DIM" "$desc" "$MENU_RESET" >&2
            else
                printf '%s%s  %s%s%s\n' "$prefix" "$label" "$MENU_DIM" "$desc" "$MENU_RESET" >&2
            fi
        fi
        ((i++))
    done

    printf '%s↑↓ navigate  enter select  n new%s\n' "$MENU_DIM" "$MENU_RESET" >&2
}

# Interactive menu with arrow key navigation
# Args: menu items (format: "label|description")
# Returns: selected index (0-based), or "new" for new session
interactive_menu() {
    local -a items=("$@")
    local total=${#items[@]}
    local selected=0

    # Save terminal settings and ensure proper mode for arrow key reading
    # This fixes issues after SSH disconnect where terminal state is corrupted
    local saved_stty
    saved_stty=$(stty -g 2>/dev/null)
    # Reset terminal to sane state first, then configure for raw input
    stty sane 2>/dev/null
    stty -icanon -echo min 1 2>/dev/null  # Disable line buffering, echo; read 1 char at a time

    # Hide cursor
    printf '\033[?25l' >&2

    # Ensure cursor and terminal settings are restored on exit
    trap 'printf "\033[?25h" >&2; stty "$saved_stty" 2>/dev/null' RETURN

    # Initial draw
    MENU_DRAWN=""
    draw_menu "$selected" "${items[@]}"

    # Read keys
    while true; do
        # Read a single character (with escape sequence handling)
        local key
        IFS= read -rsn1 key

        case "$key" in
            $'\x1b')  # Escape sequence (arrow keys)
                # Note: -t 0.1 not supported on bash 3.x (macOS default)
                # Suppress stderr and use fallback for compatibility
                read -rsn2 -t 0.1 rest 2>/dev/null || read -rsn2 rest
                case "$rest" in
                    '[A')  # Up arrow
                        ((selected > 0)) && ((selected--))
                        ;;
                    '[B')  # Down arrow
                        ((selected < total - 1)) && ((selected++))
                        ;;
                esac
                ;;
            'k'|'K')  # Vim up
                ((selected > 0)) && ((selected--))
                ;;
            'j'|'J')  # Vim down
                ((selected < total - 1)) && ((selected++))
                ;;
            'n'|'N')  # New session
                printf '\033[?25h' >&2  # Show cursor
                echo "new"
                return
                ;;
            '')  # Enter key
                printf '\033[?25h' >&2  # Show cursor
                echo "$selected"
                return
                ;;
            'q'|'Q'|$'\x03')  # Quit (q or Ctrl+C)
                printf '\033[?25h' >&2  # Show cursor
                echo "quit"
                return
                ;;
        esac

        draw_menu "$selected" "${items[@]}"
    done
}

# Read and validate menu choice from user (legacy fallback)
# Args: $1 = max number option
# Returns: number (1-max), "new", or exits on EOF
read_menu_choice() {
    local max="$1"
    local choice
    while true; do
        read -r choice
        if [[ "$choice" == "n" || "$choice" == "N" ]]; then
            echo "new"
            return
        fi
        if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= max )); then
            echo "$choice"
            return
        fi
        if [[ -z "$choice" ]]; then
            echo "1"  # default
            return
        fi
        echo -n "Invalid. Enter 1-${max} or 'n': " >&2
    done
}

# Show session selection menu and get user's choice
# Args: $1 = host_dir, $2 = hostname, $3 = array of live session names (space-separated)
# Returns: selected session name on stdout
show_session_menu() {
    local host_dir="$1"
    local hostname="$2"
    shift 2
    local -a live_sessions=("$@")

    # Build array of sessions with timestamps for sorting
    local -a session_info=()
    for session in "${live_sessions[@]}"; do
        local session_file="$host_dir/${session}.json"
        local last_connected=""
        if [[ -f "$session_file" ]]; then
            last_connected=$(grep -o '"last_connected": *"[^"]*"' "$session_file" 2>/dev/null | cut -d'"' -f4)
        fi
        [[ -z "$last_connected" ]] && last_connected="1970-01-01T00:00:00"
        session_info+=("$last_connected|$session")
    done

    # Sort by timestamp (most recent first)
    local -a sorted_sessions=()
    while IFS= read -r line; do
        sorted_sessions+=("${line#*|}")
    done < <(printf '%s\n' "${session_info[@]}" | sort -r)

    # Limit to 10 sessions
    local max_show=10
    if [[ ${#sorted_sessions[@]} -gt $max_show ]]; then
        sorted_sessions=("${sorted_sessions[@]:0:$max_show}")
    fi

    # Build menu items with descriptions (session|description format)
    local -a menu_items=()
    for session in "${sorted_sessions[@]}"; do
        local session_file="$host_dir/${session}.json"
        local last_connected_str=""
        if [[ -f "$session_file" ]]; then
            local last_ts
            last_ts=$(grep -o '"last_connected": *"[^"]*"' "$session_file" 2>/dev/null | cut -d'"' -f4)
            if [[ -n "$last_ts" ]]; then
                # Calculate relative time
                local last_epoch now_epoch diff_secs
                # Strip timezone suffix for BSD date (take first 19 chars: YYYY-MM-DDTHH:MM:SS)
                local ts_no_tz="${last_ts:0:19}"
                last_epoch=$(date -d "$last_ts" +%s 2>/dev/null || date -j -f "%Y-%m-%dT%H:%M:%S" "$ts_no_tz" +%s 2>/dev/null)
                now_epoch=$(date +%s)
                if [[ -n "$last_epoch" ]]; then
                    diff_secs=$((now_epoch - last_epoch))
                    if [[ $diff_secs -lt 60 ]]; then
                        last_connected_str="connected just now"
                    elif [[ $diff_secs -lt 3600 ]]; then
                        last_connected_str="connected $((diff_secs / 60)) min ago"
                    elif [[ $diff_secs -lt 86400 ]]; then
                        last_connected_str="connected $((diff_secs / 3600)) hours ago"
                    else
                        last_connected_str="connected $((diff_secs / 86400)) days ago"
                    fi
                fi
            fi
        fi
        menu_items+=("${session}|${last_connected_str}")
    done

    # Add "New session" as the last option
    menu_items+=("New session|start a fresh session")

    # Display header
    echo "" >&2
    printf '%sSessions on %s%s%s:%s\n' "$MENU_BOLD" "$MENU_DIM" "$hostname" "$MENU_RESET" "$MENU_RESET" >&2
    echo "" >&2

    # Run interactive menu
    local choice
    choice=$(interactive_menu "${menu_items[@]}")

    # "New session" is the last item in menu_items (index = number of sessions)
    local new_session_index=${#sorted_sessions[@]}

    case "$choice" in
        new)
            echo "" >&2
            return 1  # Signal to create new session
            ;;
        quit)
            echo "" >&2
            exit 0
            ;;
        "$new_session_index")
            # Selected "New session" from the menu
            echo "" >&2
            return 1  # Signal to create new session
            ;;
        *)
            # Return selected session name on stdout
            echo "${sorted_sessions[$choice]}"
            return 0
            ;;
    esac
}

# Clean up dead sessions (sessions that no longer exist on remote)
# Args: $1 = host_dir, $2 = array of dead session names
cleanup_dead_sessions() {
    local host_dir="$1"
    shift
    local -a dead_sessions=("$@")

    for session in "${dead_sessions[@]}"; do
        rm -f "$host_dir/${session}.json"
    done
}

# -----------------------------------------------------------------------------
# Detect terminal environment and build focus URL
# Sets: TERM_TYPE, TERM_TARGET, FOCUS_URL
# -----------------------------------------------------------------------------
# URL encode a string (encode all non-alphanumeric except - _ . ~)
url_encode() {
    local string="$1"
    local length="${#string}"
    local encoded=""
    local c
    for (( i = 0; i < length; i++ )); do
        c="${string:i:1}"
        case "$c" in
            [a-zA-Z0-9._~-]) encoded+="$c" ;;
            *) encoded+=$(printf '%%%02X' "'$c") ;;
        esac
    done
    echo "$encoded"
}

# Escape string for safe embedding in JSON
# Handles: backslash, double quote, newline, carriage return, tab
json_escape() {
    local str="$1"
    str="${str//\\/\\\\}"      # Escape backslashes first
    str="${str//\"/\\\"}"      # Escape double quotes
    str="${str//$'\n'/\\n}"    # Escape newlines
    str="${str//$'\r'/\\r}"    # Escape carriage returns
    str="${str//$'\t'/\\t}"    # Escape tabs
    echo "$str"
}

# Convert standard markdown to Slack mrkdwn format
# - **bold** → *bold* (Slack uses single asterisk for bold)
# - Preserves _italic_ (same in both formats)
# - Preserves `code` (same in both formats)
markdown_to_mrkdwn() {
    local str="$1"
    # Convert **bold** to *bold* (standard markdown bold → slack bold)
    # Uses sed with extended regex
    echo "$str" | sed -E 's/\*\*([^*]+)\*\*/*\1*/g'
}

# Check if MCP server is running (for hybrid button support)
# Checks: 1) PID file with valid process, 2) Health endpoint responds
is_mcp_server_running() {
    local pid_file="${CLAUDE_DIR}/.mcp-server.pid"
    local port_file="${CLAUDE_DIR}/.mcp-server.port"
    local port="${MCP_SERVER_PORT:-8463}"

    # Check PID file first (fastest)
    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file" 2>/dev/null)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
    fi

    # Check port file for custom port
    if [[ -f "$port_file" ]]; then
        port=$(cat "$port_file" 2>/dev/null)
    fi

    # Check if health endpoint responds (catches servers started without PID file)
    if curl -sf "http://localhost:${port}/health" --max-time 1 >/dev/null 2>&1; then
        return 0
    fi

    return 1
}

# Check local-tunnel status
# Returns: "running:URL", "mcp_only", "tunnel_only:URL", "stopped"
check_local_tunnel_status() {
    local mcp_running=false
    local tunnel_running=false
    local tunnel_url=""

    # Check MCP health on port 8463
    if curl -sf "http://localhost:8463/health" --max-time 1 >/dev/null 2>&1; then
        mcp_running=true
    fi

    # Check Tailscale Funnel first
    if command -v tailscale &>/dev/null && tailscale status &>/dev/null 2>&1; then
        tunnel_url=$(tailscale funnel status --json 2>/dev/null | jq -r '.Web | keys[0] // empty' 2>/dev/null)
        if [[ -n "$tunnel_url" ]]; then
            tunnel_running=true
        fi
    fi

    # Fall back to localtunnel PID file check
    if [[ "$tunnel_running" == "false" ]]; then
        local pid_file="${CLAUDE_DIR}/.tunnel.pid"
        if [[ -f "$pid_file" ]]; then
            local pid
            pid=$(cat "$pid_file" 2>/dev/null)
            if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                tunnel_running=true
                # Try to get URL from tunnel URL file
                if [[ -f "${CLAUDE_DIR}/.tunnel-url" ]]; then
                    tunnel_url=$(cat "${CLAUDE_DIR}/.tunnel-url" 2>/dev/null)
                fi
            fi
        fi
    fi

    if [[ "$mcp_running" == "true" && "$tunnel_running" == "true" ]]; then
        echo "running:${tunnel_url}"
    elif [[ "$mcp_running" == "true" ]]; then
        echo "mcp_only"
    elif [[ "$tunnel_running" == "true" ]]; then
        echo "tunnel_only:${tunnel_url}"
    else
        echo "stopped"
    fi
}

# Check remote-tunnel status
# Returns: "running:URL", "relay_only", "tunnel_only:URL", "stopped"
check_remote_tunnel_status() {
    local relay_running=false
    local tunnel_running=false
    local tunnel_url=""

    # Check relay health on port 8464
    if curl -sf "http://localhost:8464/health" --max-time 1 >/dev/null 2>&1; then
        relay_running=true
    fi

    # Check Tailscale Funnel first
    if command -v tailscale &>/dev/null && tailscale status &>/dev/null 2>&1; then
        tunnel_url=$(tailscale funnel status --json 2>/dev/null | jq -r '.Web | keys[0] // empty' 2>/dev/null)
        if [[ -n "$tunnel_url" ]]; then
            tunnel_running=true
        fi
    fi

    # Fall back to remote-tunnel PID file check
    if [[ "$tunnel_running" == "false" ]]; then
        local pid_file="${CLAUDE_DIR}/.remote-tunnel.pid"
        if [[ -f "$pid_file" ]]; then
            local pid
            pid=$(cat "$pid_file" 2>/dev/null)
            if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                tunnel_running=true
                # Try to get URL from tunnel URL file
                if [[ -f "${CLAUDE_DIR}/.remote-tunnel-url" ]]; then
                    tunnel_url=$(cat "${CLAUDE_DIR}/.remote-tunnel-url" 2>/dev/null)
                fi
            fi
        fi
    fi

    if [[ "$relay_running" == "true" && "$tunnel_running" == "true" ]]; then
        echo "running:${tunnel_url}"
    elif [[ "$relay_running" == "true" ]]; then
        echo "relay_only"
    elif [[ "$tunnel_running" == "true" ]]; then
        echo "tunnel_only:${tunnel_url}"
    else
        echo "stopped"
    fi
}

# Wait for tunnel to become healthy
# Args: $1 = status function name, $2 = timeout in seconds (default 30)
# Returns: 0 on success (prints URL), 1 on timeout
wait_for_tunnel() {
    local status_func="$1"
    local timeout="${2:-30}"
    local elapsed=0

    while [[ $elapsed -lt $timeout ]]; do
        local status
        status=$($status_func)

        if [[ "$status" == running:* ]]; then
            # Extract URL after "running:"
            echo "${status#running:}"
            return 0
        fi

        sleep 1
        ((elapsed++))
    done

    return 1
}

# -----------------------------------------------------------------------------
# Update command - update scripts from repo
# Usage: claude-slack-notify update [--no-pull]
# -----------------------------------------------------------------------------
if [[ "$1" == "update" ]]; then
    REPO_PATH_FILE="${CLAUDE_DIR}/.repo-path"
    DO_PULL="1"  # Pull by default

    if [[ "$2" == "--no-pull" ]]; then
        DO_PULL=""
    fi

    # Find repo path
    REPO_PATH=""
    if [[ -f "$REPO_PATH_FILE" ]]; then
        REPO_PATH=$(cat "$REPO_PATH_FILE" 2>/dev/null)
    fi

    # Validate repo path
    if [[ -z "$REPO_PATH" || ! -d "$REPO_PATH" || ! -f "$REPO_PATH/bin/claude-slack-notify" ]]; then
        echo "Error: Repo path not found or invalid." >&2
        echo "" >&2
        echo "Run install.sh from the repo directory first to set the path:" >&2
        echo "  cd /path/to/claude-slack-notify && ./install.sh --update" >&2
        exit 1
    fi

    echo "╭─────────────────────────────────────────────────────────────╮"
    echo "│  Updating Claude Slack Notify                               │"
    echo "╰─────────────────────────────────────────────────────────────╯"
    echo ""
    echo "  Repo: $REPO_PATH"
    echo ""

    # Git pull (default behavior)
    if [[ -n "$DO_PULL" ]]; then
        echo "  Pulling latest changes..."
        cd "$REPO_PATH"
        if git pull; then
            echo ""
        else
            echo "  ⚠ git pull failed, continuing with local version" >&2
            echo ""
        fi
    fi

    # Run install.sh --update
    "$REPO_PATH/install.sh" --update
    UPDATE_STATUS=$?

    if [[ $UPDATE_STATUS -eq 0 ]]; then
        # Clear jupyter-env so next `jupyter` command prompts for setup
        JUPYTER_ENV_FILE="${CLAUDE_DIR}/jupyter-env"
        if [[ -f "$JUPYTER_ENV_FILE" ]]; then
            rm -f "$JUPYTER_ENV_FILE"
            echo "  Cleared jupyter-env (will re-prompt on next 'jupyter' run)"
        fi

        echo ""
        echo "╭─────────────────────────────────────────────────────────────╮"
        echo "│  Next Steps                                                 │"
        echo "╰─────────────────────────────────────────────────────────────╯"
        echo ""

        # Detect environment for context-specific instructions
        UPDATE_OS=$(uname -s)
        UPDATE_ENV=""

        case "$UPDATE_OS" in
            Darwin)
                UPDATE_ENV="mac"
                ;;
            Linux)
                if [[ -n "$SSH_CONNECTION" ]]; then
                    UPDATE_ENV="remote-linux"
                elif [[ -n "$WSL_DISTRO_NAME" ]] || grep -qi microsoft /proc/version 2>/dev/null; then
                    UPDATE_ENV="wsl"
                else
                    UPDATE_ENV="linux"
                fi
                ;;
            *)
                UPDATE_ENV="other"
                ;;
        esac

        echo "  1. Re-run /slack-notify to update your session registration"
        echo ""

        case "$UPDATE_ENV" in
            mac)
                echo "  2. If local-tunnel is running:"
                echo "     • Restart it: Ctrl+C, then run 'local-tunnel'"
                echo ""
                echo "  Environment: macOS"
                if [[ -n "$ITERM_SESSION_ID" ]]; then
                    echo "  Terminal: iTerm2"
                elif [[ "$TERM_PROGRAM" == "Apple_Terminal" ]]; then
                    echo "  Terminal: Terminal.app"
                fi
                ;;
            remote-linux)
                echo "  2. On your Mac (where local-tunnel runs):"
                echo "     • Restart local-tunnel if MCP server code changed"
                echo ""
                echo "  Environment: Remote Linux (via SSH)"
                [[ -n "$TMUX" ]] && echo "  Tmux: $(tmux display-message -p '#{session_name}' 2>/dev/null)"
                ;;
            wsl)
                echo "  2. If using local-tunnel on Windows:"
                echo "     • Restart the tunnel process"
                echo ""
                echo "  Environment: WSL ($WSL_DISTRO_NAME)"
                ;;
            *)
                echo "  Environment: $UPDATE_OS"
                ;;
        esac
        echo ""
    else
        echo ""
        echo "  ✗ Update failed" >&2
        exit 1
    fi
    exit 0
fi

# -----------------------------------------------------------------------------
# Links command - list or manage links
# Usage: claude-slack-notify links [clean]
# -----------------------------------------------------------------------------
if [[ "$1" == "links" ]]; then
    if [[ "$2" == "clean" ]]; then
        # Remove links older than 24 hours
        if [[ -d "$LINKS_DIR" ]]; then
            find "$LINKS_DIR" -name "*.json" -mtime +1 -delete 2>/dev/null
            echo "Cleaned old links"
        fi
        exit 0
    fi

    # List active links
    if [[ -d "$LINKS_DIR" ]]; then
        for f in "$LINKS_DIR"/*.json; do
            [[ -f "$f" ]] || continue
            LINK_ID=$(basename "$f" .json)
            TERM_TYPE=$(grep -o '"term_type": *"[^"]*"' "$f" | cut -d'"' -f4)
            CREATED=$(grep -o '"created_at": *"[^"]*"' "$f" | cut -d'"' -f4)
            echo "$LINK_ID  ($TERM_TYPE)  created: $CREATED"
        done
    fi
    exit 0
fi

# -----------------------------------------------------------------------------
# Launch command - start Claude in a local tmux session for reliable input
# Usage: claude-slack-notify launch [session-name]
# This is the recommended way to run Claude on Mac for thread reply support.
# Uses tmux send-keys (gastown pattern) instead of AppleScript for Enter.
# -----------------------------------------------------------------------------
if [[ "$1" == "launch" ]]; then
    shift
    SESSION_NAME="${1:-}"

    # Platform check - macOS only (for now)
    if [[ "$(uname)" != "Darwin" ]]; then
        echo "Error: 'launch' command is currently for macOS only." >&2
        echo "On Linux, Claude already runs in tmux via 'remote' command." >&2
        exit 1
    fi

    # Check if tmux is available
    if ! command -v tmux &>/dev/null; then
        echo "Error: tmux is required. Install with: brew install tmux" >&2
        exit 1
    fi

    # Check if already inside tmux
    if [[ -n "$TMUX" ]]; then
        echo "Error: Already inside a tmux session." >&2
        echo "Either run 'claude' directly here and use /slack-notify," >&2
        echo "or exit tmux and run 'claude-slack-notify launch' from outside." >&2
        exit 1
    fi

    # Generate session name if not provided
    if [[ -z "$SESSION_NAME" ]]; then
        SESSION_NAME="claude-$(head -c 6 /dev/urandom | base64 | tr -dc 'a-z0-9' | head -c 6)"
    fi

    # Check if session already exists
    if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
        echo "Attaching to existing session: $SESSION_NAME"
        exec tmux attach-session -t "$SESSION_NAME"
    fi

    # Platform check for tunnel setup (macOS only)
    if [[ "$(uname)" == "Darwin" ]]; then
        # Check local-tunnel and start if needed
        LOCAL_TUNNEL="${CLAUDE_DIR}/bin/local-tunnel"
        if [[ -x "$LOCAL_TUNNEL" ]]; then
            STATUS=$(check_local_tunnel_status 2>/dev/null || echo "stopped")
            if [[ "$STATUS" == "stopped" ]]; then
                echo "Starting local-tunnel in background..."
                "$LOCAL_TUNNEL" --background 2>/dev/null &
                sleep 2
            fi
        fi
    fi

    # Create new tmux session with Claude
    # The session runs a wrapper that:
    # 1. Exports CLAUDE_TMUX_SESSION for the hooks to detect
    # 2. Runs claude
    # 3. Kills the session when claude exits
    echo "Creating tmux session: $SESSION_NAME"
    tmux new-session -d -s "$SESSION_NAME" -x 200 -y 50

    # Send the claude command to the session
    # Export env vars for slack-notify to detect this is a local-tmux session
    tmux send-keys -t "$SESSION_NAME" "export CLAUDE_TMUX_SESSION='$SESSION_NAME'" Enter
    sleep 0.1
    tmux send-keys -t "$SESSION_NAME" "export CLAUDE_TMUX_TARGET='$SESSION_NAME:0.0'" Enter
    sleep 0.1
    tmux send-keys -t "$SESSION_NAME" "claude" Enter

    # Attach to the session
    echo "Attaching to Claude session..."
    exec tmux attach-session -t "$SESSION_NAME"
fi

# -----------------------------------------------------------------------------
# Local command - check/start local-tunnel (macOS), then register session
# Usage: claude-slack-notify local [optional-name]
# -----------------------------------------------------------------------------
if [[ "$1" == "local" ]]; then
    # Platform check - macOS only
    if [[ "$(uname)" != "Darwin" ]]; then
        echo "Error: 'local' command is for macOS only. Use 'remote' on Linux." >&2
        exit 1
    fi

    # Check local-tunnel exists
    LOCAL_TUNNEL="${CLAUDE_DIR}/bin/local-tunnel"
    if [[ ! -x "$LOCAL_TUNNEL" ]]; then
        echo "Error: local-tunnel not found. Run install.sh first." >&2
        exit 1
    fi

    # Check current status
    STATUS=$(check_local_tunnel_status)

    case "$STATUS" in
        running:*)
            TUNNEL_URL="${STATUS#running:}"
            echo "local-tunnel already running: $TUNNEL_URL"
            ;;
        mcp_only)
            echo "MCP server running but tunnel not connected. Starting tunnel..."
            "$LOCAL_TUNNEL" --background
            if ! TUNNEL_URL=$(wait_for_tunnel check_local_tunnel_status 30); then
                echo "Error: Tunnel failed to start within 30 seconds." >&2
                exit 1
            fi
            echo "Tunnel started: $TUNNEL_URL"
            ;;
        tunnel_only:*)
            echo "Tunnel running but MCP server not responding. Starting tunnel..."
            "$LOCAL_TUNNEL" --background
            if ! TUNNEL_URL=$(wait_for_tunnel check_local_tunnel_status 30); then
                echo "Error: MCP server failed to start within 30 seconds." >&2
                exit 1
            fi
            echo "Tunnel ready: $TUNNEL_URL"
            ;;
        stopped)
            echo "Starting local-tunnel..."
            "$LOCAL_TUNNEL" --background
            if ! TUNNEL_URL=$(wait_for_tunnel check_local_tunnel_status 30); then
                echo "Error: local-tunnel failed to start within 30 seconds." >&2
                exit 1
            fi
            echo "Tunnel started: $TUNNEL_URL"
            ;;
    esac

    # Now register the session (shift to get optional name argument)
    shift
    OPTIONAL_NAME="${1:-}"

    # Re-execute as register command
    exec "$0" register "$OPTIONAL_NAME"
fi

# -----------------------------------------------------------------------------
# Remote command - simplified SSH workflow for Mac, tunnel starter for Linux
# Mac: SSH to saved remote host with tmux session (sync Slack config on first run)
#      Supports multiple sessions per host with interactive menu selection
# Linux: Start remote-tunnel and register session
# Usage: claude-slack-notify remote [--new] [--session NAME] [hostname]
#   --new           Force create a new session (skip menu)
#   --session NAME  Use or create a specific named session (skip menu)
# -----------------------------------------------------------------------------
if [[ "$1" == "remote" ]]; then
    shift  # Remove "remote" from args

    # Parse arguments: [--new] [--session NAME] [hostname]
    NEW_SESSION=""
    SESSION_NAME=""
    HOST_ARG=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --new)
                NEW_SESSION="1"
                shift
                ;;
            --session)
                shift
                if [[ $# -eq 0 ]]; then
                    echo "Error: --session requires a name argument" >&2
                    exit 1
                fi
                SESSION_NAME="$1"
                validate_session_name "$SESSION_NAME"
                shift
                ;;
            *)
                HOST_ARG="$1"
                shift
                ;;
        esac
    done

    REMOTE_HOST_FILE="${CLAUDE_DIR}/.remote-host"
    SESSIONS_DIR="${CLAUDE_DIR}/.remote-sessions"

    # -------------------------------------------------------------------------
    # Mac behavior: SSH to remote server with Focus button support
    # -------------------------------------------------------------------------
    if [[ "$(uname)" == "Darwin" ]]; then
        # Get remote hostname from arg, config file, or prompt
        REMOTE_HOST=""
        FIRST_RUN=""

        if [[ -n "$HOST_ARG" ]]; then
            # Hostname provided as argument - use it and save
            REMOTE_HOST="$HOST_ARG"
            mkdir -p "$CLAUDE_DIR"
            echo "$REMOTE_HOST" > "$REMOTE_HOST_FILE"
        elif [[ -f "$REMOTE_HOST_FILE" ]]; then
            # Use saved hostname
            REMOTE_HOST=$(cat "$REMOTE_HOST_FILE" 2>/dev/null)
        fi

        if [[ -z "$REMOTE_HOST" ]]; then
            # First run - prompt for hostname
            FIRST_RUN="1"
            echo "Remote host not configured."
            echo -n "Enter hostname (e.g., user@server or SSH alias): "
            read -r REMOTE_HOST
            if [[ -z "$REMOTE_HOST" ]]; then
                echo "Error: hostname is required" >&2
                exit 1
            fi
            mkdir -p "$CLAUDE_DIR"
            echo "$REMOTE_HOST" > "$REMOTE_HOST_FILE"
        fi

        # Session persistence: multi-session support with per-host directories
        mkdir -p "$SESSIONS_DIR"
        SAFE_HOST=$(sanitize_hostname "$REMOTE_HOST")
        HOST_DIR="${SESSIONS_DIR}/${SAFE_HOST}"

        # Migrate from old single-file format if needed
        migrate_session_format "$SESSIONS_DIR" "$SAFE_HOST"

        # Acquire lock to prevent race conditions
        acquire_session_lock "$HOST_DIR"

        RECONNECT_MODE=""
        INSTANCE_NAME=""

        # If --session NAME was provided, use that directly
        if [[ -n "$SESSION_NAME" ]]; then
            INSTANCE_NAME="$SESSION_NAME"
            if [[ -f "$HOST_DIR/${INSTANCE_NAME}.json" ]]; then
                RECONNECT_MODE="1"
            fi
        # If --new was provided, skip menu and create new session
        elif [[ -n "$NEW_SESSION" ]]; then
            INSTANCE_NAME=$(generate_instance_name)
        else
            # Check what sessions exist locally and which are alive on remote
            declare -a local_sessions=()
            declare -a live_sessions=()
            declare -a dead_sessions=()

            # Get local session files
            if [[ -d "$HOST_DIR" ]]; then
                for f in "$HOST_DIR"/*.json; do
                    [[ -f "$f" ]] || continue
                    name=$(basename "$f" .json)
                    [[ "$name" == ".lock" ]] && continue
                    local_sessions+=("$name")
                done
            fi

            if [[ ${#local_sessions[@]} -gt 0 ]]; then
                # Query remote for live tmux sessions
                echo "Checking remote sessions..."
                remote_sessions=""
                if ! remote_sessions=$(query_remote_sessions "$REMOTE_HOST"); then
                    # SSH error already printed, exit
                    exit 1
                fi

                # Match local sessions against live remote sessions
                for session in "${local_sessions[@]}"; do
                    if echo "$remote_sessions" | grep -q "^${session}$"; then
                        live_sessions+=("$session")
                    else
                        dead_sessions+=("$session")
                    fi
                done
            fi

            # Decide behavior based on live session count
            if [[ ${#live_sessions[@]} -eq 0 ]]; then
                # No live sessions - create new
                INSTANCE_NAME=$(generate_instance_name)
            else
                # One or more live sessions - show menu
                if [[ ! -t 0 ]]; then
                    echo "Error: Session selection requires interactive terminal." >&2
                    echo "Use: claude-slack-notify remote --session NAME $REMOTE_HOST" >&2
                    echo "" >&2
                    echo "Available sessions:" >&2
                    for s in "${live_sessions[@]}"; do
                        echo "  $s" >&2
                    done
                    exit 1
                fi

                selected=""
                if selected=$(show_session_menu "$HOST_DIR" "$REMOTE_HOST" "${live_sessions[@]}"); then
                    INSTANCE_NAME="$selected"
                    RECONNECT_MODE="1"
                else
                    # User chose to create new session
                    INSTANCE_NAME=$(generate_instance_name)
                fi
            fi

            # Schedule cleanup of dead sessions in background after successful connect
            if [[ ${#dead_sessions[@]} -gt 0 ]]; then
                # Store dead sessions for cleanup after SSH (can't background from here reliably)
                DEAD_SESSIONS_TO_CLEAN=("${dead_sessions[@]}")
            fi
        fi

        # Create/update session file
        SESSION_FILE="$HOST_DIR/${INSTANCE_NAME}.json"
        mkdir -p "$HOST_DIR"
        if [[ -f "$SESSION_FILE" ]]; then
            # Update last_connected timestamp using a temp file for atomicity
            tmp_file="$SESSION_FILE.tmp.$$"
            if grep -q '"last_connected":' "$SESSION_FILE"; then
                sed "s/\"last_connected\": *\"[^\"]*\"/\"last_connected\": \"$(date -Iseconds)\"/" "$SESSION_FILE" > "$tmp_file"
            else
                # Add last_connected field before closing brace
                sed 's/}$/,\n  "last_connected": "'"$(date -Iseconds)"'"\n}/' "$SESSION_FILE" > "$tmp_file"
            fi
            mv "$tmp_file" "$SESSION_FILE"
        else
            # Create new session file
            cat > "$SESSION_FILE" << EOF
{
  "hostname": "$REMOTE_HOST",
  "instance_name": "$INSTANCE_NAME",
  "created_at": "$(date -Iseconds)",
  "last_connected": "$(date -Iseconds)"
}
EOF
        fi

        # Always generate fresh LINK_ID (local terminal info changes each connect)
        mkdir -p "$LINKS_DIR"
        LINK_ID=$(head -c 12 /dev/urandom | base64 | tr -dc 'a-z0-9' | head -c 8)

        # Detect local terminal for Focus button
        LINK_TERM_TYPE="unknown"
        LINK_TERM_TARGET=""
        LINK_FOCUS_URL=""

        if [[ -n "$TMUX" ]]; then
            local_session=$(tmux display-message -p '#{session_name}' 2>/dev/null)
            local_window=$(tmux display-message -p '#{window_index}' 2>/dev/null)
            local_pane=$(tmux display-message -p '#{pane_index}' 2>/dev/null)
            local_tmux_target="${local_session}:${local_window}.${local_pane}"
            local_client_tty=$(tmux display-message -p '#{client_tty}' 2>/dev/null)
            local_client_termtype=$(tmux display-message -p '#{client_termtype}' 2>/dev/null)

            if [[ "$local_client_termtype" == *"iTerm"* ]] || [[ -n "$ITERM_SESSION_ID" ]]; then
                term_app="iterm"
            else
                term_app="terminal"
            fi

            if [[ -n "$local_client_tty" ]]; then
                LINK_TERM_TYPE="${term_app}-tmux"
                LINK_TERM_TARGET="${local_client_tty}|${local_tmux_target}"
                LINK_FOCUS_URL="claude-focus://${term_app}-tmux/$(url_encode "$local_client_tty")/$(url_encode "$local_tmux_target")"
            else
                LINK_TERM_TYPE="tmux"
                LINK_TERM_TARGET="$local_tmux_target"
                LINK_FOCUS_URL="claude-focus://tmux/$(url_encode "$local_tmux_target")"
            fi
        elif [[ -n "$ITERM_SESSION_ID" ]]; then
            LINK_TERM_TYPE="iterm2"
            LINK_TERM_TARGET="${ITERM_SESSION_ID#*:}"
            LINK_FOCUS_URL="claude-focus://iterm2/${LINK_TERM_TARGET}"
        elif [[ "$__CFBundleIdentifier" == "com.apple.Terminal" || "$TERM_PROGRAM" == "Apple_Terminal" ]]; then
            local_terminal_tty=$(tty 2>/dev/null)
            if [[ -n "$local_terminal_tty" && "$local_terminal_tty" != "not a tty" ]]; then
                LINK_TERM_TYPE="terminal"
                LINK_TERM_TARGET="$local_terminal_tty"
                LINK_FOCUS_URL="claude-focus://terminal/$(url_encode "$local_terminal_tty")"
            fi
        fi

        # Get Mac's tunnel URL for Focus button routing
        MAC_TUNNEL_URL=""
        if [[ -f "$CLAUDE_DIR/.tunnel-url" ]]; then
            MAC_TUNNEL_URL=$(cat "$CLAUDE_DIR/.tunnel-url" 2>/dev/null)
        fi

        # Save link file for Focus button
        cat > "$LINKS_DIR/${LINK_ID}.json" << EOF
{
  "link_id": "${LINK_ID}",
  "instance_name": "${INSTANCE_NAME}",
  "term_type": "${LINK_TERM_TYPE}",
  "term_target": "${LINK_TERM_TARGET}",
  "focus_url": "${LINK_FOCUS_URL}",
  "mac_tunnel_url": "${MAC_TUNNEL_URL}",
  "created_at": "$(date -Iseconds)"
}
EOF

        # Sync Slack config (always, to pick up token updates)
        if [[ -f "$CLAUDE_DIR/.slack-config" ]]; then
            echo ""
            echo "Syncing Slack config to $REMOTE_HOST..."
            scp -q "$CLAUDE_DIR/.slack-config" "$REMOTE_HOST:~/.claude/" 2>/dev/null && \
                echo "  ✓ .slack-config"
            if [[ -f "$CLAUDE_DIR/slack-webhook-url" ]]; then
                scp -q "$CLAUDE_DIR/slack-webhook-url" "$REMOTE_HOST:~/.claude/" 2>/dev/null && \
                    echo "  ✓ slack-webhook-url"
            fi
            if [[ -f "$CLAUDE_DIR/slack-signing-secret" ]]; then
                scp -q "$CLAUDE_DIR/slack-signing-secret" "$REMOTE_HOST:~/.claude/" 2>/dev/null && \
                    echo "  ✓ slack-signing-secret"
            fi
        fi

        # Sync Mac tunnel URL to remote for Focus button routing
        if [[ -n "$MAC_TUNNEL_URL" ]]; then
            ssh "$REMOTE_HOST" "mkdir -p ~/.claude && echo '$MAC_TUNNEL_URL' > ~/.claude/.mac-tunnel-url" 2>/dev/null
        fi

        echo ""
        echo "Remote: $REMOTE_HOST"
        if [[ -n "$RECONNECT_MODE" ]]; then
            echo "Session: $INSTANCE_NAME (reconnecting)"
        else
            echo "Session: $INSTANCE_NAME (new)"
        fi
        if [[ "$LINK_TERM_TYPE" != "unknown" ]]; then
            echo "Focus: $LINK_TERM_TYPE"
        fi
        echo ""
        echo "Run /slack-notify in Claude to enable buttons"
        echo ""
        echo -n "Press Enter to connect..."
        read -r
        echo ""

        # Clean up dead sessions before connecting (non-blocking)
        if [[ -n "${DEAD_SESSIONS_TO_CLEAN+x}" && ${#DEAD_SESSIONS_TO_CLEAN[@]} -gt 0 ]]; then
            cleanup_dead_sessions "$HOST_DIR" "${DEAD_SESSIONS_TO_CLEAN[@]}"
        fi

        # Release lock before exec (allows multiple windows to same host)
        release_session_lock

        # SSH and attach-or-create tmux session with all required env vars for Focus button
        # -A flag: attach to existing session if it exists, create new if not
        exec ssh -t "$REMOTE_HOST" \
            "tmux new-session -A -s '$INSTANCE_NAME' \\; \
             set-environment CLAUDE_LINK_ID '$LINK_ID' \\; \
             set-environment CLAUDE_SSH_HOST '$REMOTE_HOST' \\; \
             set-environment CLAUDE_INSTANCE_NAME '$INSTANCE_NAME'"
    fi

    # -------------------------------------------------------------------------
    # Linux behavior: Start remote-tunnel and register session
    # -------------------------------------------------------------------------
    # Check remote-tunnel exists
    REMOTE_TUNNEL="${CLAUDE_DIR}/bin/remote-tunnel"
    if [[ ! -x "$REMOTE_TUNNEL" ]]; then
        echo "Error: remote-tunnel not found. Run install.sh first." >&2
        exit 1
    fi

    # Check current status
    STATUS=$(check_remote_tunnel_status)

    case "$STATUS" in
        running:*)
            TUNNEL_URL="${STATUS#running:}"
            echo "remote-tunnel already running: $TUNNEL_URL"
            ;;
        relay_only)
            echo "Relay server running but tunnel not connected. Starting tunnel..."
            "$REMOTE_TUNNEL" --background
            if ! TUNNEL_URL=$(wait_for_tunnel check_remote_tunnel_status 30); then
                echo "Error: Tunnel failed to start within 30 seconds." >&2
                exit 1
            fi
            echo "Tunnel started: $TUNNEL_URL"
            ;;
        tunnel_only:*)
            echo "Tunnel running but relay server not responding. Starting tunnel..."
            "$REMOTE_TUNNEL" --background
            if ! TUNNEL_URL=$(wait_for_tunnel check_remote_tunnel_status 30); then
                echo "Error: Relay server failed to start within 30 seconds." >&2
                exit 1
            fi
            echo "Tunnel ready: $TUNNEL_URL"
            ;;
        stopped)
            echo "Starting remote-tunnel..."
            "$REMOTE_TUNNEL" --background
            if ! TUNNEL_URL=$(wait_for_tunnel check_remote_tunnel_status 30); then
                echo "Error: remote-tunnel failed to start within 30 seconds." >&2
                exit 1
            fi
            echo "Tunnel started: $TUNNEL_URL"
            ;;
    esac

    echo "Note: Focus button won't switch windows (Mac not connected)"

    # Now register the session (use HOST_ARG if provided as optional name)
    OPTIONAL_NAME="${HOST_ARG:-}"

    # Re-execute as register command
    exec "$0" register "$OPTIONAL_NAME"
fi

# -----------------------------------------------------------------------------
# Jupyter command - simplified JupyterLab tmux setup
# Usage: claude-slack-notify jupyter (or jupyter-start)
# Run this in a JupyterLab terminal to set up a linked session
# -----------------------------------------------------------------------------
if [[ "$1" == "jupyter" || "$1" == "jupyter-start" ]]; then
    JUPYTER_ENV_FILE="$CLAUDE_DIR/jupyter-env"

    # If jupyter-env doesn't exist, create it and show setup URL
    # (Run 'claude-slack-notify update' to reset and re-prompt for setup)
    if [[ ! -f "$JUPYTER_ENV_FILE" ]]; then
        echo "Setting up JupyterLab link..."
        echo ""

        # Generate link ID and instance name
        LINK_ID=$(head -c 6 /dev/urandom | base64 | tr -dc 'a-z0-9' | head -c 8)
        INSTANCE_NAME=$(generate_instance_name)
        SSH_HOST=$(hostname -f 2>/dev/null || hostname)

        # Ask for JupyterLab URL
        echo "Enter your JupyterLab URL (from browser address bar):"
        echo -n "> "
        read -r JUPYTER_URL

        if [[ -z "$JUPYTER_URL" ]]; then
            echo "Error: JupyterLab URL is required" >&2
            exit 1
        fi

        # Strip path to get base URL
        JUPYTER_URL=$(echo "$JUPYTER_URL" | sed 's|/lab/.*||; s|/tree/.*||; s|/notebooks/.*||; s|#.*||')

        # Save jupyter-env
        cat > "$JUPYTER_ENV_FILE" << EOF
export CLAUDE_LINK_ID=$LINK_ID
export CLAUDE_SSH_HOST=$SSH_HOST
export CLAUDE_INSTANCE_NAME=$INSTANCE_NAME
export CLAUDE_JUPYTER_URL=$JUPYTER_URL
EOF

        # URL encode for the setup link
        url_encode_param() {
            python3 -c "import urllib.parse; print(urllib.parse.quote('$1', safe=''))" 2>/dev/null || \
            echo "$1" | sed 's/:/%3A/g; s|/|%2F|g; s/ /%20/g'
        }

        ENCODED_URL=$(url_encode_param "$JUPYTER_URL")
        ENCODED_HOST=$(url_encode_param "$SSH_HOST")
        ENCODED_NAME=$(url_encode_param "$INSTANCE_NAME")

        echo ""
        echo "╭─────────────────────────────────────────────────────────────╮"
        echo "│  JupyterLab Link Setup                                      │"
        echo "╰─────────────────────────────────────────────────────────────╯"
        echo ""
        echo "  Open this URL on your Mac to enable Focus button:"
        echo ""
        echo "  claude-focus://jupyter-link/${LINK_ID}?url=${ENCODED_URL}&host=${ENCODED_HOST}&name=${ENCODED_NAME}"
        echo ""
        echo "  (Click or paste in browser - do this before using Focus)"
        echo ""
        echo "  Starting tmux session..."
        echo ""
        # Fall through to start tmux session
    fi

    # Source the environment file to get CLAUDE_LINK_ID etc.
    source "$JUPYTER_ENV_FILE"

    if [[ -z "$CLAUDE_LINK_ID" ]]; then
        echo "Error: CLAUDE_LINK_ID not set in jupyter-env" >&2
        exit 1
    fi

    SESSION_NAME="${CLAUDE_INSTANCE_NAME:-jupyter}"

    # Check if already in tmux
    if [[ -n "$TMUX" ]]; then
        echo "Already in tmux. Setting environment variables..."
        tmux set-environment CLAUDE_LINK_ID "$CLAUDE_LINK_ID"
        tmux set-environment CLAUDE_SSH_HOST "$CLAUDE_SSH_HOST"
        tmux set-environment CLAUDE_INSTANCE_NAME "$CLAUDE_INSTANCE_NAME"
        echo "Done. Now run: claude"
        exit 0
    fi

    # Check if session already exists
    if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
        echo "Attaching to existing session: $SESSION_NAME"
        # Update environment in existing session
        tmux set-environment -t "$SESSION_NAME" CLAUDE_LINK_ID "$CLAUDE_LINK_ID"
        tmux set-environment -t "$SESSION_NAME" CLAUDE_SSH_HOST "$CLAUDE_SSH_HOST"
        tmux set-environment -t "$SESSION_NAME" CLAUDE_INSTANCE_NAME "$CLAUDE_INSTANCE_NAME"
        exec tmux attach -t "$SESSION_NAME"
    fi

    echo "Starting tmux session: $SESSION_NAME"

    # Create new session with environment variables
    # The \; syntax runs multiple tmux commands
    exec tmux new-session -s "$SESSION_NAME" \; \
         set-environment CLAUDE_LINK_ID "$CLAUDE_LINK_ID" \; \
         set-environment CLAUDE_SSH_HOST "$CLAUDE_SSH_HOST" \; \
         set-environment CLAUDE_INSTANCE_NAME "$CLAUDE_INSTANCE_NAME"
fi

# -----------------------------------------------------------------------------
# Clean command - kill stale claude-* tmux sessions older than 1 day
# Usage: claude-slack-notify clean
# -----------------------------------------------------------------------------
if [[ "$1" == "clean" ]]; then
    if ! command -v tmux &>/dev/null; then
        echo "Error: tmux not installed" >&2
        exit 1
    fi

    # Get cutoff timestamp (1 day ago)
    # Linux: date -d '1 day ago'
    # macOS: date -v-1d
    if date -d '1 day ago' +%s &>/dev/null 2>&1; then
        CUTOFF=$(date -d '1 day ago' +%s)
    else
        CUTOFF=$(date -v-1d +%s)
    fi

    CLEANED=0
    SKIPPED=0

    # List tmux sessions
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue

        # Parse: "claude-xyz: 1 windows (created Mon Jan 19 18:06:50 2026) (attached)"
        SESSION=$(echo "$line" | cut -d: -f1)

        # Only process claude-* sessions
        [[ "$SESSION" != claude-* ]] && continue

        # Skip attached sessions
        if echo "$line" | grep -q "(attached)"; then
            echo "Skipping attached: $SESSION"
            ((SKIPPED++))
            continue
        fi

        # Extract creation date from "(created ...)"
        CREATED=$(echo "$line" | grep -oP '\(created \K[^)]+' 2>/dev/null || \
                  echo "$line" | sed -n 's/.*created \([^)]*\)).*/\1/p')

        if [[ -z "$CREATED" ]]; then
            continue
        fi

        # Convert to epoch
        # Linux: date -d "$CREATED"
        # macOS: date -j -f format
        if date -d "$CREATED" +%s &>/dev/null 2>&1; then
            CREATED_EPOCH=$(date -d "$CREATED" +%s)
        else
            # macOS format: "Mon Jan 19 18:06:50 2026"
            CREATED_EPOCH=$(date -j -f "%a %b %d %H:%M:%S %Y" "$CREATED" +%s 2>/dev/null || echo 0)
        fi

        if [[ $CREATED_EPOCH -lt $CUTOFF ]]; then
            echo "Killing stale session: $SESSION (created $CREATED)"
            tmux kill-session -t "$SESSION" 2>/dev/null && ((CLEANED++))
        fi
    done < <(tmux ls 2>/dev/null)

    echo ""
    echo "Cleaned $CLEANED stale sessions, skipped $SKIPPED attached"

    # Also clean up stale instance files (sessions that no longer exist)
    INSTANCES_CLEANED=0
    if [[ -d "$INSTANCES_DIR" ]]; then
        for instance_file in "$INSTANCES_DIR"/*.json; do
            [[ -f "$instance_file" ]] || continue

            # Extract tmux session name from term_target
            term_target=$(grep -o '"term_target": *"[^"]*"' "$instance_file" 2>/dev/null | cut -d'"' -f4)
            [[ -z "$term_target" ]] && continue

            # Get just the tmux part (after last |)
            tmux_target="${term_target##*|}"
            # Get session name (before :)
            session_name="${tmux_target%%:*}"

            [[ -z "$session_name" ]] && continue

            # Check if tmux session exists
            if ! tmux has-session -t "$session_name" 2>/dev/null; then
                instance_name=$(grep -o '"name": *"[^"]*"' "$instance_file" 2>/dev/null | cut -d'"' -f4)
                echo "Removing stale instance: $instance_name (tmux session '$session_name' not found)"
                rm -f "$instance_file"
                ((INSTANCES_CLEANED++))
            fi
        done
    fi

    if [[ $INSTANCES_CLEANED -gt 0 ]]; then
        echo "Cleaned $INSTANCES_CLEANED stale instance files"
    fi

    exit 0
fi

get_tmux_target() {
    # Get the controlling TTY for this process tree
    # We need to find the TTY that corresponds to our tmux pane
    local my_tty=""

    # Try to get TTY from PPID (the parent shell process)
    # Note: CLAUDE_INSTANCE_ID is now a session UUID, not a PID, so we use PPID for TTY lookup
    local check_pid="$PPID"
    my_tty=$(ps -p "$check_pid" -o tty= 2>/dev/null | tr -d ' ')

    # Normalize TTY format (add /dev/ prefix if missing)
    if [[ -n "$my_tty" && "$my_tty" != "??" && "$my_tty" != "?" ]]; then
        [[ "$my_tty" != /dev/* ]] && my_tty="/dev/$my_tty"

        # Look up which tmux pane has this TTY
        local pane_info
        pane_info=$(tmux list-panes -a -F '#{pane_tty} #{session_name}:#{window_index}.#{pane_index}' 2>/dev/null | grep "^${my_tty} " | head -1)

        if [[ -n "$pane_info" ]]; then
            # Extract session:window.pane from the output
            echo "${pane_info#* }"
            return
        fi
    fi

    # Fallback to display-message (works when called from the active pane)
    local session window pane
    session=$(tmux display-message -p '#{session_name}' 2>/dev/null)
    window=$(tmux display-message -p '#{window_index}' 2>/dev/null)
    pane=$(tmux display-message -p '#{pane_index}' 2>/dev/null)
    echo "${session}:${window}.${pane}"
}

detect_terminal() {
    TERM_TYPE="unknown"
    TERM_TARGET=""
    FOCUS_URL=""

    # Check for local-tmux session (started via claude-slack-notify launch)
    # This uses tmux send-keys with gastown pattern for reliable Enter submission
    if [[ -n "$CLAUDE_TMUX_SESSION" ]]; then
        local tmux_target="${CLAUDE_TMUX_TARGET:-$CLAUDE_TMUX_SESSION:0.0}"
        TERM_TYPE="local-tmux"
        TERM_TARGET="$tmux_target"
        FOCUS_URL="claude-focus://local-tmux/$(url_encode "$tmux_target")"
        return
    fi

    # If in tmux, try to get link variables from tmux session environment
    # This is needed because tmux set-environment stores vars at session level,
    # not in individual shell environments. New windows/panes won't inherit them.
    if [[ -n "$TMUX" ]]; then
        if [[ -z "$CLAUDE_LINK_ID" ]]; then
            CLAUDE_LINK_ID=$(tmux show-environment CLAUDE_LINK_ID 2>/dev/null | cut -d= -f2-)
            [[ "$CLAUDE_LINK_ID" == "-CLAUDE_LINK_ID" ]] && CLAUDE_LINK_ID=""
        fi
        if [[ -z "$CLAUDE_SSH_HOST" ]]; then
            CLAUDE_SSH_HOST=$(tmux show-environment CLAUDE_SSH_HOST 2>/dev/null | cut -d= -f2-)
            [[ "$CLAUDE_SSH_HOST" == "-CLAUDE_SSH_HOST" ]] && CLAUDE_SSH_HOST=""
        fi
        if [[ -z "$CLAUDE_INSTANCE_NAME" ]]; then
            CLAUDE_INSTANCE_NAME=$(tmux show-environment CLAUDE_INSTANCE_NAME 2>/dev/null | cut -d= -f2-)
            [[ "$CLAUDE_INSTANCE_NAME" == "-CLAUDE_INSTANCE_NAME" ]] && CLAUDE_INSTANCE_NAME=""
        fi
    fi

    # Check for linked session without SSH (e.g., JupyterLab terminal)
    # CLAUDE_LINK_ID is set but SSH_CONNECTION is not
    if [[ -n "$CLAUDE_LINK_ID" && -z "$SSH_CONNECTION" ]]; then
        SSH_USER=$(whoami)
        SSH_HOST="${CLAUDE_SSH_HOST:-$(hostname -f 2>/dev/null || hostname)}"
        SSH_PORT="${CLAUDE_SSH_PORT:-22}"

        # Get tmux target if available
        local remote_tmux_target=""
        if [[ -n "$TMUX" ]]; then
            local r_session r_window r_pane
            r_session=$(tmux display-message -p '#{session_name}' 2>/dev/null)
            r_window=$(tmux display-message -p '#{window_index}' 2>/dev/null)
            r_pane=$(tmux display-message -p '#{pane_index}' 2>/dev/null)
            remote_tmux_target="${r_session}:${r_window}.${r_pane}"
        fi

        # JupyterLab or similar linked terminal (no direct SSH)
        TERM_TYPE="jupyter-tmux"
        TERM_TARGET="${CLAUDE_LINK_ID}|${SSH_HOST}|${SSH_USER}|${SSH_PORT}|${remote_tmux_target}"
        FOCUS_URL="claude-focus://jupyter-tmux/$(url_encode "$CLAUDE_LINK_ID")/$(url_encode "$SSH_HOST")/$(url_encode "$SSH_USER")/${SSH_PORT}/$(url_encode "$remote_tmux_target")"
        return
    fi

    # Check for SSH session with linked local terminal
    if [[ -n "$SSH_CONNECTION" ]]; then
        SSH_USER=$(whoami)
        # Use CLAUDE_SSH_HOST if set (passed from remote command), otherwise fall back to hostname
        # CLAUDE_SSH_HOST ensures we use the same host/alias the user connected with
        SSH_HOST="${CLAUDE_SSH_HOST:-$(hostname -f 2>/dev/null || hostname)}"
        SSH_PORT="${CLAUDE_SSH_PORT:-22}"

        # Debug logging for troubleshooting link issues
        if [[ -n "$SLACK_NOTIFY_DEBUG" ]]; then
            echo "DEBUG: SSH detected. CLAUDE_LINK_ID='$CLAUDE_LINK_ID' CLAUDE_SSH_HOST='$CLAUDE_SSH_HOST' SSH_HOST='$SSH_HOST'" >&2
        fi

        if [[ -n "$CLAUDE_LINK_ID" ]]; then
            # Linked SSH mode - local terminal for focus, remote for input
            TERM_TYPE="ssh-linked"

            # Get tmux target if available on remote
            local remote_tmux_target=""
            if [[ -n "$TMUX" ]]; then
                local r_session r_window r_pane
                r_session=$(tmux display-message -p '#{session_name}' 2>/dev/null)
                r_window=$(tmux display-message -p '#{window_index}' 2>/dev/null)
                r_pane=$(tmux display-message -p '#{pane_index}' 2>/dev/null)
                remote_tmux_target="${r_session}:${r_window}.${r_pane}"
            fi

            TERM_TARGET="${CLAUDE_LINK_ID}|${SSH_HOST}|${SSH_USER}|${SSH_PORT}|${remote_tmux_target}"
            FOCUS_URL="claude-focus://ssh-linked/$(url_encode "$CLAUDE_LINK_ID")/$(url_encode "$SSH_HOST")/$(url_encode "$SSH_USER")/${SSH_PORT}/$(url_encode "$remote_tmux_target")"
            return
        fi

        # Unlinked SSH mode - direct SSH (no local terminal focus)
        if [[ -n "$TMUX" ]]; then
            # SSH + tmux but no link
            local r_session r_window r_pane
            r_session=$(tmux display-message -p '#{session_name}' 2>/dev/null)
            r_window=$(tmux display-message -p '#{window_index}' 2>/dev/null)
            r_pane=$(tmux display-message -p '#{pane_index}' 2>/dev/null)
            local remote_tmux_target="${r_session}:${r_window}.${r_pane}"

            TERM_TYPE="ssh-tmux"
            TERM_TARGET="${SSH_HOST}|${SSH_USER}|${SSH_PORT}|${remote_tmux_target}"
            FOCUS_URL="claude-focus://ssh-tmux/$(url_encode "$SSH_HOST")/$(url_encode "$SSH_USER")/${SSH_PORT}/$(url_encode "$remote_tmux_target")"
            return
        fi

        # SSH without tmux or link - limited support
        TERM_TYPE="ssh"
        TERM_TARGET="${SSH_HOST}|${SSH_USER}|${SSH_PORT}"
        FOCUS_URL=""  # No focus URL - can't reliably send input without tmux
        return
    fi

    # Detect OS
    local os_type
    case "$(uname -s)" in
        MINGW*|MSYS*|CYGWIN*) os_type="windows" ;;
        Linux)
            if [[ -n "$WSL_DISTRO_NAME" ]] || grep -qi microsoft /proc/version 2>/dev/null; then
                os_type="wsl"
            else
                os_type="linux"
            fi
            ;;
        Darwin) os_type="macos" ;;
        *) os_type="unknown" ;;
    esac

    # ---------------------------------------------------------------------
    # Windows Terminal detection (runs in WSL, Git Bash, MSYS2, Cygwin)
    # ---------------------------------------------------------------------
    if [[ "$os_type" == "wsl" || "$os_type" == "windows" ]]; then
        if [[ -n "$WT_SESSION" ]]; then
            # Windows Terminal detected
            if [[ -n "$TMUX" ]]; then
                local tmux_target
                tmux_target=$(get_tmux_target)
                TERM_TYPE="wt-tmux"
                TERM_TARGET="${WT_SESSION}|${tmux_target}"
                FOCUS_URL="claude-focus://wt-tmux/$(url_encode "$WT_SESSION")/$(url_encode "$tmux_target")"
            else
                TERM_TYPE="windows-terminal"
                TERM_TARGET="$WT_SESSION"
                FOCUS_URL="claude-focus://windows-terminal/$(url_encode "$WT_SESSION")"
            fi
            return
        elif [[ -n "$ConEmuPID" ]]; then
            # ConEmu/Cmder detected
            TERM_TYPE="conemu"
            TERM_TARGET="$ConEmuPID"
            FOCUS_URL="claude-focus://conemu/$(url_encode "$ConEmuPID")"
            return
        elif [[ "$os_type" == "wsl" ]]; then
            # WSL without Windows Terminal - identify by WSL distro and window
            local wsl_window_id
            wsl_window_id="${WSL_DISTRO_NAME:-wsl}-$$"
            if [[ -n "$TMUX" ]]; then
                local tmux_target
                tmux_target=$(get_tmux_target)
                TERM_TYPE="wsl-tmux"
                TERM_TARGET="${wsl_window_id}|${tmux_target}"
                FOCUS_URL="claude-focus://wsl-tmux/$(url_encode "$wsl_window_id")/$(url_encode "$tmux_target")"
            else
                TERM_TYPE="wsl"
                TERM_TARGET="$wsl_window_id"
                FOCUS_URL="claude-focus://wsl/$(url_encode "$wsl_window_id")"
            fi
            return
        elif [[ "$os_type" == "windows" ]]; then
            # Git Bash / MSYS2 / Cygwin without Windows Terminal
            local mintty_pid="${MINTTY_PID:-$PPID}"
            TERM_TYPE="mintty"
            TERM_TARGET="$mintty_pid"
            FOCUS_URL="claude-focus://mintty/$(url_encode "$mintty_pid")"
            return
        fi
    fi

    # ---------------------------------------------------------------------
    # macOS terminal detection
    # ---------------------------------------------------------------------
    if [[ "$os_type" == "macos" ]]; then
        if [[ -n "$TMUX" ]]; then
            local tmux_target client_tty term_app client_termtype
            tmux_target=$(get_tmux_target)
            client_tty=$(tmux display-message -p '#{client_tty}' 2>/dev/null)
            client_termtype=$(tmux display-message -p '#{client_termtype}' 2>/dev/null)

            # Detect which terminal app is running tmux
            # Use client_termtype (most reliable), fall back to ITERM_SESSION_ID
            if [[ "$client_termtype" == *"iTerm"* ]] || [[ -n "$ITERM_SESSION_ID" ]]; then
                term_app="iterm"
            else
                term_app="terminal"
            fi

            if [[ -n "$client_tty" ]]; then
                TERM_TYPE="${term_app}-tmux"
                TERM_TARGET="${client_tty}|${tmux_target}"
                FOCUS_URL="claude-focus://${term_app}-tmux/$(url_encode "$client_tty")/$(url_encode "$tmux_target")"
            else
                TERM_TYPE="tmux"
                TERM_TARGET="$tmux_target"
                FOCUS_URL="claude-focus://tmux/$(url_encode "$tmux_target")"
            fi
        elif [[ -n "$ITERM_SESSION_ID" ]]; then
            TERM_TYPE="iterm2"
            TERM_TARGET="${ITERM_SESSION_ID#*:}"
            FOCUS_URL="claude-focus://iterm2/${TERM_TARGET}"
        elif [[ "$__CFBundleIdentifier" == "com.apple.Terminal" || "$TERM_PROGRAM" == "Apple_Terminal" ]]; then
            # Terminal.app - get TTY of current shell
            local terminal_tty
            terminal_tty=$(tty 2>/dev/null)
            # Fallback: when running as subprocess (e.g., from Claude), tty fails
            # Use ps to find the controlling TTY of ancestor processes
            if [[ -z "$terminal_tty" || "$terminal_tty" == "not a tty" ]]; then
                # Find TTY from parent process chain (Claude -> shell -> this script)
                terminal_tty=$(ps -o tty= -p $PPID 2>/dev/null | grep -v '?' | head -1)
                [[ -n "$terminal_tty" && "$terminal_tty" != "??" ]] && terminal_tty="/dev/$terminal_tty"
            fi
            if [[ -n "$terminal_tty" && "$terminal_tty" != "not a tty" && "$terminal_tty" != "/dev/" ]]; then
                TERM_TYPE="terminal"
                TERM_TARGET="$terminal_tty"
                FOCUS_URL="claude-focus://terminal/$(url_encode "$terminal_tty")"
            else
                # Last resort: generic Terminal.app focus (focuses frontmost window)
                TERM_TYPE="terminal"
                TERM_TARGET="frontmost"
                FOCUS_URL="claude-focus://terminal/frontmost"
            fi
        fi
        return
    fi

    # ---------------------------------------------------------------------
    # Linux terminal detection (non-WSL)
    # ---------------------------------------------------------------------
    if [[ "$os_type" == "linux" ]]; then
        if [[ -n "$TMUX" ]]; then
            local tmux_target client_tty
            tmux_target=$(get_tmux_target)
            client_tty=$(tmux display-message -p '#{client_tty}' 2>/dev/null)
            if [[ -n "$client_tty" ]]; then
                TERM_TYPE="linux-tmux"
                TERM_TARGET="${client_tty}|${tmux_target}"
                FOCUS_URL="claude-focus://linux-tmux/$(url_encode "$client_tty")/$(url_encode "$tmux_target")"
            else
                TERM_TYPE="tmux"
                TERM_TARGET="$tmux_target"
                FOCUS_URL="claude-focus://tmux/$(url_encode "$tmux_target")"
            fi
        elif [[ -n "$GNOME_TERMINAL_SERVICE" ]]; then
            TERM_TYPE="gnome-terminal"
            TERM_TARGET="$$"
            FOCUS_URL="claude-focus://gnome-terminal/$(url_encode "$$")"
        elif [[ -n "$KONSOLE_DBUS_SESSION" ]]; then
            TERM_TYPE="konsole"
            TERM_TARGET="$KONSOLE_DBUS_SESSION"
            FOCUS_URL="claude-focus://konsole/$(url_encode "$KONSOLE_DBUS_SESSION")"
        elif [[ "$TERM_PROGRAM" == "vscode" ]]; then
            TERM_TYPE="vscode"
            TERM_TARGET="$$"
            FOCUS_URL="claude-focus://vscode/$(url_encode "$$")"
        fi
    fi
}

# -----------------------------------------------------------------------------
# Register a new instance
# -----------------------------------------------------------------------------
if [[ "$1" == "register" ]]; then
    mkdir -p "$INSTANCES_DIR"

    # Detect terminal first to know what to clean up and what name to preserve
    detect_terminal

    # PHASE 1: Extract existing name from files matching TERM_TARGET BEFORE cleanup
    # This preserves the instance name on re-registration (same terminal, different PID)
    PRESERVED_NAME=""
    if [[ -n "$TERM_TARGET" ]]; then
        for old_file in "$INSTANCES_DIR"/*.json; do
            [[ -f "$old_file" ]] || continue
            old_target=$(grep -o '"term_target": *"[^"]*"' "$old_file" 2>/dev/null | cut -d'"' -f4)
            if [[ "$old_target" == "$TERM_TARGET" ]]; then
                PRESERVED_NAME=$(grep -o '"name": *"[^"]*"' "$old_file" 2>/dev/null | cut -d'"' -f4)
                break  # Use first match
            fi
        done
    fi

    # PHASE 2: Clean up old session files for this terminal (prevents stale session IDs)
    if [[ -n "$TERM_TARGET" ]]; then
        for old_file in "$INSTANCES_DIR"/*.json; do
            [[ -f "$old_file" ]] || continue
            old_target=$(grep -o '"term_target": *"[^"]*"' "$old_file" 2>/dev/null | cut -d'"' -f4)
            if [[ "$old_target" == "$TERM_TARGET" ]]; then
                rm -f "$old_file"
            fi
        done
    fi

    # PHASE 3: Determine instance name with priority:
    # 1. Command line argument (explicit override, e.g., --force-new-name behavior)
    # 2. CLAUDE_INSTANCE_NAME env var (set by remote command for 1:1 tmux correspondence)
    # 3. PRESERVED_NAME from existing instance file (maintains identity on re-register)
    # 4. Generate a new random name
    INSTANCE_NAME="$2"
    if [[ -z "$INSTANCE_NAME" && -n "$CLAUDE_INSTANCE_NAME" ]]; then
        INSTANCE_NAME="$CLAUDE_INSTANCE_NAME"
    fi
    if [[ -z "$INSTANCE_NAME" && -n "$PRESERVED_NAME" ]]; then
        INSTANCE_NAME="$PRESERVED_NAME"
    fi
    if [[ -z "$INSTANCE_NAME" ]]; then
        INSTANCE_NAME=$(generate_instance_name)
    fi

    # detect_terminal already called above for cleanup
    HOSTNAME=$(hostname -s 2>/dev/null || echo "unknown")

    # Build instance JSON with optional SSH fields
    INSTANCE_JSON="{
  \"id\": \"${INSTANCE_ID}\",
  \"name\": \"${INSTANCE_NAME}\",
  \"hostname\": \"${HOSTNAME}\",
  \"term_type\": \"${TERM_TYPE}\",
  \"term_target\": \"${TERM_TARGET}\",
  \"focus_url\": \"${FOCUS_URL}\""

    # Add SSH-specific fields if in SSH mode
    if [[ "$TERM_TYPE" == "ssh-linked" && -n "$CLAUDE_LINK_ID" ]]; then
        INSTANCE_JSON+=",
  \"link_id\": \"${CLAUDE_LINK_ID}\",
  \"ssh_host\": \"${SSH_HOST}\",
  \"ssh_user\": \"${SSH_USER}\",
  \"ssh_port\": \"${SSH_PORT}\""
    elif [[ "$TERM_TYPE" == "ssh-tmux" || "$TERM_TYPE" == "ssh" ]]; then
        INSTANCE_JSON+=",
  \"ssh_host\": \"${SSH_HOST}\",
  \"ssh_user\": \"${SSH_USER}\",
  \"ssh_port\": \"${SSH_PORT}\""
    fi

    INSTANCE_JSON+=",
  \"registered_at\": \"$(date -Iseconds)\"
}"

    echo "$INSTANCE_JSON" > "$INSTANCE_FILE"

    # Auto-start tunnel/relay for Slack button support
    SLACK_CONFIG_FILE="${CLAUDE_DIR}/.slack-config"
    if [[ -f "$SLACK_CONFIG_FILE" ]]; then
        case "$(uname)" in
            Linux)
                # On Linux: always auto-start remote-tunnel relay if not running
                # (needed for button support regardless of session type)
                REMOTE_TUNNEL="${CLAUDE_DIR}/bin/remote-tunnel"
                if [[ -x "$REMOTE_TUNNEL" ]]; then
                    # Check if relay is responding
                    if ! curl -sf "http://localhost:8464/health" --max-time 1 >/dev/null 2>&1; then
                        echo "Starting relay for Slack buttons..." >&2
                        "$REMOTE_TUNNEL" --background >/dev/null 2>&1 || true
                    fi
                fi
                ;;
            Darwin)
                # On macOS: warn if local-tunnel not running (only for non-linked sessions)
                if [[ "$TERM_TYPE" != "ssh-linked" ]] && [[ "$TERM_TYPE" != "jupyter-tmux" ]]; then
                    TUNNEL_PID_FILE="${CLAUDE_DIR}/.tunnel.pid"
                    TUNNEL_RUNNING=false
                    if [[ -f "$TUNNEL_PID_FILE" ]]; then
                        EXISTING_PID=$(cat "$TUNNEL_PID_FILE" 2>/dev/null)
                        if [[ -n "$EXISTING_PID" ]] && kill -0 "$EXISTING_PID" 2>/dev/null; then
                            TUNNEL_RUNNING=true
                        fi
                    fi
                    # Also check if MCP server is responding (Tailscale Funnel doesn't use PID file)
                    if curl -sf "http://localhost:8463/health" --max-time 1 >/dev/null 2>&1; then
                        TUNNEL_RUNNING=true
                    fi
                    if [[ "$TUNNEL_RUNNING" == "false" ]]; then
                        echo "Warning: Slack buttons require 'local-tunnel' to be running" >&2
                        echo "         Run: local-tunnel --background" >&2
                    fi
                fi
                ;;
        esac
    fi

    echo "$INSTANCE_NAME"
    exit 0
fi

# -----------------------------------------------------------------------------
# List registered instances
# -----------------------------------------------------------------------------
if [[ "$1" == "list" ]]; then
    if [[ -d "$INSTANCES_DIR" ]]; then
        for f in "$INSTANCES_DIR"/*.json; do
            [[ -f "$f" ]] || continue
            NAME=$(grep -o '"name": *"[^"]*"' "$f" | cut -d'"' -f4)
            HOST=$(grep -o '"hostname": *"[^"]*"' "$f" | cut -d'"' -f4)
            TERM=$(grep -o '"term_type": *"[^"]*"' "$f" | cut -d'"' -f4)
            TARGET=$(grep -o '"term_target": *"[^"]*"' "$f" | cut -d'"' -f4)
            echo "$NAME @ $HOST ($TERM $TARGET)"
        done
    fi
    exit 0
fi

# -----------------------------------------------------------------------------
# Status - show system status, tunnels, and registered sessions
# Usage: claude-slack-notify status
# -----------------------------------------------------------------------------
if [[ "$1" == "status" ]]; then
    echo "╭─────────────────────────────────────────────────────────────╮"
    echo "│  Claude Slack Notify Status                                 │"
    echo "╰─────────────────────────────────────────────────────────────╯"
    echo ""

    # Machine info
    MACHINE_HOSTNAME=$(hostname -f 2>/dev/null || hostname)
    MACHINE_OS=$(uname -s)

    # Detect environment type
    ENV_TYPE=""
    TERMINAL_APP=""

    case "$MACHINE_OS" in
        Darwin)
            ENV_TYPE="macOS"
            if [[ -n "$ITERM_SESSION_ID" ]]; then
                TERMINAL_APP="iTerm2"
            elif [[ "$TERM_PROGRAM" == "Apple_Terminal" || "$__CFBundleIdentifier" == "com.apple.Terminal" ]]; then
                TERMINAL_APP="Terminal.app"
            elif [[ -n "$TERM_PROGRAM" ]]; then
                TERMINAL_APP="$TERM_PROGRAM"
            fi
            ;;
        Linux)
            if [[ -n "$WSL_DISTRO_NAME" ]] || grep -qi microsoft /proc/version 2>/dev/null; then
                ENV_TYPE="WSL ($WSL_DISTRO_NAME)"
                if [[ -n "$WT_SESSION" ]]; then
                    TERMINAL_APP="Windows Terminal"
                fi
            elif [[ -n "$JUPYTER_SERVER_ROOT" || -n "$JPY_PARENT_PID" ]]; then
                ENV_TYPE="JupyterLab"
                TERMINAL_APP="Browser"
            else
                ENV_TYPE="Linux"
            fi
            ;;
        MINGW*|MSYS*|CYGWIN*)
            ENV_TYPE="Windows (Git Bash)"
            if [[ -n "$WT_SESSION" ]]; then
                TERMINAL_APP="Windows Terminal"
            elif [[ -n "$ConEmuPID" ]]; then
                TERMINAL_APP="ConEmu"
            fi
            ;;
        *)
            ENV_TYPE="$MACHINE_OS"
            ;;
    esac

    echo "  Machine: $MACHINE_HOSTNAME"
    echo "  OS: $ENV_TYPE"
    [[ -n "$TERMINAL_APP" ]] && echo "  Terminal: $TERMINAL_APP"

    # SSH session info
    if [[ -n "$SSH_CONNECTION" ]]; then
        SSH_FROM=$(echo "$SSH_CONNECTION" | awk '{print $1}')
        echo "  SSH from: $SSH_FROM"
    fi

    # Tmux session info
    if [[ -n "$TMUX" ]]; then
        TMUX_SESSION=$(tmux display-message -p '#{session_name}' 2>/dev/null)
        TMUX_WINDOW=$(tmux display-message -p '#{window_index}' 2>/dev/null)
        TMUX_PANE=$(tmux display-message -p '#{pane_index}' 2>/dev/null)
        echo "  Tmux: $TMUX_SESSION:$TMUX_WINDOW.$TMUX_PANE"

        # Check tmux environment for link info
        LINK_ID=$(tmux show-environment CLAUDE_LINK_ID 2>/dev/null | cut -d= -f2-)
        [[ "$LINK_ID" == "-CLAUDE_LINK_ID" ]] && LINK_ID=""
        if [[ -n "$LINK_ID" ]]; then
            LINK_HOST=$(tmux show-environment CLAUDE_SSH_HOST 2>/dev/null | cut -d= -f2-)
            [[ "$LINK_HOST" == "-CLAUDE_SSH_HOST" ]] && LINK_HOST=""
            echo "  Linked to: $LINK_HOST (link: $LINK_ID)"
        fi
    fi
    echo ""

    # Tunnel/MCP status (check for local services)
    echo "  ┌─────────────────────────────────────────────────────────┐"
    echo "  │ Services                                                │"
    echo "  └─────────────────────────────────────────────────────────┘"

    # Check MCP server
    if is_mcp_server_running; then
        MCP_PORT=$(cat "${CLAUDE_DIR}/.mcp-server.port" 2>/dev/null || echo "8463")
        echo "    MCP Server: ✓ running on port $MCP_PORT"
    else
        echo "    MCP Server: ✗ not running"
    fi

    # Check tunnel (Tailscale Funnel or Localtunnel)
    TUNNEL_URL=""
    TUNNEL_TYPE=""
    if [[ -f "${CLAUDE_DIR}/.tunnel-url" ]]; then
        TUNNEL_URL=$(cat "${CLAUDE_DIR}/.tunnel-url" 2>/dev/null)
        TUNNEL_TYPE=$(cat "${CLAUDE_DIR}/.tunnel-type" 2>/dev/null || echo "unknown")
    elif [[ -f "${CLAUDE_DIR}/.remote-tunnel-url" ]]; then
        TUNNEL_URL=$(cat "${CLAUDE_DIR}/.remote-tunnel-url" 2>/dev/null)
        TUNNEL_TYPE=$(cat "${CLAUDE_DIR}/.remote-tunnel-type" 2>/dev/null || echo "remote")
    fi
    if [[ -n "$TUNNEL_URL" ]]; then
        # Verify tunnel is actually responding
        if curl -sf "${TUNNEL_URL}/health" --max-time 2 >/dev/null 2>&1; then
            echo "    Tunnel: ✓ $TUNNEL_URL ($TUNNEL_TYPE)"
        else
            echo "    Tunnel: ⚠ URL found but not responding"
            echo "            $TUNNEL_URL ($TUNNEL_TYPE)"
        fi
    else
        echo "    Tunnel: ✗ not running"
    fi
    echo ""

    # Registered sessions on this machine
    echo "  ┌─────────────────────────────────────────────────────────┐"
    echo "  │ Registered Sessions                                     │"
    echo "  └─────────────────────────────────────────────────────────┘"

    SESSION_COUNT=0
    if [[ -d "$INSTANCES_DIR" ]]; then
        for f in "$INSTANCES_DIR"/*.json; do
            [[ -f "$f" ]] || continue
            SESSION_COUNT=$((SESSION_COUNT + 1))
            NAME=$(grep -o '"name": *"[^"]*"' "$f" | cut -d'"' -f4)
            HOST=$(grep -o '"hostname": *"[^"]*"' "$f" | cut -d'"' -f4)
            TERM=$(grep -o '"term_type": *"[^"]*"' "$f" | cut -d'"' -f4)
            CREATED=$(grep -o '"created_at": *"[^"]*"' "$f" | cut -d'"' -f4 | cut -dT -f1,2 | tr 'T' ' ')

            # Check if this is our current session
            SESS_ID=$(basename "$f" .json)
            if [[ "$SESS_ID" == "$INSTANCE_ID" ]]; then
                echo "    → $NAME ($TERM) - current session"
            else
                echo "    • $NAME ($TERM) @ $HOST"
            fi
        done
    fi

    if [[ $SESSION_COUNT -eq 0 ]]; then
        echo "    (no sessions registered)"
    fi
    echo ""

    # Links (Mac only, for SSH sessions)
    if [[ -d "${CLAUDE_DIR}/links" ]]; then
        LINK_COUNT=$(find "${CLAUDE_DIR}/links" -name "*.json" 2>/dev/null | wc -l)
        if [[ $LINK_COUNT -gt 0 ]]; then
            echo "  ┌─────────────────────────────────────────────────────────┐"
            echo "  │ Active Links (for SSH sessions)                        │"
            echo "  └─────────────────────────────────────────────────────────┘"

            for f in "${CLAUDE_DIR}/links"/*.json; do
                [[ -f "$f" ]] || continue
                LID=$(basename "$f" .json)
                LTYPE=$(grep -o '"term_type": *"[^"]*"' "$f" | cut -d'"' -f4)
                LCREATED=$(grep -o '"created_at": *"[^"]*"' "$f" | cut -d'"' -f4 | cut -dT -f1,2 | tr 'T' ' ')
                echo "    • $LID ($LTYPE) created $LCREATED"
            done
            echo ""
        fi
    fi

    # Quick help
    echo "  ┌─────────────────────────────────────────────────────────┐"
    echo "  │ Quick Commands                                          │"
    echo "  └─────────────────────────────────────────────────────────┘"
    echo "    claude-slack-notify update    Pull latest & reinstall"
    echo "    claude-slack-notify list      List all sessions"
    echo "    claude-slack-notify stop      Stop this session"
    echo "    /slack-notify                 Register in Claude"
    echo ""

    exit 0
fi

# -----------------------------------------------------------------------------
# Stop - unregister session and stop tunnel (if available)
# Usage: claude-slack-notify stop
# On local Mac: stops tunnel + MCP server + unregisters session
# On remote: just unregisters session (tunnel runs on local Mac)
# -----------------------------------------------------------------------------
if [[ "$1" == "stop" ]]; then
    # Unregister this session
    if [[ -f "$INSTANCE_FILE" ]]; then
        rm -f "$INSTANCE_FILE"
        echo "Session unregistered"
    fi

    # Stop tunnel if available (only on local Mac)
    SLACK_TUNNEL="${CLAUDE_DIR}/bin/local-tunnel"
    if [[ -x "$SLACK_TUNNEL" ]]; then
        "$SLACK_TUNNEL" --stop
    fi
    exit 0
fi

# -----------------------------------------------------------------------------
# Start timing
# Usage: claude-slack-notify start
# -----------------------------------------------------------------------------
if [[ "$1" == "start" ]]; then
    # Only work for registered instances (prevents sub-agents from creating timers)
    # First try direct INSTANCE_FILE lookup, then fall back to TERM_TARGET search
    if [[ ! -f "$INSTANCE_FILE" ]]; then
        detect_terminal
        if [[ -n "$TERM_TARGET" ]]; then
            for candidate_file in "$INSTANCES_DIR"/*.json; do
                [[ -f "$candidate_file" ]] || continue
                candidate_target=$(grep -o '"term_target": *"[^"]*"' "$candidate_file" 2>/dev/null | cut -d'"' -f4)
                if [[ -n "$candidate_target" ]]; then
                    our_tmux="${TERM_TARGET##*|}"
                    our_session="${our_tmux%%:*}"
                    cand_tmux="${candidate_target##*|}"
                    cand_session="${cand_tmux%%:*}"
                    if [[ "$our_session" == "$cand_session" ]]; then
                        INSTANCE_FILE="$candidate_file"
                        INSTANCE_ID=$(basename "$candidate_file" .json)
                        TIMESTAMP_FILE="/tmp/claude-prompt-start-${INSTANCE_ID}"
                        break
                    fi
                fi
            done
        fi
        if [[ ! -f "$INSTANCE_FILE" ]]; then
            exit 0
        fi
    fi

    # Only start a new timer if one isn't already running
    # This preserves the original start time across multiple rapid tool calls
    if [[ ! -f "$TIMESTAMP_FILE" ]]; then
        date +%s > "$TIMESTAMP_FILE"
    fi
    exit 0
fi

# -----------------------------------------------------------------------------
# Check elapsed time and notify if needed
# Usage: claude-slack-notify check [context]
# Hook events pass JSON via stdin with tool_name, tool_input, transcript_path, etc.
# -----------------------------------------------------------------------------

# Comprehensive tool formatter - converts tool_name + tool_input to readable text
# Usage: echo '{"name":"Bash","input":{...}}' | jq -r "$TOOL_FORMATTER"
# The jq filter expects an object with .name and .input fields
TOOL_FORMATTER='
def format_tool:
    if .name == "Bash" then
        "● Bash: " + ((.input.command // "") | split("\n")[0] | .[0:80]) +
        (if (.input.description // "") != "" then " (" + .input.description + ")" else "" end)
    elif .name == "Edit" then
        "● Edit: " + (.input.file_path // "") +
        (if (.input.old_string // "") != "" then " (replacing " + ((.input.old_string // "") | .[0:30]) + "...)" else "" end)
    elif .name == "Write" then
        "● Write: " + (.input.file_path // "")
    elif .name == "Read" then
        "● Read: " + (.input.file_path // "") +
        (if (.input.offset // 0) > 0 then " (from line " + ((.input.offset // 0) | tostring) + ")" else "" end)
    elif .name == "Glob" or .name == "Search" then
        "● " + .name + ": " + (.input.pattern // "") +
        (if (.input.path // "") != "" then " in " + .input.path else "" end)
    elif .name == "Grep" then
        "● Grep: " + (.input.pattern // "") +
        (if (.input.path // "") != "" then " in " + .input.path else "" end)
    elif .name == "AskUserQuestion" then
        [.input.questions[] |
            "❓ " + .question + "\n" +
            ([.options // [] | to_entries[] |
                "   " + ((.key + 1) | tostring) + ". " + .value.label +
                (if (.value.description // "") != "" then " - " + .value.description else "" end)
            ] | join("\n"))
        ] | join("\n\n")
    elif .name == "Task" then
        "● Task (" + (.input.subagent_type // "agent") + "): " +
        (if (.input.description // "") != "" then .input.description
         elif (.input.prompt // "") != "" then ((.input.prompt // "") | .[0:100])
         else "running subagent" end)
    elif .name == "WebFetch" then
        "● WebFetch: " + (.input.url // "") +
        (if (.input.prompt // "") != "" then "\n  Prompt: " + ((.input.prompt // "") | .[0:80]) else "" end)
    elif .name == "WebSearch" then
        "● WebSearch: " + (.input.query // "")
    elif .name == "TodoWrite" then
        "● TodoWrite: " + (
            [.input.todos[]? | select(.status == "in_progress") | .content] |
            if length > 0 then "Working on: " + (.[0] // "")
            else ([.input.todos[]?.content] | length | tostring) + " tasks"
            end
        )
    elif .name == "NotebookEdit" then
        "● NotebookEdit: " + (.input.notebook_path // "") +
        (if (.input.edit_mode // "") != "" then " (" + .input.edit_mode + ")" else "" end)
    elif .name == "Skill" then
        "● Skill: /" + (.input.skill // "") +
        (if (.input.args // "") != "" then " " + .input.args else "" end)
    elif .name == "EnterPlanMode" then
        "● Entering plan mode"
    elif .name == "ExitPlanMode" then
        "● Exiting plan mode"
    elif .name == "TaskCreate" then
        "● TaskCreate: " + (.input.subject // "new task")
    elif .name == "TaskUpdate" then
        "● TaskUpdate: " + (.input.taskId // "") +
        (if (.input.status // "") != "" then " → " + .input.status else "" end)
    elif .name == "TaskGet" then
        "● TaskGet: " + (.input.taskId // "")
    elif .name == "TaskList" then
        "● TaskList"
    elif .name == "TaskOutput" then
        "● TaskOutput: " + (.input.task_id // "")
    elif .name == "KillShell" then
        "● KillShell: " + (.input.shell_id // "")
    elif (.name | contains("browser_navigate")) then
        "● 🌐 Navigate: " + (.input.url // "")
    elif (.name | contains("browser_click")) then
        "● 🖱️ Click: " + (.input.element // "element")
    elif (.name | contains("browser_type")) then
        "● ⌨️ Type: " + ((.input.text // "") | .[0:40]) + (if (.input.element // "") != "" then " in " + .input.element else "" end)
    elif (.name | contains("browser_snapshot")) then
        "● 📸 Browser snapshot"
    elif (.name | contains("browser_take_screenshot")) then
        "● 📷 Screenshot" + (if (.input.element // "") != "" then ": " + .input.element else "" end)
    elif (.name | contains("browser_fill_form")) then
        "● 📝 Fill form: " + ((.input.fields // []) | length | tostring) + " fields"
    elif (.name | contains("browser_select_option")) then
        "● 📋 Select: " + ((.input.values // []) | join(", "))
    elif (.name | contains("browser_hover")) then
        "● 👆 Hover: " + (.input.element // "element")
    elif (.name | contains("browser_press_key")) then
        "● ⌨️ Press: " + (.input.key // "key")
    elif (.name | contains("browser_wait_for")) then
        "● ⏳ Wait: " + (if (.input.text // "") != "" then "\"" + .input.text + "\"" elif (.input.time // 0) > 0 then (.input.time | tostring) + "s" else "condition" end)
    elif (.name | startswith("mcp__")) then
        # MCP tools: mcp__server__tool format
        "● MCP: " + ((.name | split("__") | .[1:] | join("/")) // .name) +
        (if (.input | keys | length) > 0 then
            " (" + ([.input | to_entries[] | select(.value != null and .value != "") | .key + "=" + (.value | tostring | .[0:20])] | .[0:3] | join(", ")) + ")"
         else "" end)
    else
        "● " + .name +
        (if (.input.description // "") != "" then ": " + .input.description
         elif (.input.file_path // "") != "" then ": " + .input.file_path
         elif (.input.pattern // "") != "" then ": " + .input.pattern + (if (.input.path // "") != "" then " in " + .input.path else "" end)
         elif (.input.prompt // "") != "" then ": " + ((.input.prompt // "") | .[0:80])
         elif (.input | keys | length) > 0 then ": " + ([.input | to_entries[] | select(.value != null and .value != "") | .key + "=" + (.value | tostring | .[0:30])] | .[0:2] | join(", "))
         else "" end)
    end;
format_tool
'

# Waiting variant of tool formatter (with ⏳ prefix for pending permissions, ❓ for questions)
TOOL_FORMATTER_WAITING='
def format_tool_waiting:
    if .name == "Bash" then
        "⏳ Bash: " + ((.input.command // "") | split("\n")[0] | .[0:80]) +
        (if (.input.description // "") != "" then " (" + .input.description + ")" else "" end)
    elif .name == "Edit" then
        "⏳ Edit: " + (.input.file_path // "") +
        (if (.input.old_string // "") != "" then " (replacing " + ((.input.old_string // "") | .[0:30]) + "...)" else "" end)
    elif .name == "Write" then
        "⏳ Write: " + (.input.file_path // "")
    elif .name == "Read" then
        "⏳ Read: " + (.input.file_path // "") +
        (if (.input.offset // 0) > 0 then " (from line " + ((.input.offset // 0) | tostring) + ")" else "" end)
    elif .name == "Glob" or .name == "Search" then
        "⏳ " + .name + ": " + (.input.pattern // "") +
        (if (.input.path // "") != "" then " in " + .input.path else "" end)
    elif .name == "Grep" then
        "⏳ Grep: " + (.input.pattern // "") +
        (if (.input.path // "") != "" then " in " + .input.path else "" end)
    elif .name == "AskUserQuestion" then
        [.input.questions[] |
            "❓ " + .question + "\n" +
            ([.options // [] | to_entries[] |
                "   " + ((.key + 1) | tostring) + ". " + .value.label +
                (if (.value.description // "") != "" then " - " + .value.description else "" end)
            ] | join("\n"))
        ] | join("\n\n")
    elif .name == "Task" then
        "⏳ Task (" + (.input.subagent_type // "agent") + "): " +
        (if (.input.description // "") != "" then .input.description
         elif (.input.prompt // "") != "" then ((.input.prompt // "") | .[0:100])
         else "running subagent" end)
    elif .name == "WebFetch" then
        "⏳ WebFetch: " + (.input.url // "")
    elif .name == "WebSearch" then
        "⏳ WebSearch: " + (.input.query // "")
    elif .name == "Skill" then
        "⏳ Skill: /" + (.input.skill // "")
    elif .name == "EnterPlanMode" then
        "⏳ Entering plan mode"
    elif .name == "ExitPlanMode" then
        "⏳ Exiting plan mode - awaiting approval"
    elif .name == "TaskCreate" then
        "⏳ TaskCreate: " + (.input.subject // "new task")
    elif .name == "TaskUpdate" then
        "⏳ TaskUpdate: " + (.input.taskId // "") +
        (if (.input.status // "") != "" then " → " + .input.status else "" end)
    elif .name == "TaskGet" then
        "⏳ TaskGet: " + (.input.taskId // "")
    elif .name == "TaskList" then
        "⏳ TaskList"
    elif .name == "TaskOutput" then
        "⏳ TaskOutput: " + (.input.task_id // "")
    elif .name == "KillShell" then
        "⏳ KillShell: " + (.input.shell_id // "")
    elif (.name | contains("browser_navigate")) then
        "⏳ 🌐 Navigate: " + (.input.url // "")
    elif (.name | contains("browser_click")) then
        "⏳ 🖱️ Click: " + (.input.element // "element")
    elif (.name | contains("browser_type")) then
        "⏳ ⌨️ Type: " + ((.input.text // "") | .[0:40]) + (if (.input.element // "") != "" then " in " + .input.element else "" end)
    elif (.name | contains("browser_snapshot")) then
        "⏳ 📸 Browser snapshot"
    elif (.name | contains("browser_take_screenshot")) then
        "⏳ 📷 Screenshot" + (if (.input.element // "") != "" then ": " + .input.element else "" end)
    elif (.name | contains("browser_fill_form")) then
        "⏳ 📝 Fill form: " + ((.input.fields // []) | length | tostring) + " fields"
    elif (.name | contains("browser_select_option")) then
        "⏳ 📋 Select: " + ((.input.values // []) | join(", "))
    elif (.name | contains("browser_hover")) then
        "⏳ 👆 Hover: " + (.input.element // "element")
    elif (.name | contains("browser_press_key")) then
        "⏳ ⌨️ Press: " + (.input.key // "key")
    elif (.name | contains("browser_wait_for")) then
        "⏳ ⏳ Wait: " + (if (.input.text // "") != "" then "\"" + .input.text + "\"" elif (.input.time // 0) > 0 then (.input.time | tostring) + "s" else "condition" end)
    elif (.name | startswith("mcp__")) then
        "⏳ MCP: " + ((.name | split("__") | .[1:] | join("/")) // .name) +
        (if (.input | keys | length) > 0 then
            " (" + ([.input | to_entries[] | select(.value != null and .value != "") | .key + "=" + (.value | tostring | .[0:30])] | .[0:3] | join(", ")) + ")"
         else "" end)
    else
        "⏳ " + .name +
        (if (.input.description // "") != "" then ": " + .input.description
         elif (.input.file_path // "") != "" then ": " + .input.file_path
         elif (.input.pattern // "") != "" then ": " + .input.pattern + (if (.input.path // "") != "" then " in " + .input.path else "" end)
         elif (.input.prompt // "") != "" then ": " + ((.input.prompt // "") | .[0:80])
         elif (.input | keys | length) > 0 then ": " + ([.input | to_entries[] | select(.value != null and .value != "") | .key + "=" + (.value | tostring | .[0:30])] | .[0:2] | join(", "))
         else "" end)
    end;
format_tool_waiting
'

if [[ "$1" == "check" ]]; then
    # Only work for registered instances (prevents sub-agents from notifying)
    # First try direct INSTANCE_FILE lookup, then fall back to TERM_TARGET search
    if [[ ! -f "$INSTANCE_FILE" ]]; then
        # Try TERM_TARGET fallback
        detect_terminal
        if [[ -n "$TERM_TARGET" ]]; then
            for candidate_file in "$INSTANCES_DIR"/*.json; do
                [[ -f "$candidate_file" ]] || continue
                candidate_target=$(grep -o '"term_target": *"[^"]*"' "$candidate_file" 2>/dev/null | cut -d'"' -f4)
                if [[ -n "$candidate_target" ]]; then
                    our_tmux="${TERM_TARGET##*|}"
                    our_session="${our_tmux%%:*}"
                    cand_tmux="${candidate_target##*|}"
                    cand_session="${cand_tmux%%:*}"
                    if [[ "$our_session" == "$cand_session" ]]; then
                        INSTANCE_FILE="$candidate_file"
                        INSTANCE_ID=$(basename "$candidate_file" .json)
                        break
                    fi
                fi
            done
        fi
        # If still not found, exit
        if [[ ! -f "$INSTANCE_FILE" ]]; then
            exit 0
        fi
    fi

    # Read stdin to get hook event data
    STDIN_DATA=""
    HOOK_EVENT=""
    NOTIF_MSG=""
    NOTIF_TYPE=""
    DIRECT_TOOL_MSG=""
    TRANSCRIPT_MSG=""

    if [[ ! -t 0 ]]; then
        STDIN_DATA=$(timeout 1 cat 2>/dev/null || true)
        if [[ -n "$STDIN_DATA" ]] && command -v jq &>/dev/null; then
            HOOK_EVENT=$(echo "$STDIN_DATA" | jq -r '.hook_event_name // empty' 2>/dev/null)

            # For PermissionRequest: extract tool info directly from stdin (most reliable)
            if [[ "$HOOK_EVENT" == "PermissionRequest" ]]; then
                TOOL_NAME=$(echo "$STDIN_DATA" | jq -r '.tool_name // empty' 2>/dev/null)
                if [[ -n "$TOOL_NAME" ]]; then
                    DIRECT_TOOL_MSG=$(echo "$STDIN_DATA" | jq -r --argjson fmt "$TOOL_FORMATTER_WAITING" '
                        {name: .tool_name, input: .tool_input} | '"$TOOL_FORMATTER_WAITING" 2>/dev/null)
                fi
            fi

            # For Notification: extract message and notification_type
            if [[ "$HOOK_EVENT" == "Notification" ]]; then
                NOTIF_MSG=$(echo "$STDIN_DATA" | jq -r '.message // empty' 2>/dev/null)
                NOTIF_TYPE=$(echo "$STDIN_DATA" | jq -r '.notification_type // empty' 2>/dev/null)

                # Also check if tool info is available in stdin (some Notification events include it)
                TOOL_NAME=$(echo "$STDIN_DATA" | jq -r '.tool_name // empty' 2>/dev/null)
                if [[ -n "$TOOL_NAME" ]]; then
                    DIRECT_TOOL_MSG=$(echo "$STDIN_DATA" | jq -r '
                        {name: .tool_name, input: .tool_input} | '"$TOOL_FORMATTER_WAITING" 2>/dev/null)
                fi
            fi

            # Get last assistant message from transcript for additional context
            TRANSCRIPT_PATH=$(echo "$STDIN_DATA" | jq -r '.transcript_path // empty' 2>/dev/null)
            if [[ -n "$TRANSCRIPT_PATH" && -f "$TRANSCRIPT_PATH" ]]; then
                # Extract full assistant message content (text + tool calls)
                TRANSCRIPT_MSG=$(tac "$TRANSCRIPT_PATH" 2>/dev/null | while read -r line; do
                    MSG_TYPE=$(echo "$line" | jq -r '.type // empty' 2>/dev/null)
                    if [[ "$MSG_TYPE" == "assistant" ]]; then
                        # Build full content: text blocks + tool descriptions
                        FULL_CONTENT=$(echo "$line" | jq -r '
                            if .message.content then
                                [.message.content[] |
                                    if .type == "text" then
                                        .text
                                    elif .type == "tool_use" then
                                        {name: .name, input: .input} | '"$TOOL_FORMATTER"'
                                    else
                                        empty
                                    end
                                ] | map(select(. != null and . != "")) | join("\n")
                            else
                                empty
                            end
                        ' 2>/dev/null)
                        if [[ -n "$FULL_CONTENT" ]]; then
                            echo "$FULL_CONTENT"
                            break
                        fi
                    fi
                done)

                # For Notification events without direct tool info, extract from transcript
                if [[ "$HOOK_EVENT" == "Notification" && -z "$DIRECT_TOOL_MSG" ]]; then
                    TOOL_REQUEST=$(tac "$TRANSCRIPT_PATH" 2>/dev/null | while read -r line; do
                        MSG_TYPE=$(echo "$line" | jq -r '.type // empty' 2>/dev/null)
                        if [[ "$MSG_TYPE" == "assistant" ]]; then
                            TOOL_INFO=$(echo "$line" | jq -r '
                                if .message.content then
                                    [.message.content[] | select(.type == "tool_use")] | last |
                                        if . then
                                            {name: .name, input: .input} | '"$TOOL_FORMATTER_WAITING"'
                                        else
                                            empty
                                        end
                                else
                                    empty
                                end
                            ' 2>/dev/null)
                            if [[ -n "$TOOL_INFO" ]]; then
                                echo "$TOOL_INFO"
                                break
                            fi
                        fi
                    done)

                    if [[ -n "$TOOL_REQUEST" ]]; then
                        DIRECT_TOOL_MSG="$TOOL_REQUEST"
                    fi
                fi
            fi
        fi
    fi

    # Calculate elapsed time if timestamp exists
    ELAPSED=0
    if [[ -f "$TIMESTAMP_FILE" ]]; then
        START_TIME=$(cat "$TIMESTAMP_FILE")
        NOW=$(date +%s)
        ELAPSED=$((NOW - START_TIME))
    fi

    # Events that require immediate user input - always notify immediately
    # Other events (Stop, SubagentStop) only notify if elapsed >= threshold
    if [[ "$HOOK_EVENT" == "Notification" || "$HOOK_EVENT" == "PermissionRequest" ]]; then
        # Always notify for user input events - user needs to respond
        rm -f "$TIMESTAMP_FILE"
    elif [[ $ELAPSED -lt $MIN_DURATION ]]; then
        # Below threshold and not a user input event - skip
        exit 0
    else
        # Threshold exceeded - clear timestamp and notify
        rm -f "$TIMESTAMP_FILE"
    fi

    # Build context: use direct tool info when available (most accurate for user-facing prompts)
    # For user-input events (PermissionRequest, Notification), always use waiting format (⏳)
    CONTEXT=""
    if [[ -n "$DIRECT_TOOL_MSG" ]]; then
        # Direct tool info from stdin - use this for the waiting prompt
        CONTEXT="$DIRECT_TOOL_MSG"
    elif [[ -n "$TRANSCRIPT_MSG" ]]; then
        # For permission/notification events, convert bullet (●) to hourglass (⏳) to show waiting
        if [[ "$HOOK_EVENT" == "Notification" || "$HOOK_EVENT" == "PermissionRequest" ]]; then
            CONTEXT=$(echo "$TRANSCRIPT_MSG" | sed 's/^● /⏳ /; s/\n● /\n⏳ /g')
        else
            CONTEXT="$TRANSCRIPT_MSG"
        fi
        if [[ -n "$NOTIF_MSG" ]]; then
            CONTEXT="${CONTEXT}

---
*${NOTIF_MSG}*"
        fi
    elif [[ -n "$NOTIF_MSG" ]]; then
        CONTEXT="$NOTIF_MSG"
    fi

    # Deduplication: skip if we already notified for this tool_use_id
    # This prevents double notifications when multiple hooks fire for the same event
    DEDUP_DIR="/tmp/claude-slack-dedup"
    DEDUP_WINDOW=10
    NOW_TS=$(date +%s)

    # Use tool_use_id if available (unique per tool call), otherwise use content hash
    TOOL_USE_ID=""
    if [[ -n "$STDIN_DATA" ]] && command -v jq &>/dev/null; then
        TOOL_USE_ID=$(echo "$STDIN_DATA" | jq -r '.tool_use_id // empty' 2>/dev/null)
    fi

    if [[ -n "$TOOL_USE_ID" ]]; then
        DEDUP_KEY="$TOOL_USE_ID"
    else
        # Fallback to content hash with normalization
        NORMALIZED_CONTEXT=$(echo "$CONTEXT" | LC_ALL=C sed 's/^[^a-zA-Z0-9]*//g')
        DEDUP_KEY=$(echo "${INSTANCE_ID}:${NORMALIZED_CONTEXT}" | md5sum | cut -d' ' -f1)
    fi

    # Create dedup directory
    mkdir -p "$DEDUP_DIR"
    DEDUP_FILE="${DEDUP_DIR}/${DEDUP_KEY}"

    # Check if we recently sent this notification (with file locking to handle race condition)
    if [[ -f "$DEDUP_FILE" ]]; then
        LAST_TS=$(cat "$DEDUP_FILE" 2>/dev/null)
        if [[ -n "$LAST_TS" ]]; then
            AGE=$((NOW_TS - LAST_TS))
            if [[ $AGE -lt $DEDUP_WINDOW ]]; then
                # Same notification sent recently, skip
                exit 0
            fi
        fi
    fi

    # Mark this notification as sent (atomic write to handle race)
    echo "$NOW_TS" > "${DEDUP_FILE}.tmp.$$" && mv "${DEDUP_FILE}.tmp.$$" "$DEDUP_FILE"

    # Clean up old dedup files (older than 1 minute)
    find "$DEDUP_DIR" -type f -mmin +1 -delete 2>/dev/null || true

    # Truncate if too long for Slack (max ~2800 chars to leave room for header)
    MAX_CONTEXT_LEN=2800
    if [[ ${#CONTEXT} -gt $MAX_CONTEXT_LEN ]]; then
        CONTEXT="${CONTEXT:0:$MAX_CONTEXT_LEN}

_…[truncated - see terminal for full output]_"
    fi

    # Build message
    if [[ -n "$CONTEXT" ]]; then
        if [[ $ELAPSED -gt 0 ]]; then
            MESSAGE="${CONTEXT} (${ELAPSED}s)"
        else
            MESSAGE="$CONTEXT"
        fi
    else
        MESSAGE="Task completed (${ELAPSED}s)"
    fi
else
    # Direct call with arguments: $1=title, $2=status, $3=context (optional)
    TITLE="${1:-Ready for input}"
    CONTEXT_ARG="${3:-}"

    if [[ -n "$CONTEXT_ARG" ]]; then
        # If context provided as $3, use it with title as header
        MESSAGE="${TITLE}

${CONTEXT_ARG}"
    else
        MESSAGE="$TITLE"
    fi
fi

STATUS="${2:-waiting}"

# -----------------------------------------------------------------------------
# Get webhook URL
# -----------------------------------------------------------------------------
if [[ -f "$WEBHOOK_FILE" ]]; then
    WEBHOOK_URL=$(cat "$WEBHOOK_FILE")
elif [[ -n "$SLACK_WEBHOOK_URL" ]]; then
    WEBHOOK_URL="$SLACK_WEBHOOK_URL"
else
    exit 0
fi

# -----------------------------------------------------------------------------
# Load instance info and detect terminal
# -----------------------------------------------------------------------------
INSTANCE_NAME="Claude"
HOSTNAME=$(hostname -s 2>/dev/null || echo "unknown")

# Dynamically detect current terminal first (needed for TERM_TARGET fallback)
detect_terminal

# Try to load instance by INSTANCE_ID first
if [[ -n "$INSTANCE_FILE" && -f "$INSTANCE_FILE" ]]; then
    INSTANCE_NAME=$(grep -o '"name": *"[^"]*"' "$INSTANCE_FILE" | cut -d'"' -f4)
    HOSTNAME=$(grep -o '"hostname": *"[^"]*"' "$INSTANCE_FILE" | cut -d'"' -f4)
fi

# FALLBACK: If INSTANCE_FILE not found but we have TERM_TARGET, search by terminal
# This handles cases where session_id changed (project switch, conversation compaction)
if [[ ! -f "$INSTANCE_FILE" && -n "$TERM_TARGET" ]]; then
    for candidate_file in "$INSTANCES_DIR"/*.json; do
        [[ -f "$candidate_file" ]] || continue
        candidate_target=$(grep -o '"term_target": *"[^"]*"' "$candidate_file" 2>/dev/null | cut -d'"' -f4)
        if [[ -n "$candidate_target" ]]; then
            # Extract tmux session name from both targets for comparison
            # TERM_TARGET format: tmux_session:window.pane or LINK_ID|HOST|USER|PORT|tmux_session:window.pane
            our_tmux="${TERM_TARGET##*|}"      # Get part after last |
            our_session="${our_tmux%%:*}"       # Get session name before :
            cand_tmux="${candidate_target##*|}"
            cand_session="${cand_tmux%%:*}"

            if [[ "$our_session" == "$cand_session" ]]; then
                INSTANCE_FILE="$candidate_file"
                INSTANCE_ID=$(basename "$candidate_file" .json)
                INSTANCE_NAME=$(grep -o '"name": *"[^"]*"' "$INSTANCE_FILE" | cut -d'"' -f4)
                HOSTNAME=$(grep -o '"hostname": *"[^"]*"' "$INSTANCE_FILE" | cut -d'"' -f4)
                break
            fi
        fi
    done
fi

# Fallback to stored values if detection failed or FOCUS_URL is empty
# This handles: Docker containers, SSH sessions where CLAUDE_LINK_ID isn't in hook env
if [[ -f "$INSTANCE_FILE" ]]; then
    if [[ "$TERM_TYPE" == "unknown" || "$TERM_TYPE" == "ssh" || -z "$FOCUS_URL" ]]; then
        STORED_FOCUS_URL=$(grep -o '"focus_url": *"[^"]*"' "$INSTANCE_FILE" | cut -d'"' -f4)
        if [[ -n "$STORED_FOCUS_URL" ]]; then
            TERM_TYPE=$(grep -o '"term_type": *"[^"]*"' "$INSTANCE_FILE" | cut -d'"' -f4)
            TERM_TARGET=$(grep -o '"term_target": *"[^"]*"' "$INSTANCE_FILE" | cut -d'"' -f4)
            FOCUS_URL="$STORED_FOCUS_URL"

            # For linked sessions, update the tmux target dynamically (user may have switched windows)
            if [[ "$TERM_TYPE" == "ssh-linked" || "$TERM_TYPE" == "jupyter-tmux" ]] && [[ -n "$TMUX" ]]; then
                local current_session current_window current_pane new_tmux_target
                current_session=$(tmux display-message -p '#{session_name}' 2>/dev/null)
                current_window=$(tmux display-message -p '#{window_index}' 2>/dev/null)
                current_pane=$(tmux display-message -p '#{pane_index}' 2>/dev/null)
                new_tmux_target="${current_session}:${current_window}.${current_pane}"

                # Update FOCUS_URL with current tmux target (replace last path segment)
                # Format: claude-focus://ssh-linked/LINK_ID/HOST/USER/PORT/TMUX_TARGET
                FOCUS_URL=$(echo "$FOCUS_URL" | sed "s|/[^/]*$|/$(url_encode "$new_tmux_target")|")
                # Also update TERM_TARGET (last field after |)
                TERM_TARGET=$(echo "$TERM_TARGET" | sed "s|[^|]*$|$new_tmux_target|")
            fi
        fi
    fi
fi

# -----------------------------------------------------------------------------
# Build notification
# -----------------------------------------------------------------------------
case "$STATUS" in
    started)  COLOR="#8B9A6B" ;;  # warm olive-gold
    waiting)  COLOR="#C9A66B" ;;  # warm amber sand
    error)    COLOR="#C47070" ;;  # warm coral
    *)        COLOR="#B8A99A" ;;  # sand/taupe
esac

# Build location string (keep it short for Slack display)
LOCATION="$HOSTNAME"
if [[ -n "$TERM_TYPE" && "$TERM_TYPE" != "unknown" ]]; then
    # Extract just the tmux session:window.pane if present (skip the /dev/tty part)
    DISPLAY_TARGET="$TERM_TARGET"
    if [[ "$TERM_TARGET" == *"|"* ]]; then
        DISPLAY_TARGET="${TERM_TARGET#*|}"
    fi
    # Simplify term type for display
    case "$TERM_TYPE" in
        iterm-tmux|terminal-tmux|wt-tmux|wsl-tmux|linux-tmux)
            LOCATION="$HOSTNAME (tmux $DISPLAY_TARGET)" ;;
        *)
            LOCATION="$HOSTNAME ($TERM_TYPE)" ;;
    esac
fi

# Escape all user-controllable values for safe JSON embedding
SAFE_INSTANCE_NAME=$(json_escape "$INSTANCE_NAME")
SAFE_HOSTNAME=$(json_escape "$HOSTNAME")
SAFE_LOCATION=$(json_escape "$LOCATION")
# Convert standard markdown to Slack mrkdwn format, then escape for JSON
SAFE_MESSAGE=$(json_escape "$(markdown_to_mrkdwn "$MESSAGE")")
SAFE_FOCUS_URL=$(json_escape "$FOCUS_URL")

# Build button block if we have a focus URL
BUTTON_BLOCK=""
if [[ -n "$FOCUS_URL" ]]; then
    # Check if MCP server is running for hybrid button support
    # For linked sessions (ssh-linked, jupyter-tmux), assume MCP server is on the local machine
    # which we can't reach from here - use interactive buttons (they'll route through the tunnel)
    MCP_SERVER_RUNNING=""
    if [[ "$TERM_TYPE" == "ssh-linked" || "$TERM_TYPE" == "jupyter-tmux" ]]; then
        # Linked session: MCP server is on local machine, use interactive buttons
        MCP_SERVER_RUNNING="1"
    elif is_mcp_server_running; then
        MCP_SERVER_RUNNING="1"
    fi

    # Check for dynamic question options (from AskUserQuestion)
    DYNAMIC_BUTTONS=""
    if [[ -n "$CLAUDE_QUESTION_OPTS_FILE" && -f "$CLAUDE_QUESTION_OPTS_FILE" ]]; then
        # Extract options from the question file and build button config
        # Format: label|action (action is the 1-indexed option number)
        DYNAMIC_BUTTONS=$(jq -r '
            .[0].options // [] |
            to_entries |
            map("\(.value.label)|\(.key + 1)") |
            .[]
        ' "$CLAUDE_QUESTION_OPTS_FILE" 2>/dev/null)
    fi

    # Read button config or use defaults
    BUTTON_CONFIG="$CLAUDE_DIR/button-config"
    if [[ -n "$DYNAMIC_BUTTONS" ]]; then
        # Use dynamic buttons from AskUserQuestion
        BUTTON_CONFIG_CONTENT="$DYNAMIC_BUTTONS"
    elif [[ ! -f "$BUTTON_CONFIG" ]]; then
        # Default buttons if no config exists
        BUTTON_CONFIG_CONTENT="1|1
2|2
Continue|continue
Push|push"
    else
        BUTTON_CONFIG_CONTENT=$(cat "$BUTTON_CONFIG")
    fi

    # Always use URL-first format for button values (more robust)
    # This embeds the focus URL directly, eliminating session file lookup
    # Benefits: works across project switches, conversation compaction, etc.
    if [[ -n "$FOCUS_URL" ]]; then
        BUTTON_VALUE_PREFIX="url:${FOCUS_URL}"
    else
        # Fallback to instance ID only if focus URL unavailable (shouldn't happen)
        BUTTON_VALUE_PREFIX="${INSTANCE_ID}"
    fi

    # Build action buttons from config
    ACTION_BUTTONS=""
    BUTTON_COUNT=0
    while IFS='|' read -r label action || [[ -n "$label" ]]; do
        # Skip empty lines and comments
        [[ -z "$label" || "$label" == \#* ]] && continue

        # URL encode the action
        safe_action=$(json_escape "${FOCUS_URL}?action=$(url_encode "$action")")
        safe_label=$(json_escape "$label")

        # Build button with action_id when MCP server running (works on mobile + desktop)
        # Otherwise use url (desktop-only with custom URL scheme)
        if [[ -n "$MCP_SERVER_RUNNING" ]]; then
            # Interactive button: action_id/value only, no url (works on mobile)
            ACTION_BUTTONS="${ACTION_BUTTONS},
        {
          \"type\": \"button\",
          \"text\": { \"type\": \"plain_text\", \"text\": \"${safe_label}\" },
          \"action_id\": \"session_action_${BUTTON_COUNT}\",
          \"value\": \"${BUTTON_VALUE_PREFIX}|${action}\"
        }"
        else
            # Desktop-only button: just url (custom URL scheme)
            ACTION_BUTTONS="${ACTION_BUTTONS},
        {
          \"type\": \"button\",
          \"text\": { \"type\": \"plain_text\", \"text\": \"${safe_label}\" },
          \"url\": \"${safe_action}\"
        }"
        fi
        ((BUTTON_COUNT++))
    done <<< "$BUTTON_CONFIG_CONTENT"

    # Build Focus button: interactive when MCP server running, url-based otherwise
    if [[ -n "$MCP_SERVER_RUNNING" ]]; then
        FOCUS_BUTTON="{
          \"type\": \"button\",
          \"text\": { \"type\": \"plain_text\", \"text\": \"Focus\" },
          \"style\": \"primary\",
          \"action_id\": \"session_focus\",
          \"value\": \"${BUTTON_VALUE_PREFIX}|focus\"
        }"
    else
        FOCUS_BUTTON="{
          \"type\": \"button\",
          \"text\": { \"type\": \"plain_text\", \"text\": \"Focus\" },
          \"url\": \"${SAFE_FOCUS_URL}\",
          \"style\": \"primary\"
        }"
    fi

    BUTTON_BLOCK=",{
      \"type\": \"actions\",
      \"elements\": [
        ${FOCUS_BUTTON}${ACTION_BUTTONS}
      ]
    }"
fi

# Build the message payload (used by both API and webhook)
MESSAGE_PAYLOAD="{
    \"attachments\": [
      {
        \"fallback\": \"${SAFE_INSTANCE_NAME}: ${SAFE_MESSAGE}\",
        \"color\": \"${COLOR}\",
        \"blocks\": [
          {
            \"type\": \"section\",
            \"text\": {
              \"type\": \"mrkdwn\",
              \"text\": \"*${SAFE_INSTANCE_NAME}* on \`${SAFE_LOCATION}\`\n${SAFE_MESSAGE}\"
            }
          }${BUTTON_BLOCK}
        ]
      }
    ]
  }"

# Try to use Slack API (enables thread replies) if bot token is configured
USE_API=""
if [[ -f "$SLACK_CONFIG" ]]; then
    source "$SLACK_CONFIG"
    if [[ -n "$SLACK_BOT_TOKEN" && -n "$SLACK_CHANNEL_ID" ]]; then
        USE_API="1"
    fi
fi

if [[ -n "$USE_API" ]]; then
    # Use chat.postMessage API - enables thread replies
    API_PAYLOAD=$(echo "$MESSAGE_PAYLOAD" | jq --arg channel "$SLACK_CHANNEL_ID" '. + {channel: $channel}')

    RESPONSE=$(curl -s -X POST \
        -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
        -H "Content-type: application/json; charset=utf-8" \
        --data "$API_PAYLOAD" \
        "https://slack.com/api/chat.postMessage" \
        --max-time 30)

    # Save thread mapping if successful
    if echo "$RESPONSE" | jq -e '.ok == true' > /dev/null 2>&1; then
        THREAD_TS=$(echo "$RESPONSE" | jq -r '.ts')
        if [[ -n "$THREAD_TS" && "$THREAD_TS" != "null" ]]; then
            mkdir -p "$THREADS_DIR"
            # Save thread info for reply routing
            cat > "${THREADS_DIR}/${THREAD_TS}.json" <<EOF
{
  "thread_ts": "$THREAD_TS",
  "session_id": "$INSTANCE_ID",
  "focus_url": "$FOCUS_URL",
  "instance_name": "$INSTANCE_NAME",
  "created": "$(date -Iseconds)"
}
EOF
            # Register thread with Mac's MCP server (for SSH-linked sessions)
            # This allows thread replies from Slack to be forwarded to this terminal
            MAC_TUNNEL_URL=""
            if [[ -f "${CLAUDE_DIR}/.mac-tunnel-url" ]]; then
                MAC_TUNNEL_URL=$(cat "${CLAUDE_DIR}/.mac-tunnel-url" 2>/dev/null)
            fi
            if [[ -n "$MAC_TUNNEL_URL" && -n "$FOCUS_URL" ]]; then
                # Register in background to not slow down notification
                (curl -s -X POST \
                    -H 'Content-type: application/json' \
                    --data "{\"thread_ts\":\"$THREAD_TS\",\"session_id\":\"$INSTANCE_ID\",\"focus_url\":\"$FOCUS_URL\",\"instance_name\":\"$INSTANCE_NAME\"}" \
                    "${MAC_TUNNEL_URL}/slack/register-thread" \
                    --max-time 5 >/dev/null 2>&1) &
            fi
        fi
    fi
else
    # Fall back to webhook (no thread reply support)
    curl -s -X POST -H 'Content-type: application/json' \
        --data "$MESSAGE_PAYLOAD" \
        "$WEBHOOK_URL" --max-time 30 > /dev/null 2>&1
fi
