#!/bin/bash
# =============================================================================
# slack-tunnel - Start tunnel for Slack button actions
#
# Uses Cloudflare Quick Tunnels (random URL, no account needed) and
# automatically updates Slack's Request URL via API.
#
# Commands:
#   slack-tunnel          - Start tunnel (interactive)
#   slack-tunnel --setup  - One-time setup: configure Slack API tokens
#   slack-tunnel --background - Start tunnel in background
#   slack-tunnel --stop   - Stop background tunnel
#   slack-tunnel --status - Check tunnel status
# =============================================================================

set -uo pipefail

MCP_PORT=8463
CLAUDE_DIR="$HOME/.claude"
MCP_SERVER="$CLAUDE_DIR/bin/mcp-server"
SLACK_CONFIG_FILE="$CLAUDE_DIR/.slack-config"
TUNNEL_PID_FILE="$CLAUDE_DIR/.tunnel.pid"
TUNNEL_URL_FILE="$CLAUDE_DIR/.tunnel-url"
WATCHDOG_PID_FILE="$CLAUDE_DIR/.tunnel-watchdog.pid"
ACTIVITY_FILE="$CLAUDE_DIR/.tunnel-last-activity"
TUNNEL_LOG="$CLAUDE_DIR/tunnel.log"
IDLE_TIMEOUT=3600  # 1 hour in seconds

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

echo_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
echo_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
echo_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# =============================================================================
# Slack API helpers
# =============================================================================

# Load Slack config
load_slack_config() {
    if [[ ! -f "$SLACK_CONFIG_FILE" ]]; then
        return 1
    fi
    # Source the config file (sets SLACK_APP_ID, SLACK_ACCESS_TOKEN, SLACK_REFRESH_TOKEN, SLACK_TOKEN_EXPIRES)
    source "$SLACK_CONFIG_FILE"
    return 0
}

# Save Slack config
save_slack_config() {
    cat > "$SLACK_CONFIG_FILE" << EOF
SLACK_APP_ID="$SLACK_APP_ID"
SLACK_ACCESS_TOKEN="$SLACK_ACCESS_TOKEN"
SLACK_REFRESH_TOKEN="$SLACK_REFRESH_TOKEN"
SLACK_TOKEN_EXPIRES="$SLACK_TOKEN_EXPIRES"
EOF
    chmod 600 "$SLACK_CONFIG_FILE"
}

# Check if token is expired (with 5 minute buffer)
is_token_expired() {
    local now
    now=$(date +%s)
    local buffer=300  # 5 minutes
    if [[ -z "${SLACK_TOKEN_EXPIRES:-}" ]] || [[ $((SLACK_TOKEN_EXPIRES - buffer)) -lt $now ]]; then
        return 0  # expired
    fi
    return 1  # not expired
}

# Rotate the Slack token using refresh token
rotate_slack_token() {
    echo_info "Refreshing Slack configuration token..."

    local response
    response=$(curl -s -X POST "https://slack.com/api/tooling.tokens.rotate" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "refresh_token=${SLACK_REFRESH_TOKEN}")

    local ok
    ok=$(echo "$response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$response" | jq -r '.error // "unknown error"')
        echo_error "Failed to refresh token: $error"
        echo_error "Run 'slack-tunnel --setup' to reconfigure"
        return 1
    fi

    SLACK_ACCESS_TOKEN=$(echo "$response" | jq -r '.token')
    SLACK_REFRESH_TOKEN=$(echo "$response" | jq -r '.refresh_token')
    local exp
    exp=$(echo "$response" | jq -r '.exp')
    SLACK_TOKEN_EXPIRES="$exp"

    save_slack_config
    echo_info "Token refreshed successfully"
    return 0
}

# Update Slack app's Request URL
update_slack_request_url() {
    local new_url="$1"

    # Ensure token is valid
    if is_token_expired; then
        if ! rotate_slack_token; then
            return 1
        fi
    fi

    echo_info "Updating Slack Request URL..."

    # Export current manifest
    local manifest_response
    manifest_response=$(curl -s -X POST "https://slack.com/api/apps.manifest.export" \
        -H "Authorization: Bearer ${SLACK_ACCESS_TOKEN}" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "app_id=${SLACK_APP_ID}")

    local ok
    ok=$(echo "$manifest_response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$manifest_response" | jq -r '.error // "unknown error"')
        echo_error "Failed to export manifest: $error"
        return 1
    fi

    # Update the request_url in the manifest
    local updated_manifest
    updated_manifest=$(echo "$manifest_response" | jq --arg url "$new_url" '
        .manifest.settings.interactivity.is_enabled = true |
        .manifest.settings.interactivity.request_url = $url |
        .manifest
    ')

    # Update the manifest
    local update_response
    update_response=$(curl -s -X POST "https://slack.com/api/apps.manifest.update" \
        -H "Authorization: Bearer ${SLACK_ACCESS_TOKEN}" \
        -H "Content-Type: application/json" \
        -d "{\"app_id\": \"${SLACK_APP_ID}\", \"manifest\": ${updated_manifest}}")

    ok=$(echo "$update_response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$update_response" | jq -r '.error // "unknown error"')
        echo_error "Failed to update manifest: $error"

        # Show more details if available
        local errors
        errors=$(echo "$update_response" | jq -r '.errors // empty')
        if [[ -n "$errors" ]]; then
            echo_error "Details: $errors"
        fi
        return 1
    fi

    echo_info "Slack Request URL updated to: $new_url"
    return 0
}

# =============================================================================
# MCP server helpers
# =============================================================================

check_mcp_server() {
    if curl -s "http://localhost:$MCP_PORT/health" &>/dev/null; then
        return 0
    fi
    return 1
}

find_mcp_source_dir() {
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

    if [[ -L "$CLAUDE_DIR/bin/mcp-server" ]]; then
        local target
        target="$(readlink "$CLAUDE_DIR/bin/mcp-server")"
        local repo_dir
        repo_dir="$(dirname "$target")/.."
        if [[ -d "$repo_dir/mcp-server/src" ]]; then
            echo "$repo_dir/mcp-server"
            return 0
        fi
    fi

    if [[ -d "$script_dir/../mcp-server/src" ]]; then
        echo "$script_dir/../mcp-server"
        return 0
    fi

    return 1
}

rebuild_if_needed() {
    local mcp_source_dir
    if ! mcp_source_dir=$(find_mcp_source_dir); then
        return 0
    fi

    local src_dir="$mcp_source_dir/src"
    local dist_dir="$mcp_source_dir/dist"
    local installed_dist="$CLAUDE_DIR/mcp-server-dist/dist"

    local newest_src
    newest_src=$(find "$src_dir" -name "*.ts" -type f -exec stat -f "%m %N" {} \; 2>/dev/null | sort -rn | head -1 | cut -d' ' -f1)

    local oldest_dist=0
    if [[ -d "$dist_dir" ]]; then
        oldest_dist=$(find "$dist_dir" -name "*.js" -type f -exec stat -f "%m %N" {} \; 2>/dev/null | sort -n | head -1 | cut -d' ' -f1)
    fi

    if [[ -n "$newest_src" ]] && [[ "$newest_src" -gt "$oldest_dist" ]]; then
        echo_info "Source files changed, rebuilding MCP server..."
        (
            cd "$mcp_source_dir"
            if command -v bun &>/dev/null; then
                bun run build
            elif command -v npm &>/dev/null; then
                npm run build
            else
                echo_warn "No build tool found (bun/npm), skipping rebuild"
                return 0
            fi
        )

        if [[ -d "$installed_dist" ]]; then
            cp -r "$dist_dir"/* "$installed_dist"/
            echo_info "Updated installed MCP server"
        fi
    fi
}

start_mcp_server() {
    if [[ ! -x "$MCP_SERVER" ]]; then
        echo_error "MCP server not found at $MCP_SERVER"
        echo_error "Run install.sh first to build the MCP server"
        exit 1
    fi

    echo_info "Starting MCP server..."
    nohup "$MCP_SERVER" > "$CLAUDE_DIR/mcp-server.log" 2>&1 &
    MCP_PID=$!
    echo "$MCP_PID" > "$CLAUDE_DIR/.mcp-server.pid"

    for i in {1..10}; do
        if check_mcp_server; then
            echo_info "MCP server started (PID: $MCP_PID)"
            return 0
        fi
        sleep 0.5
    done

    echo_error "MCP server failed to start. Check $CLAUDE_DIR/mcp-server.log"
    exit 1
}

stop_mcp_server() {
    local pid_file="$CLAUDE_DIR/.mcp-server.pid"
    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            rm -f "$pid_file"
            echo_info "MCP server stopped"
        fi
    fi
}

# =============================================================================
# Idle watchdog (for --background mode)
# =============================================================================

start_watchdog() {
    touch "$ACTIVITY_FILE"

    (
        while true; do
            sleep 300  # Check every 5 minutes

            if [[ ! -f "$ACTIVITY_FILE" ]]; then
                continue
            fi

            local last now
            if [[ "$(uname)" == "Darwin" ]]; then
                last=$(stat -f %m "$ACTIVITY_FILE" 2>/dev/null || echo 0)
            else
                last=$(stat -c %Y "$ACTIVITY_FILE" 2>/dev/null || echo 0)
            fi
            now=$(date +%s)

            if [[ $((now - last)) -gt $IDLE_TIMEOUT ]]; then
                echo "$(date): Idle timeout ($IDLE_TIMEOUT seconds), shutting down" >> "$TUNNEL_LOG"

                if [[ -f "$TUNNEL_PID_FILE" ]]; then
                    local tunnel_pid
                    tunnel_pid=$(cat "$TUNNEL_PID_FILE")
                    kill "$tunnel_pid" 2>/dev/null || true
                    rm -f "$TUNNEL_PID_FILE"
                fi

                stop_mcp_server
                rm -f "$ACTIVITY_FILE"
                rm -f "$WATCHDOG_PID_FILE"
                exit 0
            fi
        done
    ) &
    local watchdog_pid=$!
    echo "$watchdog_pid" > "$WATCHDOG_PID_FILE"
    echo_info "Idle watchdog started (timeout: ${IDLE_TIMEOUT}s)"
}

stop_watchdog() {
    if [[ -f "$WATCHDOG_PID_FILE" ]]; then
        local pid
        pid=$(cat "$WATCHDOG_PID_FILE")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
        fi
        rm -f "$WATCHDOG_PID_FILE"
    fi
}

# =============================================================================
# Start tunnel and get URL
# =============================================================================

start_tunnel_and_get_url() {
    local background="${1:-false}"

    # Check cloudflared installed
    if ! command -v cloudflared &>/dev/null; then
        echo_error "cloudflared not installed."
        echo ""
        echo -e "  Install with:"
        echo -e "    macOS:  ${BOLD}brew install cloudflared${NC}"
        echo -e "    Linux:  See https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/downloads/"
        exit 1
    fi

    # Kill any existing cloudflared tunnels to prevent accumulation
    pkill -f "cloudflared tunnel.*localhost:${MCP_PORT}" 2>/dev/null || true
    rm -f "$TUNNEL_PID_FILE" "$TUNNEL_URL_FILE"
    sleep 0.5

    echo_info "Starting Cloudflare Quick Tunnel..."

    # Start cloudflared and capture output to get URL
    local log_file="$CLAUDE_DIR/.cloudflared.log"

    if [[ "$background" == "true" ]]; then
        nohup cloudflared tunnel --url "http://localhost:$MCP_PORT" >> "$log_file" 2>&1 &
    else
        cloudflared tunnel --url "http://localhost:$MCP_PORT" > "$log_file" 2>&1 &
    fi
    TUNNEL_PID=$!
    echo "$TUNNEL_PID" > "$TUNNEL_PID_FILE"

    # Wait for URL to appear in logs (cloudflared outputs it to stderr)
    local tunnel_url=""
    for i in {1..30}; do
        if [[ -f "$log_file" ]]; then
            # Cloudflared outputs URL like: "https://xxx.trycloudflare.com"
            tunnel_url=$(grep -oE 'https://[a-z0-9-]+\.trycloudflare\.com' "$log_file" 2>/dev/null | head -1 || true)
            if [[ -n "$tunnel_url" ]]; then
                break
            fi
        fi
        sleep 0.5
    done

    if [[ -z "$tunnel_url" ]]; then
        echo_error "Failed to get tunnel URL"
        cat "$log_file" 2>/dev/null | tail -10
        kill "$TUNNEL_PID" 2>/dev/null || true
        rm -f "$TUNNEL_PID_FILE"
        exit 1
    fi

    echo "$tunnel_url" > "$TUNNEL_URL_FILE"
    TUNNEL_URL="$tunnel_url"
    echo_info "Tunnel started: $tunnel_url"
}

# =============================================================================
# --setup: Configure Slack API tokens
# =============================================================================

cmd_setup() {
    echo ""
    echo -e "${BOLD}Slack Tunnel Setup${NC}"
    echo -e "${DIM}Configure automatic Request URL updates${NC}"
    echo ""

    # Check dependencies
    if ! command -v jq &>/dev/null; then
        echo_error "jq is required but not installed."
        echo "  Install with: brew install jq (macOS) or apt install jq (Linux)"
        exit 1
    fi

    if ! command -v cloudflared &>/dev/null; then
        echo_error "cloudflared is required but not installed."
        echo "  Install with: brew install cloudflared (macOS)"
        exit 1
    fi

    echo -e "${CYAN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${CYAN}│${NC}  ${BOLD}Step 1: Get your Slack App ID${NC}                               ${CYAN}│${NC}"
    echo -e "${CYAN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  ${CYAN}1.${NC} Go to ${BOLD}https://api.slack.com/apps${NC}"
    echo -e "  ${CYAN}2.${NC} Click on your app (or create one)"
    echo -e "  ${CYAN}3.${NC} Copy the ${BOLD}App ID${NC} from the top of the page"
    echo -e "     ${DIM}(Format: A0XXXXXXXXX)${NC}"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Paste your App ID: "
    read -r SLACK_APP_ID

    if [[ -z "$SLACK_APP_ID" || ! "$SLACK_APP_ID" =~ ^A[A-Z0-9]+$ ]]; then
        echo_error "Invalid App ID format. Should start with 'A' followed by letters/numbers."
        exit 1
    fi

    echo ""
    echo -e "${CYAN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${CYAN}│${NC}  ${BOLD}Step 2: Generate a Configuration Token${NC}                     ${CYAN}│${NC}"
    echo -e "${CYAN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  ${CYAN}1.${NC} Go to ${BOLD}https://api.slack.com/apps${NC}"
    echo -e "  ${CYAN}2.${NC} Scroll to the ${BOLD}bottom${NC} of the page (below your apps list)"
    echo -e "  ${CYAN}3.${NC} Find ${BOLD}\"Your App Configuration Tokens\"${NC} section"
    echo -e "  ${CYAN}4.${NC} Click ${BOLD}\"Generate Token\"${NC}"
    echo -e "  ${CYAN}5.${NC} Select your ${BOLD}workspace${NC} from the dropdown"
    echo -e "  ${CYAN}6.${NC} Click ${BOLD}\"Generate\"${NC}"
    echo ""
    echo -e "  ${DIM}(This adds \"Slack Tooling Tokens Vendor\" app to your workspace)${NC}"
    echo ""
    echo -e "  ${CYAN}7.${NC} Copy the ${BOLD}Access Token${NC} (starts with xoxe-...)"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Paste the Access Token: "
    read -r SLACK_ACCESS_TOKEN

    if [[ -z "$SLACK_ACCESS_TOKEN" ]]; then
        echo_error "Access token is required"
        exit 1
    fi

    echo ""
    echo -e "  ${CYAN}8.${NC} Copy the ${BOLD}Refresh Token${NC} (shown below the access token)"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Paste the Refresh Token: "
    read -r SLACK_REFRESH_TOKEN

    if [[ -z "$SLACK_REFRESH_TOKEN" ]]; then
        echo_error "Refresh token is required"
        exit 1
    fi

    # Set initial expiry (12 hours from now, but we'll refresh before using)
    SLACK_TOKEN_EXPIRES=$(($(date +%s) + 43200))

    # Save config
    save_slack_config
    echo ""
    echo_info "Configuration saved to $SLACK_CONFIG_FILE"

    # Verify by testing the token
    echo ""
    echo_info "Verifying configuration..."

    local test_response
    test_response=$(curl -s -X POST "https://slack.com/api/apps.manifest.export" \
        -H "Authorization: Bearer ${SLACK_ACCESS_TOKEN}" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "app_id=${SLACK_APP_ID}")

    local ok
    ok=$(echo "$test_response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$test_response" | jq -r '.error // "unknown error"')
        echo_error "Configuration test failed: $error"
        echo_error "Please check your tokens and try again."
        rm -f "$SLACK_CONFIG_FILE"
        exit 1
    fi

    echo ""
    echo -e "${GREEN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${GREEN}│${NC}  ${GREEN}✓${NC} ${BOLD}Setup Complete!${NC}                                          ${GREEN}│${NC}"
    echo -e "${GREEN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  The tunnel will now automatically update your Slack app's"
    echo -e "  Request URL each time it starts."
    echo ""
    echo -e "  ${BOLD}To start the tunnel:${NC}"
    echo -e "    slack-tunnel"
    echo ""
    echo -e "  ${BOLD}Or for background mode:${NC}"
    echo -e "    slack-tunnel --background"
    echo ""
}

# =============================================================================
# --background: Start tunnel in background
# =============================================================================

cmd_background() {
    # Check Slack is configured
    if ! load_slack_config; then
        echo_error "Slack not configured. Run: slack-tunnel --setup"
        exit 1
    fi

    # Check if already running (and there's only ONE tunnel)
    local tunnel_count
    tunnel_count=$(pgrep -f "cloudflared tunnel.*localhost:${MCP_PORT}" 2>/dev/null | wc -l | tr -d ' ')

    if [[ -f "$TUNNEL_PID_FILE" ]] && [[ "$tunnel_count" -eq 1 ]]; then
        local existing_pid
        existing_pid=$(cat "$TUNNEL_PID_FILE")
        if kill -0 "$existing_pid" 2>/dev/null; then
            echo_info "Tunnel already running (PID: $existing_pid)"
            return 0
        fi
    fi

    # Clean up stale state (multiple tunnels or orphaned PID file)
    if [[ "$tunnel_count" -gt 0 ]]; then
        echo_info "Cleaning up stale tunnel processes..."
    fi
    rm -f "$TUNNEL_PID_FILE"

    # Rebuild MCP server if needed
    rebuild_if_needed

    # Start MCP server if not running
    if ! check_mcp_server; then
        start_mcp_server
    fi

    # Start tunnel
    start_tunnel_and_get_url "true"

    # Update Slack Request URL
    if ! update_slack_request_url "${TUNNEL_URL}/slack/actions"; then
        echo_warn "Failed to update Slack, but tunnel is running"
        echo_warn "Manually set Request URL to: ${TUNNEL_URL}/slack/actions"
    fi

    # Start idle watchdog
    start_watchdog

    # Touch activity file
    touch "$ACTIVITY_FILE"

    echo_info "Tunnel running in background (PID: $TUNNEL_PID)"
}

# =============================================================================
# --stop: Stop background tunnel
# =============================================================================

cmd_stop() {
    local stopped=false

    if [[ -f "$WATCHDOG_PID_FILE" ]]; then
        stop_watchdog
        stopped=true
    fi

    # Kill the tunnel from PID file
    if [[ -f "$TUNNEL_PID_FILE" ]]; then
        local pid
        pid=$(cat "$TUNNEL_PID_FILE")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            stopped=true
        fi
        rm -f "$TUNNEL_PID_FILE"
    fi

    # Kill ANY remaining cloudflared tunnel processes (cleanup stale tunnels)
    local stale_count=0
    while IFS= read -r pid; do
        if [[ -n "$pid" ]]; then
            kill "$pid" 2>/dev/null || true
            ((stale_count++)) || true
        fi
    done < <(pgrep -f "cloudflared tunnel.*localhost:${MCP_PORT:-8463}" 2>/dev/null || true)

    if [[ "$stale_count" -gt 0 || "$stopped" == "true" ]]; then
        echo_info "Tunnel stopped"
        stopped=true
    fi

    # Remove tunnel URL file
    rm -f "$TUNNEL_URL_FILE"

    if [[ -f "$CLAUDE_DIR/.mcp-server.pid" ]]; then
        stop_mcp_server
        stopped=true
    fi

    rm -f "$ACTIVITY_FILE"

    if [[ "$stopped" == "true" ]]; then
        echo_info "All services stopped"
    else
        echo_info "No services were running"
    fi
}

# =============================================================================
# --status: Check tunnel status
# =============================================================================

cmd_status() {
    echo ""
    echo -e "${BOLD}Tunnel Status${NC}"
    echo ""

    # Check Slack config
    if [[ -f "$SLACK_CONFIG_FILE" ]]; then
        load_slack_config
        echo -e "  Slack App:  ${CYAN}$SLACK_APP_ID${NC}"
        if is_token_expired; then
            echo -e "  Token:      ${YELLOW}Expired (will refresh on next use)${NC}"
        else
            echo -e "  Token:      ${GREEN}Valid${NC}"
        fi
    else
        echo -e "  Slack:      ${YELLOW}Not configured${NC} (run: slack-tunnel --setup)"
    fi
    echo ""

    # Check tunnel process
    if [[ -f "$TUNNEL_PID_FILE" ]]; then
        local pid
        pid=$(cat "$TUNNEL_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "  Tunnel:     ${GREEN}Running${NC} (PID: $pid)"
            if [[ -f "$TUNNEL_URL_FILE" ]]; then
                local url
                url=$(cat "$TUNNEL_URL_FILE")
                echo -e "  URL:        ${CYAN}$url/slack/actions${NC}"
            fi
        else
            echo -e "  Tunnel:     ${YELLOW}Stopped${NC} (stale PID file)"
        fi
    else
        echo -e "  Tunnel:     ${YELLOW}Stopped${NC}"
    fi

    # Check MCP server
    if check_mcp_server; then
        local mcp_pid=""
        if [[ -f "$CLAUDE_DIR/.mcp-server.pid" ]]; then
            mcp_pid=$(cat "$CLAUDE_DIR/.mcp-server.pid")
        fi
        echo -e "  MCP Server: ${GREEN}Running${NC}${mcp_pid:+ (PID: $mcp_pid)}"
    else
        echo -e "  MCP Server: ${YELLOW}Stopped${NC}"
    fi

    # Check watchdog
    if [[ -f "$WATCHDOG_PID_FILE" ]]; then
        local pid
        pid=$(cat "$WATCHDOG_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "  Watchdog:   ${GREEN}Running${NC}"
        else
            echo -e "  Watchdog:   ${YELLOW}Stopped${NC}"
        fi
    else
        echo -e "  Watchdog:   ${YELLOW}Stopped${NC}"
    fi

    # Check last activity
    if [[ -f "$ACTIVITY_FILE" ]]; then
        local last now elapsed
        if [[ "$(uname)" == "Darwin" ]]; then
            last=$(stat -f %m "$ACTIVITY_FILE" 2>/dev/null || echo 0)
        else
            last=$(stat -c %Y "$ACTIVITY_FILE" 2>/dev/null || echo 0)
        fi
        now=$(date +%s)
        elapsed=$((now - last))
        local remaining=$((IDLE_TIMEOUT - elapsed))
        if [[ $remaining -gt 0 ]]; then
            echo -e "  Idle timer: ${DIM}${remaining}s until auto-stop${NC}"
        fi
    fi

    echo ""
}

# =============================================================================
# Default: Interactive mode
# =============================================================================

cmd_interactive() {
    echo ""
    echo -e "${BOLD}Slack Tunnel for Claude Notifications${NC}"
    echo -e "${DIM}Creates a public URL for Slack button actions${NC}"
    echo ""

    # Check Slack is configured
    if ! load_slack_config; then
        echo_warn "Slack not configured yet."
        echo ""
        echo -ne "  ${YELLOW}?${NC} Run setup now? [Y/n] "
        read -r response
        if [[ "$response" =~ ^[Nn]$ ]]; then
            exit 0
        fi
        cmd_setup
        load_slack_config
    fi

    # Rebuild MCP server if needed
    rebuild_if_needed

    # Kill existing MCP server and start fresh
    if check_mcp_server; then
        echo_info "Stopping existing MCP server..."
        local old_pid
        old_pid=$(cat "$CLAUDE_DIR/.mcp-server.pid" 2>/dev/null)
        if [[ -n "$old_pid" ]]; then
            kill "$old_pid" 2>/dev/null || true
            sleep 1
        fi
    fi
    start_mcp_server

    # Cleanup on exit
    cleanup() {
        echo ""
        echo_info "Shutting down..."
        if [[ -n "${TUNNEL_PID:-}" ]]; then
            kill "$TUNNEL_PID" 2>/dev/null || true
        fi
        stop_mcp_server
        rm -f "$TUNNEL_PID_FILE" "$TUNNEL_URL_FILE"
    }
    trap cleanup EXIT INT TERM

    # Start tunnel
    start_tunnel_and_get_url "false"

    # Update Slack Request URL
    if update_slack_request_url "${TUNNEL_URL}/slack/actions"; then
        echo ""
        echo -e "${GREEN}╭──────────────────────────────────────────────────────────────╮${NC}"
        echo -e "${GREEN}│${NC}  ${GREEN}✓${NC} ${BOLD}Slack Request URL updated automatically!${NC}                  ${GREEN}│${NC}"
        echo -e "${GREEN}╰──────────────────────────────────────────────────────────────╯${NC}"
        echo ""
        echo -e "  Tunnel URL: ${CYAN}${TUNNEL_URL}/slack/actions${NC}"
        echo ""
        echo -e "  ${DIM}Buttons will work on both desktop and mobile Slack.${NC}"
        echo -e "  ${DIM}Keep this running. Press Ctrl+C to stop.${NC}"
    else
        echo ""
        echo -e "${YELLOW}╭──────────────────────────────────────────────────────────────╮${NC}"
        echo -e "${YELLOW}│${NC}  ${YELLOW}!${NC} ${BOLD}Could not auto-update Slack${NC}                               ${YELLOW}│${NC}"
        echo -e "${YELLOW}╰──────────────────────────────────────────────────────────────╯${NC}"
        echo ""
        echo -e "  Tunnel URL: ${CYAN}${TUNNEL_URL}/slack/actions${NC}"
        echo ""
        echo -e "  ${BOLD}Manually update in Slack:${NC}"
        echo -e "  ${CYAN}1.${NC} Go to ${BOLD}https://api.slack.com/apps/${SLACK_APP_ID}${NC}"
        echo -e "  ${CYAN}2.${NC} Click ${BOLD}Interactivity & Shortcuts${NC}"
        echo -e "  ${CYAN}3.${NC} Update ${BOLD}Request URL${NC} to the URL above"
        echo -e "  ${CYAN}4.${NC} Click ${BOLD}Save Changes${NC}"
        echo ""
        echo -e "  ${DIM}Keep this running. Press Ctrl+C to stop.${NC}"
    fi
    echo ""

    # Keep running until interrupted
    wait "$TUNNEL_PID" 2>/dev/null || true
}

# =============================================================================
# Main
# =============================================================================

case "${1:-}" in
    --setup)
        cmd_setup
        ;;
    --background)
        cmd_background
        ;;
    --stop)
        cmd_stop
        ;;
    --status)
        cmd_status
        ;;
    --help|-h)
        echo "Usage: slack-tunnel [command]"
        echo ""
        echo "Commands:"
        echo "  (none)        Interactive mode - start tunnel in foreground"
        echo "  --setup       One-time setup: configure Slack API tokens"
        echo "  --background  Start tunnel in background (for auto-start)"
        echo "  --stop        Stop background tunnel"
        echo "  --status      Check tunnel status"
        echo ""
        echo "The tunnel uses Cloudflare Quick Tunnels (free, no account needed)"
        echo "and automatically updates your Slack app's Request URL."
        echo ""
        ;;
    "")
        cmd_interactive
        ;;
    *)
        echo_error "Unknown command: $1"
        echo "Run: slack-tunnel --help"
        exit 1
        ;;
esac
