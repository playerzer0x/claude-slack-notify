#!/bin/bash
# =============================================================================
# remote-tunnel - Remote relay for Slack button actions (Linux only)
#
# Runs on a Linux server (in tmux) to receive Slack button clicks when your
# Mac is closed. Auto-detects if Mac is reachable and proxies to it when possible.
#
# Uses Localtunnel for stable URLs that don't change between restarts.
#
# Commands:
#   remote-tunnel           - Start tunnel (prompts to configure stable URL if needed)
#   remote-tunnel --setup   - Configure Slack tokens (for auto-URL updates)
#   remote-tunnel --background - Start tunnel in background
#   remote-tunnel --stop    - Stop background tunnel
#   remote-tunnel --status  - Check tunnel status
# =============================================================================

set -uo pipefail

RELAY_PORT=8464
CLAUDE_DIR="$HOME/.claude"
SLACK_CONFIG_FILE="$CLAUDE_DIR/.slack-config"
RELAY_PID_FILE="$CLAUDE_DIR/.remote-relay.pid"
TUNNEL_PID_FILE="$CLAUDE_DIR/.remote-tunnel.pid"
TUNNEL_URL_FILE="$CLAUDE_DIR/.remote-tunnel-url"
WATCHDOG_PID_FILE="$CLAUDE_DIR/.remote-tunnel-watchdog.pid"
ACTIVITY_FILE="$CLAUDE_DIR/.relay-last-activity"
TUNNEL_LOG="$CLAUDE_DIR/remote-tunnel.log"
IDLE_TIMEOUT=3600  # 1 hour in seconds
LOCALTUNNEL_SUBDOMAIN_FILE="$CLAUDE_DIR/.remote-localtunnel-subdomain"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

echo_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
echo_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
echo_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# =============================================================================
# Platform check - Linux only
# =============================================================================
if [[ "$(uname)" == "Darwin" ]]; then
    echo_error "remote-tunnel is for Linux servers only."
    echo_info "On macOS, use: local-tunnel"
    exit 1
fi

# =============================================================================
# Slack API helpers (reused from local-tunnel)
# =============================================================================

load_slack_config() {
    if [[ ! -f "$SLACK_CONFIG_FILE" ]]; then
        return 1
    fi
    source "$SLACK_CONFIG_FILE"
    return 0
}

save_slack_config() {
    cat > "$SLACK_CONFIG_FILE" << EOF
SLACK_APP_ID="$SLACK_APP_ID"
SLACK_ACCESS_TOKEN="$SLACK_ACCESS_TOKEN"
SLACK_REFRESH_TOKEN="$SLACK_REFRESH_TOKEN"
SLACK_TOKEN_EXPIRES="$SLACK_TOKEN_EXPIRES"
EOF
    chmod 600 "$SLACK_CONFIG_FILE"
}

# =============================================================================
# Localtunnel config (stable URL)
# =============================================================================

has_stable_tunnel() {
    [[ -f "$LOCALTUNNEL_SUBDOMAIN_FILE" ]]
}

get_localtunnel_subdomain() {
    cat "$LOCALTUNNEL_SUBDOMAIN_FILE" 2>/dev/null
}

is_token_expired() {
    local now
    now=$(date +%s)
    local buffer=300  # 5 minutes
    if [[ -z "${SLACK_TOKEN_EXPIRES:-}" ]] || [[ $((SLACK_TOKEN_EXPIRES - buffer)) -lt $now ]]; then
        return 0  # expired
    fi
    return 1  # not expired
}

rotate_slack_token() {
    echo_info "Refreshing Slack configuration token..."

    local response
    response=$(curl -s --max-time 30 -X POST "https://slack.com/api/tooling.tokens.rotate" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "refresh_token=${SLACK_REFRESH_TOKEN}")

    local ok
    ok=$(echo "$response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$response" | jq -r '.error // "unknown error"')
        echo_error "Failed to refresh token: $error"
        echo_error "Run 'remote-tunnel --setup' to reconfigure"
        return 1
    fi

    SLACK_ACCESS_TOKEN=$(echo "$response" | jq -r '.token')
    SLACK_REFRESH_TOKEN=$(echo "$response" | jq -r '.refresh_token')
    local exp
    exp=$(echo "$response" | jq -r '.exp')
    SLACK_TOKEN_EXPIRES="$exp"

    save_slack_config
    echo_info "Token refreshed successfully"
    return 0
}

update_slack_request_url() {
    local actions_url="$1"
    local events_url="$2"

    # Ensure token is valid
    if is_token_expired; then
        if ! rotate_slack_token; then
            return 1
        fi
    fi

    echo_info "Updating Slack Request URLs..."

    local manifest_response
    manifest_response=$(curl -s --max-time 30 -X POST "https://slack.com/api/apps.manifest.export" \
        -H "Authorization: Bearer ${SLACK_ACCESS_TOKEN}" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "app_id=${SLACK_APP_ID}")

    local ok
    ok=$(echo "$manifest_response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$manifest_response" | jq -r '.error // "unknown error"')
        echo_error "Failed to export manifest: $error"
        return 1
    fi

    # Update both interactivity URL (for buttons) and event_subscriptions URL (for thread replies)
    local updated_manifest
    updated_manifest=$(echo "$manifest_response" | jq --arg actions_url "$actions_url" --arg events_url "$events_url" '
        .manifest.settings.interactivity.is_enabled = true |
        .manifest.settings.interactivity.request_url = $actions_url |
        .manifest.settings.event_subscriptions.request_url = $events_url |
        .manifest
    ')

    local update_response
    update_response=$(curl -s --max-time 30 -X POST "https://slack.com/api/apps.manifest.update" \
        -H "Authorization: Bearer ${SLACK_ACCESS_TOKEN}" \
        -H "Content-Type: application/json" \
        -d "{\"app_id\": \"${SLACK_APP_ID}\", \"manifest\": ${updated_manifest}}")

    ok=$(echo "$update_response" | jq -r '.ok // false')

    if [[ "$ok" != "true" ]]; then
        local error
        error=$(echo "$update_response" | jq -r '.error // "unknown error"')
        echo_error "Failed to update manifest: $error"
        local errors
        errors=$(echo "$update_response" | jq -r '.errors // empty')
        if [[ -n "$errors" ]]; then
            echo_error "Details: $errors"
        fi
        return 1
    fi

    echo_info "Slack URLs updated:"
    echo_info "  Actions: $actions_url"
    echo_info "  Events:  $events_url"
    return 0
}

# =============================================================================
# Remote relay helpers
# =============================================================================

find_relay_dist() {
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

    # Check installed location first
    if [[ -f "$CLAUDE_DIR/mcp-server-dist/dist/remote-relay.js" ]]; then
        echo "$CLAUDE_DIR/mcp-server-dist/dist/remote-relay.js"
        return 0
    fi

    # Check development location
    if [[ -f "$script_dir/../mcp-server/dist/remote-relay.js" ]]; then
        echo "$script_dir/../mcp-server/dist/remote-relay.js"
        return 0
    fi

    return 1
}

check_relay_running() {
    if curl -s "http://localhost:$RELAY_PORT/health" &>/dev/null; then
        return 0
    fi
    return 1
}

# Kill any orphan process on RELAY_PORT that's not tracked by our PID file
# Returns 0 if orphans were killed, 1 if port was clear
kill_orphan_relay() {
    local pid_file="$RELAY_PID_FILE"
    local tracked_pid=""
    local killed_orphan=false

    # Get tracked PID (if valid)
    if [[ -f "$pid_file" ]]; then
        tracked_pid=$(cat "$pid_file" 2>/dev/null)
        # Verify it's actually running
        if [[ -n "$tracked_pid" ]] && ! kill -0 "$tracked_pid" 2>/dev/null; then
            # Stale PID file - remove it
            rm -f "$pid_file"
            tracked_pid=""
        fi
    fi

    # Find any process listening on RELAY_PORT
    # Use ss on Linux (lsof may not be available)
    local port_pid=""
    if command -v lsof &>/dev/null; then
        port_pid=$(lsof -ti ":$RELAY_PORT" 2>/dev/null | head -1)
    elif command -v ss &>/dev/null; then
        # ss output format: find listening socket, extract PID
        port_pid=$(ss -tlnp "sport = :$RELAY_PORT" 2>/dev/null | grep -oP 'pid=\K[0-9]+' | head -1)
    elif command -v fuser &>/dev/null; then
        port_pid=$(fuser "$RELAY_PORT/tcp" 2>/dev/null | awk '{print $1}')
    fi

    if [[ -n "$port_pid" ]]; then
        if [[ "$port_pid" != "$tracked_pid" ]]; then
            # Orphan process found - kill it
            echo_warn "Killing orphan process on port $RELAY_PORT (PID: $port_pid)"
            kill "$port_pid" 2>/dev/null || true
            sleep 0.5
            # Force kill if still running
            if kill -0 "$port_pid" 2>/dev/null; then
                kill -9 "$port_pid" 2>/dev/null || true
                sleep 0.5
            fi
            killed_orphan=true
        fi
    fi

    # Clean up stale PID file if process doesn't match port
    if [[ -n "$tracked_pid" ]] && [[ "$tracked_pid" != "$port_pid" ]]; then
        rm -f "$pid_file"
    fi

    $killed_orphan && return 0 || return 1
}

start_relay() {
    local relay_path
    if ! relay_path=$(find_relay_dist); then
        echo_error "Remote relay not found."
        echo_error "Build the MCP server first: cd mcp-server && bun run build"
        exit 1
    fi

    # Kill any orphan process on the port first
    kill_orphan_relay || true

    echo_info "Starting remote relay..."
    nohup node "$relay_path" > "$CLAUDE_DIR/remote-relay.log" 2>&1 &
    local relay_pid=$!
    echo "$relay_pid" > "$RELAY_PID_FILE"

    # Wait for relay to start
    for i in {1..10}; do
        if check_relay_running; then
            echo_info "Remote relay started (PID: $relay_pid)"
            return 0
        fi
        sleep 0.5
    done

    echo_error "Remote relay failed to start. Check $CLAUDE_DIR/remote-relay.log"
    exit 1
}

stop_relay() {
    local pid_file="$RELAY_PID_FILE"
    local stopped=false

    # Kill tracked process from PID file
    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            stopped=true
        fi
        rm -f "$pid_file"
    fi

    # Also kill any orphan process on the port
    if kill_orphan_relay; then
        stopped=true
    fi

    if $stopped; then
        echo_info "Remote relay stopped"
    fi
}

# =============================================================================
# Idle watchdog (for --background mode)
# =============================================================================

start_watchdog() {
    touch "$ACTIVITY_FILE"

    (
        while true; do
            sleep 300  # Check every 5 minutes

            if [[ ! -f "$ACTIVITY_FILE" ]]; then
                continue
            fi

            local last now
            last=$(stat -c %Y "$ACTIVITY_FILE" 2>/dev/null)
            now=$(date +%s)

            # If stat failed, skip this check (don't treat as idle)
            if [[ -z "$last" || ! "$last" =~ ^[0-9]+$ ]]; then
                continue
            fi

            if [[ $((now - last)) -gt $IDLE_TIMEOUT ]]; then
                echo "$(date): Idle timeout ($IDLE_TIMEOUT seconds), shutting down" >> "$TUNNEL_LOG"

                if [[ -f "$TUNNEL_PID_FILE" ]]; then
                    local tunnel_pid
                    tunnel_pid=$(cat "$TUNNEL_PID_FILE")
                    kill "$tunnel_pid" 2>/dev/null || true
                    rm -f "$TUNNEL_PID_FILE"
                fi

                stop_relay
                rm -f "$ACTIVITY_FILE"
                rm -f "$WATCHDOG_PID_FILE"
                exit 0
            fi
        done
    ) &
    local watchdog_pid=$!
    echo "$watchdog_pid" > "$WATCHDOG_PID_FILE"
    echo_info "Idle watchdog started (timeout: ${IDLE_TIMEOUT}s)"
}

stop_watchdog() {
    if [[ -f "$WATCHDOG_PID_FILE" ]]; then
        local pid
        pid=$(cat "$WATCHDOG_PID_FILE")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
        fi
        rm -f "$WATCHDOG_PID_FILE"
    fi
}

# =============================================================================
# Start tunnel and get URL
# =============================================================================

start_tunnel_and_get_url() {
    local background="${1:-false}"
    local log_file="$CLAUDE_DIR/.remote-tunnel.log"

    # Kill any existing tunnel processes
    pkill -f "lt --port.*${RELAY_PORT}" 2>/dev/null || true
    rm -f "$TUNNEL_PID_FILE" "$TUNNEL_URL_FILE" "$log_file"
    sleep 0.5

    # Require stable tunnel configuration
    if ! has_stable_tunnel; then
        echo_error "Stable URL not configured."
        echo ""
        echo -e "  Run ${BOLD}remote-tunnel${NC} interactively to configure your subdomain."
        exit 1
    fi

    local subdomain
    subdomain=$(get_localtunnel_subdomain)

    if ! command -v lt &>/dev/null; then
        echo_warn "Localtunnel not installed. Installing..."
        if command -v npm &>/dev/null; then
            sudo npm install -g localtunnel
        else
            echo_error "Cannot install localtunnel."
            echo ""
            echo -e "  Install with: ${BOLD}sudo npm install -g localtunnel${NC}"
            exit 1
        fi
    fi

    echo_info "Starting Localtunnel (stable URL: ${subdomain}.loca.lt)..."

    if [[ "$background" == "true" ]]; then
        nohup lt --port "$RELAY_PORT" --subdomain "$subdomain" > "$log_file" 2>&1 &
    else
        lt --port "$RELAY_PORT" --subdomain "$subdomain" > "$log_file" 2>&1 &
    fi
    TUNNEL_PID=$!
    echo "$TUNNEL_PID" > "$TUNNEL_PID_FILE"

    # Wait for URL to appear
    local tunnel_url=""
    for i in {1..20}; do
        if [[ -f "$log_file" ]]; then
            tunnel_url=$(grep -oE 'https://[a-z0-9-]+\.loca\.lt' "$log_file" 2>/dev/null | head -1 || true)
            if [[ -n "$tunnel_url" ]]; then
                break
            fi
        fi
        sleep 0.5
    done

    if [[ -z "$tunnel_url" ]]; then
        echo_error "Failed to start localtunnel"
        cat "$log_file" 2>/dev/null | tail -5
        kill "$TUNNEL_PID" 2>/dev/null || true
        rm -f "$TUNNEL_PID_FILE"
        exit 1
    fi

    echo "$tunnel_url" > "$TUNNEL_URL_FILE"
    TUNNEL_URL="$tunnel_url"

    # Check if we got the subdomain we requested
    local expected_url="https://${subdomain}.loca.lt"
    if [[ "$tunnel_url" != "$expected_url" ]]; then
        echo_warn "Subdomain '$subdomain' unavailable - got random URL instead"
        echo_warn "Your stable subdomain may be in use. Try again in a few minutes,"
        echo_warn "or choose a new subdomain with: remote-tunnel --stable"
        echo ""
    fi

    echo_info "Tunnel started: $tunnel_url"
}

# =============================================================================
# --setup: Configure Slack (copy from Mac or manual)
# =============================================================================

cmd_setup() {
    echo ""
    echo -e "${BOLD}Remote Tunnel Setup${NC}"
    echo -e "${DIM}Configure Slack API tokens for button support${NC}"
    echo ""

    # Check dependencies
    if ! command -v jq &>/dev/null; then
        echo_error "jq is required but not installed."
        echo "  Install with: sudo apt install jq"
        exit 1
    fi

    if ! command -v lt &>/dev/null; then
        echo_error "Localtunnel is required but not installed."
        echo "  Install with: npm install -g localtunnel"
        exit 1
    fi

    # Check if config already exists
    if [[ -f "$SLACK_CONFIG_FILE" ]]; then
        echo_info "Slack config already exists at $SLACK_CONFIG_FILE"
        echo ""
        echo -ne "  ${YELLOW}?${NC} Replace existing config? [y/N] "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo_info "Keeping existing config"
            return 0
        fi
    fi

    echo ""
    echo -e "${CYAN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${CYAN}│${NC}  ${BOLD}Option 1: Copy config from Mac (recommended)${NC}              ${CYAN}│${NC}"
    echo -e "${CYAN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  Run this on your Mac:"
    echo -e "    ${BOLD}scp ~/.claude/.slack-config $(hostname):~/.claude/${NC}"
    echo ""
    echo -e "  Or run this here if you have SSH access to Mac:"
    echo -e "    ${BOLD}scp mac:~/.claude/.slack-config ~/.claude/${NC}"
    echo ""
    echo -e "${CYAN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${CYAN}│${NC}  ${BOLD}Option 2: Manual setup${NC}                                     ${CYAN}│${NC}"
    echo -e "${CYAN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  ${CYAN}1.${NC} Go to ${BOLD}https://api.slack.com/apps${NC}"
    echo -e "  ${CYAN}2.${NC} Copy the ${BOLD}App ID${NC} from your app"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Paste your App ID (or Enter to skip): "
    read -r SLACK_APP_ID

    if [[ -z "$SLACK_APP_ID" ]]; then
        echo_warn "Setup skipped. Copy config from Mac or run setup again."
        return 0
    fi

    if [[ ! "$SLACK_APP_ID" =~ ^A[A-Z0-9]+$ ]]; then
        echo_error "Invalid App ID format. Should start with 'A' followed by letters/numbers."
        exit 1
    fi

    echo ""
    echo -e "  ${CYAN}3.${NC} Scroll to ${BOLD}Your App Configuration Tokens${NC} at bottom of page"
    echo -e "  ${CYAN}4.${NC} Generate a token and paste the ${BOLD}Access Token${NC}:"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Access Token: "
    read -r SLACK_ACCESS_TOKEN

    if [[ -z "$SLACK_ACCESS_TOKEN" ]]; then
        echo_error "Access token is required"
        exit 1
    fi

    echo ""
    echo -e "  ${CYAN}5.${NC} Copy the ${BOLD}Refresh Token${NC}:"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Refresh Token: "
    read -r SLACK_REFRESH_TOKEN

    if [[ -z "$SLACK_REFRESH_TOKEN" ]]; then
        echo_error "Refresh token is required"
        exit 1
    fi

    SLACK_TOKEN_EXPIRES=$(($(date +%s) + 43200))
    save_slack_config

    echo ""
    echo_info "Configuration saved to $SLACK_CONFIG_FILE"

    # Also copy slack signing secret if provided
    echo ""
    echo -e "  ${CYAN}6.${NC} (Optional) Your Slack ${BOLD}Signing Secret${NC} for request verification:"
    echo -e "     ${DIM}Found at: Your App → Basic Information → Signing Secret${NC}"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Signing Secret (or Enter to skip): "
    read -r SIGNING_SECRET

    if [[ -n "$SIGNING_SECRET" ]]; then
        echo "$SIGNING_SECRET" > "$CLAUDE_DIR/slack-signing-secret"
        chmod 600 "$CLAUDE_DIR/slack-signing-secret"
        echo_info "Signing secret saved"
    fi

    echo ""
    echo -e "${GREEN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${GREEN}│${NC}  ${GREEN}✓${NC} ${BOLD}Setup Complete!${NC}                                          ${GREEN}│${NC}"
    echo -e "${GREEN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  ${BOLD}To start the tunnel:${NC}"
    echo -e "    remote-tunnel"
    echo ""
}

# =============================================================================
# --stable: Setup stable URL with Localtunnel and start tunnel
# =============================================================================

cmd_stable() {
    # Check if localtunnel is installed
    if ! command -v lt &>/dev/null; then
        echo_warn "Localtunnel not installed. Installing..."
        echo ""
        if command -v npm &>/dev/null; then
            npm install -g localtunnel
        else
            echo_error "npm not found. Please install Node.js first."
            exit 1
        fi
        echo ""
    fi

    # If already configured, ask if they want to reconfigure or just start
    if has_stable_tunnel; then
        local current
        current=$(get_localtunnel_subdomain)
        local tunnel_url="https://${current}.loca.lt"

        echo ""
        echo -e "  ${GREEN}✓${NC} Stable URL already configured: ${CYAN}${tunnel_url}${NC}"
        echo ""
        echo -ne "  ${YELLOW}?${NC} Change subdomain? [y/N] "
        read -r change_subdomain

        if [[ ! "$change_subdomain" =~ ^[Yy]$ ]]; then
            # Just start the tunnel with existing config
            echo ""
            cmd_interactive
            return
        fi
        echo ""
    fi

    # Setup flow
    echo ""
    echo -e "${BOLD}Stable Tunnel Setup${NC}"
    echo -e "${DIM}Get a URL that stays the same every time${NC}"
    echo ""

    echo -e "  ${GREEN}✓${NC} URL stays the same every restart"
    echo -e "  ${GREEN}✓${NC} No Slack tokens needed for URL updates"
    echo -e "  ${GREEN}✓${NC} Set Slack URLs once, never again"
    echo ""

    echo -e "  Choose a unique subdomain for your tunnel."
    echo -e "  ${DIM}Pick something unlikely to be taken (e.g., claude-remote-yourname)${NC}"
    echo ""
    echo -ne "  ${YELLOW}?${NC} Subdomain: "
    read -r subdomain

    if [[ -z "$subdomain" ]]; then
        echo_error "Subdomain is required"
        exit 1
    fi

    # Remove any protocol or domain suffix if user pasted full URL
    subdomain="${subdomain#https://}"
    subdomain="${subdomain%.loca.lt}"
    subdomain="${subdomain%%/*}"

    # Validate subdomain (alphanumeric and hyphens only)
    if [[ ! "$subdomain" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$ ]]; then
        echo_error "Invalid subdomain. Use only letters, numbers, and hyphens."
        exit 1
    fi

    # Save subdomain
    echo "$subdomain" > "$LOCALTUNNEL_SUBDOMAIN_FILE"
    chmod 600 "$LOCALTUNNEL_SUBDOMAIN_FILE"

    local tunnel_url="https://${subdomain}.loca.lt"

    echo ""
    echo_info "Testing tunnel..."

    # Test the tunnel briefly
    local log_file="$CLAUDE_DIR/.localtunnel-test.log"
    rm -f "$log_file"

    lt --port "$RELAY_PORT" --subdomain "$subdomain" > "$log_file" 2>&1 &
    local test_pid=$!

    local connected=""
    for i in {1..10}; do
        if grep -q "your url is" "$log_file" 2>/dev/null; then
            connected="true"
            break
        fi
        sleep 1
    done

    kill "$test_pid" 2>/dev/null || true
    wait "$test_pid" 2>/dev/null || true

    if [[ -z "$connected" ]]; then
        echo_warn "Could not verify tunnel. The subdomain might be taken."
        echo -e "  ${DIM}Try a more unique name if it doesn't work.${NC}"
        cat "$log_file" 2>/dev/null | tail -3
    else
        echo -e "  ${GREEN}✓${NC} Tunnel works!"
    fi

    echo ""
    echo -e "${GREEN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${GREEN}│${NC}  ${GREEN}✓${NC} ${BOLD}Stable URL Configured!${NC}                                    ${GREEN}│${NC}"
    echo -e "${GREEN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  ${BOLD}Your stable URL:${NC} ${CYAN}${tunnel_url}${NC}"
    echo ""

    # Try to auto-update Slack if tokens exist
    local slack_updated=false
    if load_slack_config && [[ -n "${SLACK_APP_ID:-}" ]]; then
        echo_info "Updating Slack app settings..."
        if update_slack_request_url "${tunnel_url}/slack/actions" "${tunnel_url}/slack/events"; then
            slack_updated=true
            echo -e "  ${GREEN}✓${NC} Slack Request URLs updated automatically!"
            echo ""
        fi
    fi

    if [[ "$slack_updated" != "true" ]]; then
        echo -e "  ${BOLD}Update your Slack app (one-time only):${NC}"
        echo ""
        echo -e "  ${CYAN}1.${NC} Go to ${BOLD}https://api.slack.com/apps${NC} → your app"
        echo -e "  ${CYAN}2.${NC} ${BOLD}Interactivity & Shortcuts${NC} → Request URL:"
        echo -e "       ${BOLD}${tunnel_url}/slack/actions${NC}"
        echo -e "  ${CYAN}3.${NC} ${BOLD}Event Subscriptions${NC} → Request URL:"
        echo -e "       ${BOLD}${tunnel_url}/slack/events${NC}"
        echo ""
    fi

    # Start the tunnel
    echo_info "Starting tunnel..."
    echo ""
    cmd_interactive
}

# =============================================================================
# --background: Start tunnel in background
# =============================================================================

check_tunnel_running() {
    if [[ -f "$TUNNEL_PID_FILE" ]]; then
        local pid
        pid=$(cat "$TUNNEL_PID_FILE")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
    fi
    return 1
}

cmd_background() {
    if ! load_slack_config; then
        echo_error "Slack not configured. Run: remote-tunnel --setup"
        exit 1
    fi

    # Require stable URL for background mode (no interactive prompts)
    if ! has_stable_tunnel; then
        echo_error "Stable URL not configured."
        echo ""
        echo -e "  Background mode requires a stable URL to avoid changing URLs on restart."
        echo ""
        echo -e "  Run this first to configure:"
        echo -e "    ${BOLD}remote-tunnel --stable${NC}"
        echo ""
        echo -e "  Or run interactively (will prompt for subdomain):"
        echo -e "    ${BOLD}remote-tunnel${NC}"
        exit 1
    fi

    local relay_needs_start=true
    local tunnel_was_running=false
    local need_slack_update=false

    # Check relay status - verify PID file matches what's actually running
    if check_relay_running; then
        local tracked_pid=""
        local port_pid=""
        if [[ -f "$RELAY_PID_FILE" ]]; then
            tracked_pid=$(cat "$RELAY_PID_FILE" 2>/dev/null)
        fi
        # Find process on port
        if command -v lsof &>/dev/null; then
            port_pid=$(lsof -ti ":$RELAY_PORT" 2>/dev/null | head -1)
        elif command -v ss &>/dev/null; then
            port_pid=$(ss -tlnp "sport = :$RELAY_PORT" 2>/dev/null | grep -oP 'pid=\K[0-9]+' | head -1)
        fi

        if [[ -n "$tracked_pid" ]] && [[ "$tracked_pid" == "$port_pid" ]] && kill -0 "$tracked_pid" 2>/dev/null; then
            # Our tracked process is running correctly
            relay_needs_start=false
            echo_info "Remote relay already running (PID: $tracked_pid)"
        else
            # Orphan or mismatched process - will be cleaned up by start_relay
            echo_info "Cleaning up stale relay..."
        fi
    fi

    # Check tunnel status
    if check_tunnel_running; then
        tunnel_was_running=true
        echo_info "Tunnel already running"
    fi

    # If both running correctly, nothing to do
    if [[ "$relay_needs_start" == "false" && "$tunnel_was_running" == "true" ]]; then
        echo_info "All services already running"
        cmd_status
        return 0
    fi

    # Start relay if needed
    if $relay_needs_start; then
        start_relay
    fi

    # Start tunnel if needed
    if [[ "$tunnel_was_running" == "false" ]]; then
        start_tunnel_and_get_url "true"
        need_slack_update=true
    fi

    # Update Slack Request URLs if we started a new tunnel
    if [[ "$need_slack_update" == "true" ]]; then
        if ! update_slack_request_url "${TUNNEL_URL}/slack/actions" "${TUNNEL_URL}/slack/events"; then
            echo_warn "Failed to update Slack, but tunnel is running"
            echo_warn "Manually set Request URLs:"
            echo_warn "  Actions: ${TUNNEL_URL}/slack/actions"
            echo_warn "  Events:  ${TUNNEL_URL}/slack/events"
        fi
    fi

    # Start/restart idle watchdog
    stop_watchdog 2>/dev/null || true
    start_watchdog

    touch "$ACTIVITY_FILE"

    echo_info "Remote tunnel running in background (PID: $TUNNEL_PID)"
}

# =============================================================================
# --stop: Stop background tunnel
# =============================================================================

cmd_stop() {
    local stopped=false

    stop_watchdog && stopped=true

    if [[ -f "$TUNNEL_PID_FILE" ]]; then
        local pid
        pid=$(cat "$TUNNEL_PID_FILE")
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            stopped=true
        fi
        rm -f "$TUNNEL_PID_FILE"
    fi

    # Kill any remaining localtunnel processes on our port
    local stale_count=0
    while IFS= read -r pid; do
        if [[ -n "$pid" ]]; then
            kill "$pid" 2>/dev/null || true
            ((stale_count++)) || true
        fi
    done < <(pgrep -f "lt --port.*${RELAY_PORT}" 2>/dev/null || true)

    if [[ "$stale_count" -gt 0 || "$stopped" == "true" ]]; then
        echo_info "Tunnel stopped"
        stopped=true
    fi

    rm -f "$TUNNEL_URL_FILE"

    stop_relay && stopped=true

    rm -f "$ACTIVITY_FILE"

    if [[ "$stopped" == "true" ]]; then
        echo_info "All services stopped"
    else
        echo_info "No services were running"
    fi
}

# =============================================================================
# --status: Check tunnel status
# =============================================================================

cmd_status() {
    echo ""
    echo -e "${BOLD}Remote Tunnel Status${NC}"
    echo ""

    # Check stable tunnel config
    if has_stable_tunnel; then
        local subdomain
        subdomain=$(get_localtunnel_subdomain)
        echo -e "  Mode:       ${GREEN}Localtunnel (stable URL)${NC}"
        echo -e "  URL:        ${CYAN}https://${subdomain}.loca.lt${NC}"
        echo ""
    else
        echo -e "  Mode:       ${YELLOW}Quick Tunnel${NC} (random URL each restart)"
        echo -e "              ${DIM}Run --stable for permanent URL${NC}"
        echo ""

        # Check Slack config (only needed for quick tunnels)
        if [[ -f "$SLACK_CONFIG_FILE" ]]; then
            load_slack_config
            echo -e "  Slack App:  ${CYAN}$SLACK_APP_ID${NC}"
            if is_token_expired; then
                echo -e "  Token:      ${YELLOW}Expired (will refresh on next use)${NC}"
            else
                echo -e "  Token:      ${GREEN}Valid${NC}"
            fi
        else
            echo -e "  Slack:      ${YELLOW}Not configured${NC} (run: remote-tunnel --setup)"
        fi
        echo ""
    fi

    # Check relay - detect orphans
    local relay_tracked_pid=""
    local relay_port_pid=""
    if [[ -f "$RELAY_PID_FILE" ]]; then
        relay_tracked_pid=$(cat "$RELAY_PID_FILE" 2>/dev/null)
    fi
    # Find process on port
    if command -v lsof &>/dev/null; then
        relay_port_pid=$(lsof -ti ":$RELAY_PORT" 2>/dev/null | head -1)
    elif command -v ss &>/dev/null; then
        relay_port_pid=$(ss -tlnp "sport = :$RELAY_PORT" 2>/dev/null | grep -oP 'pid=\K[0-9]+' | head -1)
    fi

    if check_relay_running; then
        if [[ -n "$relay_tracked_pid" ]] && [[ "$relay_tracked_pid" == "$relay_port_pid" ]]; then
            echo -e "  Relay:      ${GREEN}Running${NC} (PID: $relay_tracked_pid)"
        elif [[ -n "$relay_port_pid" ]]; then
            echo -e "  Relay:      ${YELLOW}Orphan process${NC} (PID: $relay_port_pid, not tracked)"
            echo -e "              ${DIM}Run: remote-tunnel --stop && remote-tunnel --background${NC}"
        else
            echo -e "  Relay:      ${GREEN}Running${NC}"
        fi
    else
        if [[ -n "$relay_tracked_pid" ]]; then
            echo -e "  Relay:      ${YELLOW}Stopped${NC} (stale PID file: $relay_tracked_pid)"
        else
            echo -e "  Relay:      ${YELLOW}Stopped${NC}"
        fi
    fi

    # Check tunnel
    if [[ -f "$TUNNEL_PID_FILE" ]]; then
        local pid
        pid=$(cat "$TUNNEL_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "  Tunnel:     ${GREEN}Running${NC} (PID: $pid)"
            if [[ -f "$TUNNEL_URL_FILE" ]]; then
                local url
                url=$(cat "$TUNNEL_URL_FILE")
                echo -e "  URL:        ${CYAN}$url/slack/actions${NC}"
            fi
        else
            echo -e "  Tunnel:     ${YELLOW}Stopped${NC} (stale PID file)"
        fi
    else
        echo -e "  Tunnel:     ${YELLOW}Stopped${NC}"
    fi

    # Check watchdog
    if [[ -f "$WATCHDOG_PID_FILE" ]]; then
        local pid
        pid=$(cat "$WATCHDOG_PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "  Watchdog:   ${GREEN}Running${NC}"
        else
            echo -e "  Watchdog:   ${YELLOW}Stopped${NC}"
        fi
    else
        echo -e "  Watchdog:   ${YELLOW}Stopped${NC}"
    fi

    # Check Mac tunnel URL
    if [[ -f "$CLAUDE_DIR/.mac-tunnel-url" ]]; then
        local mac_url
        mac_url=$(cat "$CLAUDE_DIR/.mac-tunnel-url")
        echo -e "  Mac URL:    ${DIM}$mac_url${NC}"
    fi

    # Check last activity
    if [[ -f "$ACTIVITY_FILE" ]]; then
        local last now elapsed
        last=$(stat -c %Y "$ACTIVITY_FILE" 2>/dev/null || echo 0)
        now=$(date +%s)
        elapsed=$((now - last))
        local remaining=$((IDLE_TIMEOUT - elapsed))
        if [[ $remaining -gt 0 ]]; then
            echo -e "  Idle timer: ${DIM}${remaining}s until auto-stop${NC}"
        fi
    fi

    echo ""
}

# =============================================================================
# Default: Interactive mode
# =============================================================================

cmd_interactive() {
    echo ""
    echo -e "${BOLD}Remote Tunnel for Claude Slack Buttons${NC}"
    echo -e "${DIM}Receive Slack button clicks when your Mac is closed${NC}"
    echo ""

    if ! load_slack_config; then
        echo_warn "Slack not configured yet."
        echo ""
        echo -ne "  ${YELLOW}?${NC} Run setup now? [Y/n] "
        read -r response
        if [[ "$response" =~ ^[Nn]$ ]]; then
            exit 0
        fi
        cmd_setup
        load_slack_config
    fi

    # Kill existing relay and start fresh (handles orphans)
    if check_relay_running; then
        echo_info "Stopping existing relay..."
        local old_pid
        old_pid=$(cat "$RELAY_PID_FILE" 2>/dev/null)
        if [[ -n "$old_pid" ]]; then
            kill "$old_pid" 2>/dev/null || true
            sleep 1
        fi
    fi
    start_relay

    # Cleanup on exit
    cleanup() {
        echo ""
        echo_info "Shutting down..."
        if [[ -n "${TUNNEL_PID:-}" ]]; then
            kill "$TUNNEL_PID" 2>/dev/null || true
        fi
        stop_relay
        rm -f "$TUNNEL_PID_FILE" "$TUNNEL_URL_FILE"
    }
    trap cleanup EXIT INT TERM

    # Start tunnel
    start_tunnel_and_get_url "false"

    # Update Slack Request URLs (actions + events)
    if update_slack_request_url "${TUNNEL_URL}/slack/actions" "${TUNNEL_URL}/slack/events"; then
        echo ""
        echo -e "${GREEN}╭──────────────────────────────────────────────────────────────╮${NC}"
        echo -e "${GREEN}│${NC}  ${GREEN}✓${NC} ${BOLD}Slack URLs updated!${NC}                                       ${GREEN}│${NC}"
        echo -e "${GREEN}╰──────────────────────────────────────────────────────────────╯${NC}"
        echo ""
        echo -e "  Actions URL: ${CYAN}${TUNNEL_URL}/slack/actions${NC}"
        echo -e "  Events URL:  ${CYAN}${TUNNEL_URL}/slack/events${NC}"
        echo ""
        echo -e "  ${DIM}Slack buttons and thread replies will now work.${NC}"
        echo -e "  ${DIM}Keep this running. Press Ctrl+C to stop.${NC}"
        echo ""
        echo -e "  ${BOLD}Note:${NC} Focus button won't switch windows (Mac not involved)."
        echo -e "  ${DIM}Only 1/2/Continue/Push buttons and thread replies work.${NC}"
    else
        echo ""
        echo -e "${YELLOW}╭──────────────────────────────────────────────────────────────╮${NC}"
        echo -e "${YELLOW}│${NC}  ${YELLOW}!${NC} ${BOLD}Could not auto-update Slack${NC}                               ${YELLOW}│${NC}"
        echo -e "${YELLOW}╰──────────────────────────────────────────────────────────────╯${NC}"
        echo ""
        echo -e "  Actions URL: ${CYAN}${TUNNEL_URL}/slack/actions${NC}"
        echo -e "  Events URL:  ${CYAN}${TUNNEL_URL}/slack/events${NC}"
        echo ""
        echo -e "  ${BOLD}Manually update in Slack:${NC}"
        echo -e "  ${CYAN}1.${NC} Go to ${BOLD}https://api.slack.com/apps/${SLACK_APP_ID}${NC}"
        echo -e "  ${CYAN}2.${NC} ${BOLD}Interactivity & Shortcuts${NC} → Set Request URL"
        echo -e "  ${CYAN}3.${NC} ${BOLD}Event Subscriptions${NC} → Set Request URL"
        echo -e "  ${CYAN}4.${NC} Click ${BOLD}Save Changes${NC} on each page"
    fi
    echo ""

    # Keep running until interrupted
    wait "$TUNNEL_PID" 2>/dev/null || true
}

# =============================================================================
# Main
# =============================================================================

case "${1:-}" in
    --setup)
        cmd_setup
        ;;
    --background)
        cmd_background
        ;;
    --stop)
        cmd_stop
        ;;
    --status)
        cmd_status
        ;;
    --help|-h)
        echo "Usage: remote-tunnel [command]"
        echo ""
        echo "Commands:"
        echo "  (none)        Start tunnel (uses stable URL, prompts to configure if needed)"
        echo "  --setup       Configure Slack API tokens (for auto-URL updates)"
        echo "  --background  Start tunnel in background"
        echo "  --stop        Stop background tunnel"
        echo "  --status      Check tunnel status"
        echo ""
        ;;
    --stable|"")
        cmd_stable
        ;;
    *)
        echo_error "Unknown command: $1"
        echo "Run: remote-tunnel --help"
        exit 1
        ;;
esac
