#!/bin/bash
# =============================================================================
# slack-tunnel - Start ngrok tunnel for Slack button actions
#
# This script:
# 1. Installs ngrok if not present
# 2. Configures ngrok auth token if needed
# 3. Starts the MCP server if not running
# 4. Creates an ngrok tunnel and displays the URL for Slack configuration
# =============================================================================

set -uo pipefail

MCP_PORT=8463
CLAUDE_DIR="$HOME/.claude"
MCP_SERVER="$CLAUDE_DIR/bin/mcp-server"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

echo_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
echo_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
echo_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Check if ngrok is installed
install_ngrok() {
    echo_info "Installing ngrok..."

    if [[ "$(uname)" == "Darwin" ]]; then
        # macOS
        if command -v brew &>/dev/null; then
            brew install ngrok/ngrok/ngrok
        else
            echo_error "Homebrew not found. Install ngrok manually:"
            echo "  https://ngrok.com/download"
            exit 1
        fi
    elif [[ "$(uname)" == "Linux" ]]; then
        # Linux - try apt first, then snap
        if command -v apt-get &>/dev/null; then
            curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
            echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
            sudo apt-get update && sudo apt-get install ngrok
        elif command -v snap &>/dev/null; then
            sudo snap install ngrok
        else
            echo_error "Could not install ngrok automatically. Install manually:"
            echo "  https://ngrok.com/download"
            exit 1
        fi
    else
        echo_error "Unsupported OS. Install ngrok manually:"
        echo "  https://ngrok.com/download"
        exit 1
    fi

    echo_info "ngrok installed successfully"
}

# Check ngrok auth token
setup_ngrok_auth() {
    # Try to check if auth is configured
    if ! ngrok config check &>/dev/null 2>&1; then
        echo ""
        echo -e "${YELLOW}╭────────────────────────────────────────────────────────────╮${NC}"
        echo -e "${YELLOW}│${NC}  ${BOLD}ngrok requires a free auth token${NC}                          ${YELLOW}│${NC}"
        echo -e "${YELLOW}╰────────────────────────────────────────────────────────────╯${NC}"
        echo ""
        echo -e "  ${CYAN}1.${NC} Sign up (free) at: ${BOLD}https://dashboard.ngrok.com/signup${NC}"
        echo -e "  ${CYAN}2.${NC} Copy your authtoken from: ${BOLD}https://dashboard.ngrok.com/get-started/your-authtoken${NC}"
        echo ""
        echo -ne "  ${YELLOW}?${NC} Paste your ngrok authtoken: "
        read -r token

        if [[ -z "$token" ]]; then
            echo_error "No token provided. Cannot continue."
            exit 1
        fi

        ngrok config add-authtoken "$token"
        echo_info "ngrok auth token configured"
    fi
}

# Check if MCP server is running
check_mcp_server() {
    if curl -s "http://localhost:$MCP_PORT/health" &>/dev/null; then
        return 0
    fi
    return 1
}

# Find the MCP server source directory
find_mcp_source_dir() {
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

    # Check if bin/mcp-server is a symlink pointing to repo
    if [[ -L "$CLAUDE_DIR/bin/mcp-server" ]]; then
        local target
        target="$(readlink "$CLAUDE_DIR/bin/mcp-server")"
        local repo_dir
        repo_dir="$(dirname "$target")/.."
        if [[ -d "$repo_dir/mcp-server/src" ]]; then
            echo "$repo_dir/mcp-server"
            return 0
        fi
    fi

    # Check relative to this script (development mode)
    if [[ -d "$script_dir/../mcp-server/src" ]]; then
        echo "$script_dir/../mcp-server"
        return 0
    fi

    return 1
}

# Check if source is newer than dist and rebuild if needed
rebuild_if_needed() {
    local mcp_source_dir
    if ! mcp_source_dir=$(find_mcp_source_dir); then
        # No source directory found, skip rebuild
        return 0
    fi

    local src_dir="$mcp_source_dir/src"
    local dist_dir="$mcp_source_dir/dist"
    local installed_dist="$CLAUDE_DIR/mcp-server-dist/dist"

    # Find newest source file
    local newest_src
    newest_src=$(find "$src_dir" -name "*.ts" -type f -exec stat -f "%m %N" {} \; 2>/dev/null | sort -rn | head -1 | cut -d' ' -f1)

    # Find oldest dist file (if dist exists)
    local oldest_dist=0
    if [[ -d "$dist_dir" ]]; then
        oldest_dist=$(find "$dist_dir" -name "*.js" -type f -exec stat -f "%m %N" {} \; 2>/dev/null | sort -n | head -1 | cut -d' ' -f1)
    fi

    # Rebuild if source is newer than dist
    if [[ -n "$newest_src" ]] && [[ "$newest_src" -gt "$oldest_dist" ]]; then
        echo_info "Source files changed, rebuilding MCP server..."
        (
            cd "$mcp_source_dir"
            if command -v bun &>/dev/null; then
                bun run build
            elif command -v npm &>/dev/null; then
                npm run build
            else
                echo_warn "No build tool found (bun/npm), skipping rebuild"
                return 0
            fi
        )

        # Copy to installed location if it exists
        if [[ -d "$installed_dist" ]]; then
            cp -r "$dist_dir"/* "$installed_dist"/
            echo_info "Updated installed MCP server"
        fi
    fi
}

# Start MCP server
start_mcp_server() {
    if [[ ! -x "$MCP_SERVER" ]]; then
        echo_error "MCP server not found at $MCP_SERVER"
        echo_error "Run install.sh first to build the MCP server"
        exit 1
    fi

    echo_info "Starting MCP server..."
    nohup "$MCP_SERVER" > "$CLAUDE_DIR/mcp-server.log" 2>&1 &
    MCP_PID=$!
    echo "$MCP_PID" > "$CLAUDE_DIR/.mcp-server.pid"

    # Wait for server to start
    for i in {1..10}; do
        if check_mcp_server; then
            echo_info "MCP server started (PID: $MCP_PID)"
            return 0
        fi
        sleep 0.5
    done

    echo_error "MCP server failed to start. Check $CLAUDE_DIR/mcp-server.log"
    exit 1
}

# Cleanup on exit - kill both ngrok and MCP server
cleanup() {
    echo ""
    echo_info "Shutting down..."
    if [[ -n "${NGROK_PID:-}" ]]; then
        kill "$NGROK_PID" 2>/dev/null || true
    fi
    if [[ -n "${MCP_PID:-}" ]]; then
        kill "$MCP_PID" 2>/dev/null || true
        rm -f "$CLAUDE_DIR/.mcp-server.pid"
        echo_info "MCP server stopped"
    fi
}
trap cleanup EXIT INT TERM

# Main
main() {
    echo ""
    echo -e "${BOLD}Slack Tunnel for Claude Notifications${NC}"
    echo -e "${DIM}Creates a public URL for Slack button actions${NC}"
    echo ""

    # Step 1: Check ngrok
    if ! command -v ngrok &>/dev/null; then
        install_ngrok
    fi

    # Step 2: Check auth
    setup_ngrok_auth

    # Step 3: Rebuild MCP server if source changed
    rebuild_if_needed

    # Step 4: Kill existing MCP server and start fresh (ensures new code is used)
    if check_mcp_server; then
        echo_info "Stopping existing MCP server..."
        local old_pid
        old_pid=$(cat "$CLAUDE_DIR/.mcp-server.pid" 2>/dev/null)
        if [[ -n "$old_pid" ]]; then
            kill "$old_pid" 2>/dev/null || true
            sleep 1
        fi
    fi
    start_mcp_server

    # Step 5: Start ngrok
    echo_info "Starting ngrok tunnel..."
    echo ""

    # Start ngrok and get the URL
    TUNNEL_URL=""

    # Start ngrok in background
    ngrok http "$MCP_PORT" --log=stdout --log-format=json > "$CLAUDE_DIR/.ngrok.log" 2>&1 &
    NGROK_PID=$!

    # Wait for URL to appear in logs
    for i in {1..30}; do
        if [[ -f "$CLAUDE_DIR/.ngrok.log" ]]; then
            TUNNEL_URL=$(grep -oE '"url":"https://[^"]+' "$CLAUDE_DIR/.ngrok.log" 2>/dev/null | head -1 | cut -d'"' -f4 || true)
            if [[ -n "$TUNNEL_URL" && "$TUNNEL_URL" == https://* ]]; then
                break
            fi
        fi
        sleep 0.5
    done

    if [[ -z "$TUNNEL_URL" ]]; then
        echo_error "Failed to get ngrok tunnel URL"
        cat "$CLAUDE_DIR/.ngrok.log" 2>/dev/null | tail -5
        exit 1
    fi

    # Display the URL and configuration steps
    echo ""
    echo -e "${CYAN}╭──────────────────────────────────────────────────────────────╮${NC}"
    echo -e "${CYAN}│${NC}                                                              ${CYAN}│${NC}"
    echo -e "${CYAN}│${NC}  ${BOLD}Slack Interactivity URL:${NC}                                   ${CYAN}│${NC}"
    echo -e "${CYAN}│${NC}                                                              ${CYAN}│${NC}"
    echo -e "${CYAN}│${NC}  ${BOLD}${TUNNEL_URL}/slack/actions${NC}"
    echo -e "${CYAN}│${NC}                                                              ${CYAN}│${NC}"
    echo -e "${CYAN}╰──────────────────────────────────────────────────────────────╯${NC}"
    echo ""
    echo -e "  ${BOLD}Configure your Slack app:${NC}"
    echo -e "  ${CYAN}1.${NC} Go to ${BOLD}https://api.slack.com/apps${NC} → your app"
    echo -e "  ${CYAN}2.${NC} Click ${BOLD}Interactivity & Shortcuts${NC}"
    echo -e "  ${CYAN}3.${NC} Toggle ${BOLD}Interactivity${NC} to On"
    echo -e "  ${CYAN}4.${NC} Paste the URL above into ${BOLD}Request URL${NC}"
    echo -e "  ${CYAN}5.${NC} Click ${BOLD}Save Changes${NC}"
    echo ""

    # Wait for user to confirm
    echo -ne "  ${YELLOW}?${NC} Press ${BOLD}Enter${NC} when you've completed the steps above (or ${BOLD}q${NC} to quit): "
    read -r response

    if [[ "$response" == "q" || "$response" == "Q" ]]; then
        echo_info "Tunnel stopped"
        kill "$NGROK_PID" 2>/dev/null || true
        exit 0
    fi

    # Verify the connection
    echo ""
    echo -e "  ${DIM}Verifying connection...${NC}"

    if curl -sf "${TUNNEL_URL}/health" --max-time 10 >/dev/null 2>&1; then
        echo ""
        echo -e "${GREEN}╭──────────────────────────────────────────────────────────────╮${NC}"
        echo -e "${GREEN}│${NC}  ${GREEN}✓${NC} ${BOLD}Connection verified successfully!${NC}                         ${GREEN}│${NC}"
        echo -e "${GREEN}╰──────────────────────────────────────────────────────────────╯${NC}"
        echo ""
        echo -e "  ${BOLD}You're all set! To start receiving notifications:${NC}"
        echo -e "  Run ${CYAN}/slack-notify${NC} in Claude Code in your preferred terminal"
        echo ""
        echo -e "  ${DIM}Keep this tunnel running. Press Ctrl+C to stop.${NC}"
    else
        echo ""
        echo -e "${RED}╭──────────────────────────────────────────────────────────────╮${NC}"
        echo -e "${RED}│${NC}  ${RED}✗${NC} ${BOLD}Connection verification failed${NC}                            ${RED}│${NC}"
        echo -e "${RED}╰──────────────────────────────────────────────────────────────╯${NC}"
        echo ""
        echo -e "  ${BOLD}Troubleshooting:${NC}"
        echo -e "  ${CYAN}1.${NC} Verify the URL was saved correctly in Slack"
        echo -e "  ${CYAN}2.${NC} Make sure you clicked ${BOLD}Save Changes${NC} in Slack"
        echo -e "  ${CYAN}3.${NC} Check that the MCP server is running: ${DIM}curl http://localhost:${MCP_PORT}/health${NC}"
        echo -e "  ${CYAN}4.${NC} Try the URL directly: ${DIM}curl ${TUNNEL_URL}/health${NC}"
        echo ""
        echo -e "  ${DIM}Press Enter to retry verification, or Ctrl+C to quit${NC}"

        # Allow retry
        while true; do
            read -r
            echo -e "  ${DIM}Retrying...${NC}"
            if curl -sf "${TUNNEL_URL}/health" --max-time 10 >/dev/null 2>&1; then
                echo ""
                echo -e "  ${GREEN}✓${NC} ${BOLD}Connection verified!${NC}"
                echo ""
                echo -e "  ${BOLD}You're all set! To start receiving notifications:${NC}"
                echo -e "  Run ${CYAN}/slack-notify${NC} in Claude Code in your preferred terminal"
                echo ""
                echo -e "  ${DIM}Keep this tunnel running. Press Ctrl+C to stop.${NC}"
                break
            else
                echo -e "  ${RED}✗${NC} Still failing. Press Enter to retry, or Ctrl+C to quit"
            fi
        done
    fi

    # Keep running until interrupted
    wait "$NGROK_PID" 2>/dev/null || true
}

main "$@"
